# InnoDB存储引擎

InnoDB是**事务安全**的MySQL存储引擎。通常来说InnoDB存储引擎是**OLTP应用**中核心表的首选存储引擎。

> OLTP：联机事务处理（Online Transaction Processing），是传统的关系型数据库的主要应用，主要是基本的、日常的事务处理，例如银行交易。它表示事务性非常高的系统，以小的事务以及小的查询为主。

## 概述

InnoDB是第一个完整支持ACID事务的MySQL存储引擎，它的特点是**行锁设计、支持MVCC、支持外键、提供一致性非锁定读，**同时被设计用来最有效的利用以及使用内存和CPU。

许多实践证明了InnoDB是一个**高性能、高可用、高可扩展**的存储引擎。

## InnoDB体系架构

InnoDB存储引擎主要由后台线程和内存池组成。

InnoDB存储引擎中有多个内存块，这些内存块组成了一个大的内存池，负责：

* 维护所有进程/线程需要访问的多个内部数据结构
* 缓存磁盘上的数据，方便快速的读取，同时在对磁盘文件的数据修改之前在这里缓存
* 重做日志（redo log）缓冲

后台线程的主要任务是：

* 刷线内存池中的数据，保证缓冲池中的内存缓冲是最近的数据
* 将已经修改的数据文件刷新到磁盘文件
* 保证数据库在发生异常情况时能恢复到正常运行状态

### 后台线程

InnoDB是多线程模型，后台有不同的线程负责不同的任务

#### Master Thread

负责脏页刷新，合并插入缓冲，undo页的回收等

#### IO Thread

InnoDB中大量使用AIO来处理IO请求，这样可以极大提高数据库性能。IO Thread的工作主要是负责这些IO请求的回调。

#### Purge（清除净化） Thread

事务被提交之后，其所使用的undolog可能不在需要，因此需要PurgeThread来回收已经使用并分配的undo页。

可以支持多个Purge Thread进行回收

#### Page Cleaner Thread

将脏页的刷新操作放到单独线程中完成，减轻原来Master Thread的工作以及对用户查询线程的阻塞。

### 内存

包括缓冲池，重做日志缓冲和额外内存池

#### 缓冲池

缓冲池是一块内存区域，通过内存来弥补磁盘速度较慢对数据库性能的影响。

读取页操作时：首先将从磁盘读到的页存放到缓冲池中，这个过程称为将页“FIX”在缓冲池中，下一次再读到相同的页时，首先判断页是否在缓冲池中，如果在，该页被命中，直接读取，如果不在，从磁盘读取。

更新操作时：首先修改在缓冲池中的页，然后以一定的频率刷新到磁盘上，注意：页从缓冲池刷新回磁盘的操作并不是在每次页发生更新时触发，而是通过一种称为Checkpoint的机制刷新回磁盘。

缓冲池中缓存的数据页类型有：索引页，数据页，undo页，插入缓冲，自适应哈希索引，InnoDB存储的锁信息，数据字典信息等。缓存索引页和数据页占了很大一部分。

<img src="C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220205102417359.png" alt="image-20220205102417359" style="zoom:67%;" />

Innodb可以支持多个缓冲池实例，每个页根据哈希值平均分配到不同缓冲池实例中，减少数据库内部资源竞争，增加数据库的并发处理能力

#### 管理缓冲池—LRU list

通常来说，数据库中的缓冲池是通过LRU算法来管理的。但是InnoDB存储引擎对传统的LRU算法做了一些优化，在InnoDB的存储引擎中，LRU列表中还加入了**midpoint位置**，读取到的新页，虽然是最新的，但是并不是直接放到list的首，而是放到midpoint位置，默认为长度的5/8处。

midpoint之后的了表称为old列表，之前的列表称为new列表。（默认页的生存周期都比较短）

为什么要加入midpoint位置？

* 某些SQL操作可能要读取很多页，但是这些页很长时间就会使用这一次，那么这种操作就会将热点页从LRU列表中移除，因此设置midpoint点可以防止这种事情发生。

但是什么时候将页放到LRU的热端？

* 通过设置参数innodb_old_blocks_time，表示页读取到mid位置后需要多长时间才会被加入到LRU列表的热端

#### 管理缓冲池—Free List

LRU列表用来管理已经读取到的页，但是当数据库刚启动时，LRU列表是空的，即没有任何的页。这时候空页都存放在Free列表中。

当需要从缓冲池中分页时，首先重Free列表中查找是否有可用的空闲页，如果有则将该页从Free列表中删除，放入LRU列表中。否则，根据LRU算法，淘汰LRU列表末尾的页，将该内存空间分配给新的页。

由于Innodb支持压缩页功能，即将原本16KB的页压缩到1KB、2、4、8KB。由于页大小发生改变，LRU列表也要发生改变。对于非16KB的页，是通过unzip_LRU列表进行管理的。

#### 管理缓冲池—Flush List

在LRU列表被修改后，称该页为脏页（dirty page），即缓冲池中的页和磁盘上的页的数据产生了不一致。此时数据库会通过checkpoint机制将脏页刷新回磁盘，而**flush列表中的页就是脏页列表**。

需要注意的是，脏页即存在于LRU列表中，也存在与FLUSH列表中，LRU用来管理缓冲池中页的可用性，flush列表用来管理页刷新回磁盘，二者不影响。

#### 重做日志缓冲

InnoDB首先将重做日志信息存放到这个缓冲区，然后按照一定频率将其刷新到重做日志文件，重做日志缓冲一般不需要设置得很大，因为一般情况下每一秒会将日志缓冲刷新到日志文件，因此用户只需要保证每秒产生的事务量在这个缓冲大小之内即可。

通常情况下，8M的重做日志缓冲池除以满足大部分应用，重做日志缓冲会在一下情况下刷新到磁盘：

* Master Thread每一秒将重做日志刷新到磁盘
* 每个事务提交时会将重做日志缓冲刷新到重做日志文件
* 当重做日志缓冲池剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件。

#### 额外的内存

在对一些数据结构本身的内存进行分配时，需要从额外的内存池中进行申请，当该区域的内存不够时，会从缓冲池中进行申请。

## checkpoint技术

checkpoint技术所做的事情就是将缓冲池中的脏页刷回到磁盘

当前事务数据库系统普遍采用Write Ahead Log策略，就是当事务提交时，先写重做日志，再修改页。当由于发生宕机导致数据丢失时，通过重做日志来完成数据的恢复，这也是事务ACID中 D（Durability持久性）的要求

checkpoint技术是为了解决一下几个问题：

* 缩短数据库的恢复时间
* 缓冲池不够用时，将脏页刷新到磁盘
* 重做日志不可用时，刷新脏页

对于InnoDB而言，通过LSN（Log Sequence Number）来标记版本的，而LSN是8字节的数字，单位是字节，每个页有LSN，重做日志有LSN，Checkpoint也有LSN。

Innodb有两种Checkpoint：

* Sharp Checkpoint：在数据库关闭时将所有脏页刷新回磁盘，默认工作方式。
* Fuzzy Checkpoint

Innodb中可能发生一下几种情况的Fuzzy Checkpoint：

* Master Thread Checkpoint
* FLUSH_LRU_LIST Checkpoint
* Async/Sync Flush Checkpoint
* Dirty Page too much Checkpoint

Master Thread中发生的Checkpoint以每秒或每十秒速度从缓冲池中的**脏页列表中**刷新一定比例的页回磁盘，这个过程是异步的。

FLUSH_LRU_LIST Checkpoint是因为Innodb需要保证LRU列表中需要有差不多100个空闲的页可供使用。这个检查被放到Page Cleaner线程中执行。**此时的脏页是LRU尾部的脏页**

Async/Sync Flush Checkpoint指的是重做日志文件不可用的情况。此时脏页是从**脏页列表中**选取的。它是为了保证重做日志循环使用的可用性。

Dirty Page too much Checkpoint即脏页数量太多导致InnoDB存储引擎强制进行Checkpoint，其目的总的来说还是为了保证缓冲池中有足够可用的页。

## Master Thread工作方式

## Innodb关键特性

### 插入缓冲

**Insert Buffer**

Insert Buffer是针对于非聚集索引的插入或更新操作的。当对非聚集索引进行插入或更新操作时，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，若在，则直接插入，若不在，则先放到一个Insert Buffer对象中，然后再以一定的频率和情况进行Insert Buffer和辅助索引页子节点的merge操作，这时候通常能将多个插入合并到一个操作中，因为在一个索引页中，这就大大提高了对非聚集索引插入的性能。

Insert Buffer的使用需要同时满足一下两个条件：

* 索引是辅助索引，如果是聚集索引，直接插入即可，因为没有随机访问，
* 索引不是唯一的，如果索引是唯一的，那么在插入之前还要随机的去判断索引是否重复，这就没有使用插入缓冲的必要了。

缺点：

* 如果大量的插入操作使用了Insert Buffer，此时数据库发生了宕机，势必有大量的Insert Buffer没有合并到实际的非聚集索引中去，因此此时数据库恢复可能需要很长时间。
* 在密集写的情况下，Insert Buffer会占用过多缓冲池内存。

**Change Buffer**



### 两次写

### 自适应哈希索引

### 异步IO

### 刷新邻接页

