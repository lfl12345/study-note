# Unix下5种IO模型

UNIX 系统下的 I/O 模型有 5 种：

* 阻塞IO
* 非阻塞IO
* IO复用（select、poll、epoll）
* 信号驱动IO
* 异步IO（POSIX的aio_系列函数）

**如何理解UnixIO模型中的阻塞与非阻塞、同步与异步：**

* 区分同步和异步：同步是一种可靠的有序的运行机制，当我们使用同步操作时，后续操作是等待当前调用返回才进行下一步；而异步相反，其他任务不需要等待当前调用的返回就可以执行，通常依靠事件、回调等机制来实现任务间的次序关系。

> 感觉同步和异步可以用来描述两个进程之间的关系，也可以用来描述方法调用。例如同步可以指两个进程之间是同步的，比如网络消息的发送，也可以用来指两个方法之间是同步的。

* 阻塞和非阻塞：在进行阻塞操作时，当前进程会处于阻塞状态，无法从事其他任务，只有当条件就绪才能继续，比如 ServerSocket 新连接建立完毕，或数据读取、写入操作完成；而非阻塞则是不管条件（数据）是否就绪直接返回，进程不会因为数据没有准备好而进入阻塞状态。

**一个输入操作通常包含两个不同的阶段：**

* **用户线程等待内核将数据从网卡（或者其他数据源）拷贝到内核空间，此时数据算是准备好了**
* **从内核向用户空间的进程复制数据**

**各种IO模型的区别就是：它们实现这两个步骤的方式是不一样的**

对于套接字上的输入操作，第一步通常涉及等待数据从网络中到达，当等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区赋值到应用进程缓冲区。

## 阻塞式IO模型

最流向 IO模型是阻塞式IO模型（blocking IO）。

![image-20220105110816521](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220105110816521.png)

进程调用recvfrom，其系统调用知道数据报到达且被复制到应用进程的缓冲区中或者发生错错误才返回。最常见的错误时系统调用被信号中断。进程在从调用recvfrom开始到它返回的整段时间内是被阻塞的，进程让出CPU，内核等待数据从网络中到达内核中的缓冲区，然后唤醒进程，进程的系统调用recvfrom成功的从内核的缓冲区将数据拷贝到用户\进程缓冲区，然后recvfrom成功返回，应用进程开始处理数据报。

## 非阻塞IO模型

进程把一个套接字设置成非阻塞是在通知内核：当所请求IO操作非得把本进程投入睡眠才能完成时，不要把本进程投入睡眠，而是返回一个错误。

![image-20220105111337849](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220105111337849.png)

前三次recvfrom时没有数据可返回，因此内核转而立即返回一个错误。第四次调用recvfrom时已经有一个数据准备好，它被复制到应用进程缓冲区，于是recvfrom成功返回，进程接着处理数据。

当一个应用进程像这样对一个非阻塞描述符循环调用recvfrom时，我们称之为**轮询**（polling）。应用进程持续轮询内核，已查看某个操作是否就绪。这么做往往消耗大量的CPU时间。

## IO复用模型

我们可以使用select、poll、epoll实现IO复用，这样进程会阻塞在这三个系统调用中的某一个上，而不是阻塞在真正的IO系统调用上。

![image-20220105111825388](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220105111825388.png)

进程阻塞在select系统调用上，等待数据报套接字变为可读。当select返回套接字可读这一条件时，我们调用recvfrom把所读数据报复制到应用进程缓冲区。

IO复用和阻塞IO相比好像没有什么优势，都会阻塞到一个系统调用上，然后IO系统调用有数据之后，应用进程才可以读取数据，事实上由于使用select需要两个而不是单个系统调用，IO复用还稍有劣势。但是IO复用有一个很大的优点，就是我们可以同时等待多个描述符就绪。

IO复用模型和多线程中使用阻塞式IO模型很相似。

## 信号驱动式IO模型

我们可以使用信号，让内核在描述符就绪时发送SIGIO信号通知我们。这种模型就是信号驱动式IO模型（signal-driven IO）

![image-20220105112810572](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220105112810572.png)

进程首先开启套接字的信号驱动式IO功能，然后通过sigaction系统调用安装一个信号处理函数。该系统调用立即返回，进程可以继续工作，也就是进程没有被阻塞。当数据报准备好读取数据时，内核就为该进程产生一个SIGIO信号。进程随后就可以在信号处理函数中调用recvfrom读取数据，并通知主循环数据已准备好待处理，也可以立即通知主循环让它读取数据报。

无论如何处理SIGIO信号，这种模型的优势在于等待数据报到达期间进程不被阻塞。主循环可以继续执行，只要等待来自信号处理函数的通知：既可以是数据已准备好被处理，也可以是数据报已准备好被读取。

## 异步IO模型

异步IO由POSIX规范定义。一般来说，这些异步函数的工作机制是：告诉内核启动某个操作，并让内核在整个操作（包括将数据从内核复制到我们自己的缓冲区）完成后通知我们，这种模型与信号驱动IO模型的主要区别是：信号驱动模型是由内核通知进程何时启动一个IO操作，而异步IO模型是由内核通知我们IO操作何时完成。

![image-20220105114859580](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220105114859580.png)

进程调用aio_read函数（POSIX异步IO函数以aio或lio开头），给内核传递文件描述符，缓冲区指针，缓冲区大小（与read相同的三个参数）和文件偏移（与lseek类似），并告诉内核当整个操作完成时如何通知我们。该系统调用立即返回，而且在等待IO完成期间，进程不被阻塞。

本例子中我们假设要求内核在操作完成时产生某种信号，该信号直到数据已复制到应用进程缓冲区才产生，这一点不同于信号驱动IO模型。

## 各种IO模型的比较

这五种不同的IO模型，前四种模型的主要区别在于IO操作的第一个阶段，因为他们第二个阶段都是一样的，都是由进程通过系统调用将数据复制到进程的缓冲区中，也就是数据从内核复制到调用者的缓冲区期间，进程阻塞于recvfrom调用，反之，异步IO模型在这两个阶段都是内核处理的，不同于其他四种模型。

## 同步IO和异步IO对比

POSIX把这两个术语定义如下：

* 同步IO操作导致请求进程阻塞，知道IO操作完成
* 异步IO操作不导致请求进程阻塞

![image-20220105115625879](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220105115625879.png)

根据上述定义，前四种模型都是同步IO模型，因为真正的IO操作将阻塞进程，只有异步IO模型才是真正的异步IO。

# Java中的IO模型

## Java BIO

### 伪异步IO编程

如果进来一个socket，使用一个线程去处理socket发送的数据，那么随着客户端并发访问增加，服务端将呈现1:1的线程开销，访问量越大，系统将发生线程栈溢出，线程创建失败。

使用线程池和任务队列的方式可以实现一种伪异步IO通信框架，当客户端接入时，将客户端的Socket封装成一个Task（该任务实现Runnable接口）交给后端的线程池中处理。JDK的线程池维护一个消息队列和N个活跃的线程，对消息队列中Socket任务进行处理，由于线程池可以设置消息队列大小和最大线程数，因此，它占用的资源时可控的，无论多少客户端并发访问，都不会导致资源的耗尽和宕机。

总结

* 伪异步IO采用了线程池实现，因此避免了为每个请求创建一个独立线程而造成线程资源耗尽的问题，但是由于底层依然是采用的同步阻塞模型，因此无法从根本上解决问题。
* 如果单个消息处理的缓慢，或者服务器线程池中的全部线程都被阻塞，那么后续socket的IO消息将在队列中牌堆。新的Socket请求将被拒绝，客户端回发生大量连接超时。

### BIO模式下的端口转发思想

## Java NIO

### Java NIO基本介绍

Java NIO（New IO）也有人称之为java non-blocking IO 是从Java 1.4 版本开始引入的一个新的IO API，可以代替标准的Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持**面向缓冲区**的、基于**通道**的IO操作。NIO讲义更加高效的方式进行文件的读写操作。

NIO可以理解为非阻塞IO，传统的IO的read和write只能阻塞执行，线程在读写IO期间不能干其他事情，比如调用socket.read()时，如果服务器一直没有数据传输过来，线程就一直阻塞，而NIO中可以配置socket为非阻塞模式。

NIO相关类都被放在java.nio包以及子包下，并对原来的Java.io包中的很多类进行改写。

NIO有三大核心部分：Channel(通道)、Buffer(缓冲区)、Selector(选择器)

JavaNIO的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直到数据变得可以读取之前，改线程可以继续做其他任何事情。非阻塞写也是如此，一个线程请求写入一些数据到某个通道，但是不需要等待他完全写入，这个线程同时可以去做别的事情。

通俗理解：NIO可以做到用一个线程来处理多个操作。

### NIO 和 BIO 的比较

* BIO以流的方式处理数据，而NIO以块的方式处理数据，块IO的效率比流IO高很多（有待考证）

* BIO是阻塞的，NIO是非阻塞的
* BIO是基于字节流和字符流进行操作，而NIO基于Channel(通道)和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入通道中。Selector(选择器)用于监听多个通道事件（比如：连接请求，数据到达请求），因此可以使用单线程监听多个客户端通道

| NIO                       | BIO                   |
| ------------------------- | --------------------- |
| 面向缓冲区（Buffer）      | 面向流（Stream）      |
| 非阻塞（Non blocking IO） | 阻塞IO（Blocking IO） |
| 选择器（Selectors）       |                       |

### NIO 三大核心原理

NIO 有三个核心部分：**Channel（通道）、Buffer（缓冲区）、Selector（选择器）**

#### Buffer缓冲区

缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该快内存。相比较直接对数组的操作，Buffer API更容易操作和管理。

#### Channel通道

Java NIO的通道类似流，但又有些不同：既可以从通道中读取数据，又可以写数据到通道。但流的（input或output）读写通常是单向的，通道可以非阻塞读取和写入，通道可以支持读取或写入缓冲区，也可以支持异步的读写。

#### Selector选择器

Selector是一个Java NIO组件 ，能检查一个或多个NIO通道，并确定哪些通道已经准备好进行读取或写入。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接，提高效率。

* 每个channel都会对应一个Buffer
* 一个线程对应一个Selector，一个Selector对应多个channel(连接)
* 程序切换到那个channel是由事件决定的
* Selector会根据不同的事件，在各个通道上切换
* Buffer就是一个内存块，底层是一个数组
* 数据的读取写入是通过Buffer完成的，BIO中要么是输入流，或者是输出流，不能双向。但是NIO的Buffer是可以读也可以写。
* Java NIO系统的核心在于：通道（Channel）和缓冲区（Buffer）。通道表示打开的IO设备（例如：文件，套接字，网络中的连接），若需要使用NIO系统，需要获取用于IO设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理。简而言之，Channel负责传输，Buffer负责存取数据。

### NIO核心一：缓冲区 Buffer

一个用于特定基本数据类型的容器。有java.nio包定义，所有缓冲区都是Buffer抽象类的子类。Java NIO中的Buffer主要用于与NIO通道进行交互，数据是从通道读入缓冲区，从缓冲区写入通道。

#### Buffer类及其子类

Buffer就像一个数组，可以保存多个相同类型的数据，根据数据类型的不同，有一下Buffer常用子类：

* ByteBuffer（抽象类）
  * MappedByteBuffer
  * DirectByteBuffer
  * HeapByteBuffer

* CharBuffer
* ShortBuffer
* IntBuffer
* LongBuffer
* FloatBuffer
* DoubleBuffer

上述Buffer类都采用相似的方法进行管理数据，只是各自管理的数据类型不同而已，都是通过如下方法获取一个Buffer对象：

```java
static xxxBuffer allocate(int capacity):创建一个容量为capacity的xxxBuffer对象
```

#### 缓冲区基本属性

Buffer中重要概念：

* 容量（Capacity）
* 限制（limit）

#### 直接与非直接缓冲区

byte buffer可以使两种类型，一种是基于直接内存（也就是非堆内存），另一种是非直接内存（也就是堆内存）。对于直接内存来说，JVM将会在IO操作上具有更高的性能，因为他直接作用域本地系统的IO操作。而非直接内存，也就是堆内存中的数据，如果要做IO操作，会先从本进程内存复制到直接内存中，再利用本地IO处理。

从数据流的角度，非直接内存是下面这样的作用链：

```tex
本地IO--》直接内存--》非直接内存--》直接内存--》本地IO
```

而直接内存是：

```java
本地IO--》直接内存--》本地IO
```

很明显，在做IO处理时，比如网络发送大量数据时，直接内存会具有更高的效率。直接内存使用allocateDirect创建，但是它比申请普通的堆内存需要消耗更高的性能。不过，这部分数据是在JVM之外的，因此他不会占用应用的内存，所以当有很大的数据需要缓存，并且它的生命周期又很长，那么就比较适合使用直接内存。知识一般来说，如果不是能带来很明显的性能提升，还是推荐使用堆内存。可以使用isDirect()方法来确定字节缓冲区是堆内存还是直接内存。

直接内存使用场景

* 有很大的数据需要存储，它的生命周期长
* 适合频繁的IO操作，比如网络并发场景

### NIO核心二：Channel通道

Channel表示IO源与目标打开的连接。Channel类似于传统的流，只不过Channel本身不能访问数据，Channel只能与Buffer进行交互。

NIO的Channel类似于流，区别如下：

* 通道可以同时进行读写，而流只能读或者只能写
* 通道可以实现异步读写数据
* 通道可以从缓冲区读数据，也可以写数据到缓冲区

BIO中的Stream是单向的，而NIO中的通道是双向的。

Channel在NIO中是一个接口

```java
public interface Channel extends Closeable{}
```

#### 常用的Channel实现类

* FileChannel：用于读取、写入、映射和操作文件的通道
* DatagramChannel：通过UDP读写网络中的数据通道
* SocketChannel：通过TCP读写网络中的数据
* ServerSocketChannel：可以监听新进来的TCP连接，对每一个新进来的连接都会创建一个SocketChannel。

#### FileChannel类

可以通过对支持通道的对象调用getChannel方法获取通道。支持通道的类如下：

* FileInputStream
* FileOutputStream
* RandomAccessFile
* DatagramSocket
* Socket
* ServerSocket

还可以通过使用Files类的静态方法newBytesChannel获取字节通道，或者通过通道的静态方法open打开并返回指定通道。

### NIO核心三：Selector选择器

使用**多线程实现服务端**的缺点：

* 内存占用高
* 线程上下文切换成本高
* 只适合连接数少的场景

使用**线程池实现服务端**的缺点：

* 阻塞模式下，线程仅能处理一个socket连接
* 仅适合短连接场景

选择器Selector是SelectableChannel对象的多路复用器，Selector可以同时监控多个SelectableChannel的IO状况，也就是说，利用Selector可以使一个单独的线程管理多个Channel。Selector是非阻塞IO的核心。

Java的NIO，使用非阻塞IO的方式。可以使用一个线程，处理多个客户端连接，这时就要使用到Selector选择器

Selector能检测多个注册的通道上是否有事件发生（注意：多个Channel以事件的方式可以注册到同一个Selector），如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。

只有在连接\通道真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程。

避免了线程之间的上下文切换导致的开销。

#### 选择器selector的应用

## Java AIO

Java AIO（NIO.2）: 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的IO请求都是由OS先完成了再通知服务器应用去启动线程进行处理。

与NIO不同，当进行读写操作时，只需直接调用API的read和write方法即可，这两种方法均为异步的，对于读操作而言，当有流可读入时，操作系统会将可读入的流传入read方法打的缓冲区，对于写操作而言，当操作系统将write方法传递的流写完之后，操作系统主动通知应用程序

可以理解为read和write方法都是异步的，完成后会主动调用回调函数。在JDK1.7中，这部分内容被称为NIO.2，主要在java.nio.channels包下增加了下面四个异步通道

```java
AsynchronousSocketChannel
AsynchronousServerSocketChannel
AsynchronousFileChannel
AsycnhronousDatagramChannel
```

## Java IO模型总结

Java BIO：同步并阻塞，服务器试下模式为一个连接一个线程，即客户端有连接请求时服务器端就启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。

Java NIO：同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有IO请求时才启动一个线程进行处理。

Java AIO（NIO.2）：异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的IO请求都是由OS先完成了再通知服务器应用去启动线程进行处理。

BIO NIO AIO适用场景分析：

BIO方式适用不连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中

NIO方式适用于连接数目多而且连接比较短（轻操作）的架构，比如聊天服务器，并发局限不应用中，编程复杂。

AIO方式适用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程复杂