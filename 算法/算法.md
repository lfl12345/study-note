![image-20211113131636002](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20211113131636002.png)

前缀和

#### [约瑟夫环](https://blog.csdn.net/tingyun_say/article/details/52343897)

可以转换为递归问题去求解。

1-n个喊道m就退出

全排列

有限状态机

数字序列中某一位的数字

### **整数中1出现的次数（从1到n整数）**

枚举每一位上出现1 的次数。

```java
public class Solution {
    public int NumberOf1Between1AndN_Solution(int n) {
        int ans = 0;
        int digit = 1;
        while(n>=digit){
            ans += (n/(digit*10))*digit+Math.min(Math.max(n%(digit*10)-digit+1,0),digit);
            digit*=10;
        }
        return ans;
    }
}
```

#### 摩尔投票法、候选法（最优解）：寻找（确定个数的）众数

前提：众数是比数组中所有的数出现次数都多的数。

因此我们可以使用候选的方式去选择众数。

1. 创建一个候选对象表示当前选择出来的数，创建一个标志位代表当前候选对象“出现的次数”
2. 如果标志位为0，那么把遍历得到的对象自动的作为候选对象
3. 如果标志位不为1并且遍历得到的对象和候选对象一样，则标志位加一
4. 如果标志位不为1并且遍历得到的对象和候选对象不一样，标志位减一
5. 最后得到的候选对象就是众数

### 丑数（天坑）

**使用先比较再插入的方式：**

1. 定义三个标志位，用于标志2、3、5这三个质数走到的位置（他们的几倍）
2. 从三个中选择最小的放入列表中，同时这个最小的数所对应的标志位要加1（如果有多个对应例如：2*3==3**2）这样的都要加一，**避免重复。**
3. 循环找到所要找到的那一个。

**使用先插入后比较**（使用优先队列）：

1. 定义一个优先队列，定义一个**set用于去重**（需要注意的是，队列里的类型是long，为了确保在得到目的int型的丑数之前，所有的数都不会溢出，如果溢出就会变成负数，影响结果）
2. 从队列的头获取数值，把数值的2、3、5倍加入队列

## 树

Hash树

### 前缀树（Trie）（字典树/单词查找树/键树 ）

这种数据结构对应的操作有插入、搜索一个整体、是否存在前缀。

一个Trie中一般会存在root、children（数组、hashMap）、结束标志符flag、当前结点值（如果结束的话）。

前缀树可以高效地存储和检索字符串数据集中的键，这一个数据结构有相当多的应用场景，例如：自动补全和拼写检查。

### 树/图中的路径和

1. 判断是否存在一条路径（从根到孩子）

使用递归深度优先遍历，过程为：

* 如果为叶子点且sum=root.val返回true，为叶子结点且sum！=root.val返回false
* 如果root==null，返回false；
* 继续遍历root的左子树和右子树

2. 找出所有满足和为给定值的路径（从根到孩子）

使用递归深度优先遍历：

* 首先定义两个全局变量：一个存储所有ans，另一个存储满足条件的路径
* 如果遍历到的结点的值等于预期值，那么使用这条路径构造一个新的路径加入ans
* 判断左右子树是否为null，不为null的继续遍历
* 把结点从满足条件的路径中剔除

3. 找出所有满足和为给定值的路径（任意结点开始，任意结点结束）个数

* 定义一个全局变量为ans
* 首先最外层遍历整个树
* 然后内层从遍历到的每个结点开始使用深度变量这个子树
* 如果遍历的子树有满足条件的结点，ans++，直到遍历到叶子结点。

### 二叉搜索树的后序遍历

二叉树的后序遍历可以利用二叉树的先序遍历转换，

1. 先把序遍历的顺序变为根、右、左，然后把这个顺序保存在一个栈中，
2. 最后从栈中弹出的顺序就是后序遍历的顺序——左、右、根。

## 位运算

### 二进制中1的个数

使用val&（val-1）可以快速的消除val最右边的1。例如：110100&110011=110000。拥有了这个性质，我们就可以直接循环，然后使用val&（val-1），当val为零时，循环的次数就是1的个数。

### 两个数相加

首先如果两个数取异或运算，代表两个数无进位相加；两个数与运算的结果为所有位的进位相加的结果。因此我们可以

* 先将两个数异或运算，
* 然后在将两个数与运算，
* 再将或运算的结果与与运算的结果重复做以上两步，知道与运算结果为0（也就是没有进位了）。

### 快速乘

首先你可能会问a*b不是直接乘就出来了么，为什么需要快速算法？但是乘法在计算机中处理的时间并不是这么快的，也要拆分为加法来做的。所以快速乘法会更快的计算a*b的结果，而且a*b%mod可能还没取模就已经爆long long，但快速乘法却不会。快速幂也是同样的道理。

aX53 = aX110101（二进制）= aX（100000+10000+100+1）=ax（100000x1+10000x1+1000x0+100x1+10x0+1x1）。
那么设立一个ans=0用于保存答案，每一位让a*=2，在根据b的对应为1看是不是加上此时的a，即可完成快速运算。

### 数值的整数次方（快速幂）

这个算法只能处理次数为整数的，所以我们必须次数为负数的将底数和次数参数做转化。紧接着利用次数的二进制形式对底数进行次方操作。

```java
public class Solution {
    public double Power(double base, int exponent) {
        if(exponent<0){
            base = 1/base;
            exponent = -exponent;
        }
        double ans = 1;
        double x = base;
        while(exponent>0){
            // 一下都是精华
            if((exponent&1)==1){
                ans*=x;
            }
            x *= x;
            exponent>>=1;
        }
        return ans;
  }
}
```

### 数组中只出现一次的两个数字

如果要寻找数组中只出现一次的一个数字，并且其他数字都是以偶数倍存在，那么我们可以利用异或运算来进行操作。同样的如果要寻找只出现一次的两个数字，那么我们可以通过这两个数字的二进制的某一位不同而把这组数字分为两组，对两组分别进行异或运算，结果就是答案。

但是上面的算法只能求出两个，并且要求其他数字都是以偶数倍存在，如果想要求更多的出现一次的数组，可以利用HashSet。

### 求1+2+3+。。。+n

方法一：利用&&运算的短路特点，

```java
public class Solution {
    public int Sum_Solution(int n) {
        boolean x = n>1&&((n+=Sum_Solution(n-1))>0);
        return n;
    }
}
```

方法二：利用n(n+1)/2打开的公式（求次方）

```java
public class Solution {
    public int Sum_Solution(int n) {
        return (int)(Math.pow(n,2)+n)>>1;
    }
}
```

## 排序算法

| 算法                                                         | 平均时间复杂度 | 最好情况 | 最坏情况 | 空间复杂度 | 排序方式 | 稳定性 |      |
| ------------------------------------------------------------ | -------------- | -------- | -------- | ---------- | -------- | ------ | ---- |
| [冒泡排序](https://www.runoob.com/w3cnote/bubble-sort.html)  |                |          |          |            |          |        | √    |
| [选择排序](https://www.runoob.com/w3cnote/selection-sort.html) |                |          |          |            |          |        |      |
| [插入排序](https://www.runoob.com/w3cnote/insertion-sort.html) |                |          |          |            |          |        |      |
| [希尔排序](https://www.runoob.com/w3cnote/shell-sort.html)   |                |          |          |            |          |        |      |
| [归并排序](https://www.runoob.com/w3cnote/merge-sort.html)   |                |          |          |            |          |        |      |
| [快速排序](https://www.runoob.com/w3cnote/quick-sort-2.html) |                |          |          |            |          |        |      |
| [堆排序](https://www.runoob.com/w3cnote/heap-sort.html)      |                |          |          |            |          |        |      |
| [计数排序](https://www.runoob.com/w3cnote/counting-sort.html) |                |          |          |            |          |        |      |
| [桶排序](https://www.runoob.com/w3cnote/bucket-sort.html)    |                |          |          |            |          |        |      |
| [基数排序](https://www.runoob.com/w3cnote/radix-sort.html)   |                |          |          |            |          |        |      |
|                                                              |                |          |          |            |          |        |      |

![img](https://www.runoob.com/wp-content/uploads/2019/03/0B319B38-B70E-4118-B897-74EFA7E368F9.png)

### 桶排序的时间复杂度分析

我们假设有`n`个待排序数字。分到`m`个桶中，如果分配均匀这样平均每个桶有`n/m`个元素

桶排序的时间复杂度由两部分组成，

1. 遍历处理每个元素，O(n)级别的普通遍历
2. 每个桶内再次排序的时间复杂度的总和。

对于第二部分假设每个桶内使用的排序算法为快排，那么每个桶内的时间复杂度为(n/m)log(n/m)，有m个桶那么时间复杂度就是m*(n/m)log(n/m) = n(logn-logm);

所以最终桶排序的时间复杂度为O(n+n*(log n -log m))，其中m为桶的个数，如果达到极限n=m，就能保证避免桶内排序，将数值放到桶内之后不需要再次排序，时间复杂度为O(n)，这种情况就属于计数排序。

# 01背包

![image-20220114221536233](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220114221536233.png)
