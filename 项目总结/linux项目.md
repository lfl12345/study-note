## 项目运行的整体流程

* 初始化全局信息，54张牌的信息，已配对游戏对局信息链表头指针，未配对游戏信息指针

* 服务端socket的初始化

  * 创建一个基于TCP IP的socket，

  * 初始化socket绑定的地址信息——协议族，绑定的IP地址，监听的端口号

  * 将socket文件描述符绑定地址信息（bind）

  * 使用listen函数激活服务端的socket文件描述符，同时规定这个套接字的最大连接数，也就是内核使用队列保存正在进行连接状态的客户端socket的最大数量。

    > 当使用socket函数创建一个套接字的时候，它被假定为一个主动套接字，也就是说它是一个即将要调用connect方法的套接字，listen函数把一个未连接的套接字转换成一个被动套接字，接受来自其他主动套接字的连接请求。listen函数用在tcp服务端，一把在调用bind之后且调用accept之前调用，当调用listen函数之后，服务器进程就可以使用accept函数来接受一个请求

* 服务端epoll实例初始化

  * 通过epoll_create函数，有一个size参数，但是在后来的Linux版本中 被抛弃使用了，但是它必须大于0，这个create函数会返回一个epoll实例，这个实例由内核创建，并存放在内核中
  * 初始化epoll_event epoll事件结构体，将刚刚创建的服务端socket文件描述符放入其中，epoll_event 结构体中存放的是 监听的事件类型以及监听的文件描述符
  * 使用epoll_ctl函数将epoll_event 结构体注册到epoll实例当中，epoll_ctl函数需要传递，epoll实例的文件描述符，epoll实例的操作类型（添加，修改删除等），监听的文件描述符，监听的文件描述符的epoll_event结构体

* 调用epoll_wait 函数对注册到epoll实例中的文件描述符进行监听，需要传入参数epoll实例的文件描述符，用来存放有数据的socket文件描述符对应的epoll_event 的epoll_event 数组指针，epoll实例中最大监听数量，函数返回时间（-1阻塞监听，0立即返回，大于零0表示几毫秒后返回）

* 等待epoll实例中监听的文件描述符有数据之后，内核会唤醒挂起的线程，然后线程从epoll_wait函数返回，函数返回了有数据的epoll_event以及有数据的数量

* 根据数量遍历epoll_event，获取其中fd为读事件的文件描述符，

  * 如果文件描述符的类型为listenfd，也就是服务器的socket文件描述符，那么就是用accept函数对连接上来的socket进行连接
    * 初始化连接进来的socket的epoll_event结构体
    * 然后使用epoll_ctl将epoll_event注册到epoll实例当中
  * 如果文件描述符的类型不是listenfd，就说明是客户端已经连接上来的文件描述符中有数据了，此时，读取socket中的数据，然后解析协议，调用业务逻辑方法进行业务逻辑的处理

* 最后，当实例中已经激活的文件描述符全部处理完成后，服务器回到wait函数继续监听文件描述符

## 应用层协议的设计

* 首先仿照HTTP协议设计的请求消息和相应消息
* 然后，协议规定了只能由客户端向服务端请求消息，然后服务端发送消息，服务端不能主动地发送消息

请求报文：

* 请求行和请求体
* 请求行中包括请求的方法—begin，play，pass，stop，使用明文的方法放入请求报文中，
* 当请求的方法是play的时候，请求体中会含有打牌的信息，打牌最多只能打6张牌，每张牌信息使用一个大写的字母表示牌花色，使用数字表示牌大小。

相应报文：

* 相应行，和响应体
* 相应的类型有：begin，wait，mess，end，表示对局已经开始，对方出牌轮次，对方出牌信息，对局结束
* 响应体中还有发牌的数量以及发牌的信息，在begin和mess方法中，相应体重会有发牌的信息

## 如何解决黏包、半包问题

为什么会有黏包和半包的问题？

* 因为TCP是面向连接的传输协议，TCP传输的数据是以流的形式，而数据流是没有明确的开始结尾边界，所以TCP也没有办法判断一个数据流属于那一个消息

黏包的主要原因：

* 发送方每次写入的数据小于socket缓冲区的数据，考虑到传输效率的原因，socket会等待缓冲区满了然后再进行发送
* 接收方读取套接字socket缓冲区的数据不及时，导致多个数据包在缓冲区中积压，从而导致黏包问题

解决方案：

* 使用一个固定的字符结尾，例如'\n',这样我们就知道结束字符，然后如果遇到结束字符就结束读取，没有遇到就继续读取。但是这种方案只使用于使用裸的socket进行通信，因为第一，我们的报文中不能出现结束符，第二，我们需要遍历每一个字符来判断是否达到结尾，这显然不显示
* 在TCP协议上封装应用层协议，在报文中加入数据大小的信息，这样我们就可以在接收到报文之后，通过数据大小来取出tcp数据，从而避免黏包和半包问题。



## epoll的运行过程

见项目运行的整体流成，以及面经总结——epoll原理

## 水平触发和边缘触发的区别，应用场景

水平触发（LT）：

* 当被监控的文件描述符上有可读写事件的时候，就会通知服务器读，如果服务区没有读完，下次它还会提醒。

边缘触发（ET）：

* 当被监控的文件描述符上有可读写事件发生时，会通知服务器去读写，他只会通知服务器一次，这需要用户一次把内容读取完，效率更高。如果用户一次没有读完数据，再次去监听文件描述符的时候，不会立即返回，需要等待下一次的新的数据到来时才会返回，这次返回的内容包括上次没有读取完的内容。

对比：

* 水平触发是状态到达之后，可以多次读取数据，这种情况下会导致多次用户态和内核态的切换，需要注意程序运行效率
* 边缘触发状态改变一次，读取一次数据，如果没有读完，那么剩余的数据只有等待下一次状态改变的时候才能读取，这种模式下需要注意一次能否读写完成。

ET模式会带来的问题：

* 因为只有当缓冲区中的数据由无到有，有少变多时才会读取数据，因此用户程序需要注意一次读取需要把缓冲区中的数据读取完，否则剩下的数据就可能读不到了。

  正常读取数据时，我们若是要保证一次把缓冲区的数据读完，意味着本次读被阻塞时即缓冲区没有数据了，可是epoll服务器要处理多个请求，read不能被阻塞，所以采用非阻塞轮询的方式读取数据

## Redis中的epoll用的是那种模型

epoll中使用的是水平触发的模型，同时它将socket设置为非阻塞模型，这样可以轮询读，将到达的数据全部读取出来

## 协程为什么比普通线程快（go和其他编程语言比的优势）



## mysql中使用varchar和int比较会走索引吗

## mysql索引失效的场景

总结：LOL ，+-*/，  not、 null，no method，no convert我就是我，不一样的版本，不一样的我

1. like，最左前缀原则，开头以%开头的时候

2. or，前后都是索引，失效，只要有一个不是索引就会失效

3. left，联合查询的最左前缀原则

4. 当索引字段计算在加减乘除中，索引必然失效——select from table where age-1=10

5. not 非！=，is not 取非结果集就会导致索引失效

6. is null，is not null，允许索引值为null，b+只处理不为null，不对null进行创建。创建字段的时候最好不要允许字段为null，最好设置一个默认值

7. no method 当索引列使用到mysql内置函数的时候，会导致索引失效

8. no convert 当使用varchar和int做对比的时候，mysql会自动将int转为varchar，使用内置的函数convert，因此就导致了索引失效

9. select * from table where a > 3 a是一个辅助索引，在不同的版本中索引的使用情况是不同的。根本原因是select * 查询所有的信息，需要聚簇索引。

   因为MySQL5.6版本开始支持Multi-Range Read优化，MRR优化是为了减少磁盘的随机访问，并且将随机访问变为顺序的数据访问。

   MRR优化的好处：

   * 使数据访问变得较为顺序，在查询辅助索引的时候，首先根据得到的结果，按照主键进行排序，并按照主键排序的顺序进行书签查找
   * 减少缓冲池中页被替换的次数
   * 批量处理对键值的查询操作

