![image-20220310112208307](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220310112208307.png)

# 锁升级

前提：32位的虚拟机里面

当我们新创建一个对象的时候，32位的对象头中会包含25位的hashCode，4位的对象分代年龄，1位的偏向锁标志位，2位锁标志位。

## 25位的hashCode

如果我们没有显示或者隐式调用对象**Object父类的hashCode**方法，那么对象头中的25位hashCode值并不会真实存在，如果没有调用，那么这个位置就是0。

但是如果我复写了对象的hashCode方法，那么在显示或者隐式调用hashCode方法的时候，也不会占用对象头中hashCode位置。

## 锁标志位

无锁状态和偏向锁状态他们的锁标志位都是01，区别就是无锁状态的偏向锁状态标志位0，偏向锁 的时候偏向锁状态标志位为1。

## 无锁状态升级偏向锁状态

* 首先无锁状态的MarkWord中没有真正存储hashCode的值，这是一个前提条件。如果使用偏向锁，在hashCode的位置需要存放23位的线程ID以及2位的epoch，但是在jvm中没有逻辑对已经生成的hashCode的值进行保存。

  但是不能直接覆盖，然后下次调用hashCode的时候再去生成hashCode呢？我觉得主要的原因是要保证对象在使用的过程中HashCode的值不能改变，如果HashCode的值先被覆盖，然后要使用的时候再生成，在这中间有可能经过垃圾回收，对象的存储位置可能发生改变，那么HashCode的值就会改变，导致对象前后HashCode值不一样，因此如果对象头中已经有了HashCode的值，那么就不能使用偏向锁了。

* 偏向锁标志位需要从0变为1

## 无锁状态和偏向锁状态的区别

* MarkWord前25位存放的信息不同，无锁状态存放的是0或者HashCode，偏向锁状态存放的是偏向的线程ID以及epoch
* MarkWord的偏向锁标志位不同，一个是0，一个是1 

偏向锁的好处

* 在线程加锁的时候，直接比较自己的线程ID是否和MarkWord中存放的线程ID相同，这样直接就进行了一次加锁操作，这样就得到了性能的提升

  例如：只有一个线程对锁加锁，那么这个锁一直偏向这个进程，这个线程只需要一个简单的判断就能再次加锁

## 偏向锁升级为轻量级锁

首先，发生竞争时偏向锁升级为轻量级锁这句话说的有问题。

在发生线程竞争的时候，偏向锁不一定会升级为轻量级锁，但是偏向锁升级为轻量级锁的必要条件就是发生线程竞争。

情况一：

如果线程b去对一个对象上锁，他会先检查对象的锁标志位，如果锁标志位为01，接着检查偏向锁状态，如果偏向锁状态为1，就说明这个锁已经偏向过另一个线程，此时就会去检查另一个线程是否还在临界区内执行，如果另一个线程a已经执行完了，那么线程b会把偏向状态清空，置为无锁状态，然后自己再去争抢这个锁，此时如果没有线程争抢这个锁，那么这个锁会重新偏向b线程。

这种情况是一种并没有多个线程并发的去争抢锁的一种情况。

情况二：

如果线程b已经将锁置为无锁状态，但是此时来了一个线程c去和线程b争抢这个锁，假如线程b争抢失败，也就是没有将自己的线程ID放入MarkWord中，c线程将这个对象从无锁状态置为了偏向锁状态，偏向自己的线程ID。

线程C 正在执行的时候，线程B来争抢偏向锁，B就会触发一个偏向锁撤销的操作，但是B需要等待C进入安全点。进入安全点以后，线程C的栈会被执行遍历，遍历一些锁记录。为什么要遍历，遍历完成后会导致什么

* 会直接将对象标记为无锁状态，并将锁对象升级为00，轻量级锁

  置为无锁状态相当于将偏向锁升级为轻量级锁，会将锁标记为置为00，然后将自己的偏向锁iD和epoch置为空，置为空相当于置为之前没有hashCode时的状态

* 将我们的线程重新偏向b线程

* 直接将该对象置为不可使用偏向锁



