# 垃圾回收

## 如何判断对象可以回收

### 引用计数法

如果一个对象增加一个引用，引用计数加1，如果减少一个引用，引用计数减1。引用计数为0，就代表可以被垃圾回收。但是引用计数法有一个很大的弊端。Java 虚拟机并不采用这种算法。

弊端：

<img src="C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220108145333199.png" alt="image-20220108145333199" style="zoom:50%;" />

如果两个对象循环引用，但是这两个对象没有其他的引用，那么这即使这两个对象没有用了引用计数也不会为0，造成了内存泄漏。

### 可达性分析算法

Java虚拟机中的垃圾回收器采用**可达性分析**来探索所有存活的对象。

扫描堆中的对象，看是否能够沿着GC Root对象为起点的引用链找到该对象，找不到，表示可以回收。

哪些对象可以作为GC Root？

1. 系统类对象，就是虚拟机启动时需要加载的类对象，对于程序的运行起作用的对象
2. 本地方法栈（调用本地方法）中的Java对象
3. Java正在运行的线程中的对象
4. 上锁的对象

### 四种引用

实际并不止四种引用。

<img src="C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220108151604516.png" alt="image-20220108151604516" style="zoom:50%;" />

上图中实线代表强引用，虚线代表其他引用。

**强引用**

直接使用new或者等号赋值的变量与对象之间的关系是强引用关系。存在强引用的对象不会被垃圾回收所回收，只有当所有引用它的变量为0时，对象才会被回收。

**软引用**

当没有强引用引用软引用所引用的对象的时候，这时候如果发生垃圾回收，如果回收之后内存不够，会回收掉软引用的对象

**弱引用**

当没有强引用引用弱引用所引用的对象的时候，这时候如果发生垃圾回收，不管内存够不够，就会回收掉弱引用的对象。

当软、弱引用的对象被回收掉之后，如果他们配合了引用队列，那么他们会被放到引用队列当中，然后垃圾回收会遍历引用队列，随之把它们也回收掉。（？）

**虚引用**

虚引用和终结器引用必须配合引用队列来使用。也就是当虚引用对象创建的时候，就会关联一个引用队列。

当虚引用引用的对象被垃圾回收掉之后，引用对象所引用的内存空间可能不会被垃圾回收掉，因此虚引用变量会被放入引用队列中，有一个线程会定时遍历引用队列中的变量，然后去释放它所关联的内存空间。

**终结器引用**

如果一个对象重写了finallize方法，那么在第一次垃圾回收的时候，并不会直接释放对象内存，而是创建一个终结器引用，将终结器引用放入引用队列，然后由一个优先级很低的线程finallizeHandler去遍历引用队列，遍历到终结引用之后，首先执行finallize方法，然后再将对象的空间释放掉。

<img src="C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220108154250075.png" alt="image-20220108154250075" style="zoom:50%;" />

可以利用java.lang.ref包下的引用对象来创建软引用变量、引用队列、弱引用

<img src="C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220108160203657.png" alt="image-20220108160203657"  />

在创建软引用对象的时候，可以同时声明引用队列ReferenceQueue，当软引用对象被回收之后，软引用变量会被放入引用队列，可以通过引用队列删除软引用变量。

## 垃圾回收算法

在jvm垃圾回收的时候会根据实际情况采用一下算法，不是只用一种算法。

### 标记清除

<img src="C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220108162345646.png" alt="image-20220108162345646" style="zoom:50%;" />

标记清除算法分为两个阶段。

第一个阶段首先判断那个对象可以被垃圾回收，然后标记上。

第二个步骤就是清除，把标记上的对象清除掉，也就是将对象所占用的内存地址的起始地址放入空闲地址列表中。

优点;

* 垃圾回收速度快

缺点：

* 容易产生内存碎片

### 标记整理

分为标记和整理两个阶段。

第一个阶段是标记，和标记清除算法一样，都是将可回收的对象打上标记。

整理阶段是为了改善清除对象时产生内存碎片的问题。在清除的过程中对内存进行整理，让内存更加紧凑。从而减少了内存碎片，连续的空间会更大

优点：

* 没有内存碎片

缺点：

* 整理牵扯到对象的移动，速度减慢

### 复制

![image-20220108163953332](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220108163953332.png)

先标记后复制，然后清除，然后交换from和to区域

不会有内存碎片

但是需要占用双倍的内存

## 分代垃圾回收

jvm中不是只采用一种垃圾回收算法，而是将所有垃圾回收算法协同工作。具体的实现就是分代垃圾回收机制。

* 对象首先分配在新生代的伊甸园区域
* 新生代空间不足时，触发minor gc，伊甸园和from存活的对象使用copy复制到to区域中，存活对象年龄加1并且交换from和to区域。
* minor gc的时候会引发一次stop the world 。在发生垃圾回收的时候必须暂停其他用户线程。因为垃圾回收的时候牵扯到对象的赋值，对象地址会改变，所以会引发stop the world。等垃圾回收结束，用户线程恢复运行。minor gc 暂停时间很短，因为新生代对象大多都是垃圾
* 当新生代中的对象寿命超过阈值时，会晋升至老年代，最大寿命是15（4bit），不同的垃圾回收器会有不同的阈值。
* 当老年代空间不足时，会先尝试触发minor gc，如果之后空间仍不足，那么触发full gc，STW的时间更长（很有疑问，为什么是老年代不足，先尝试触发minor gc）。老年代采用的垃圾回收回收算法可能是标记删除或者标记整理。
* 如果full gc之后空间还是不足，那么就会触发OutOfMemoryError

### 分带垃圾回收的相关VM参数

<img src="C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220108171151499.png" alt="image-20220108171151499" style="zoom:50%;" />

大对象直接放入老年代内存。如果新生代垃圾回收了还不能存放大对象，那么不会触发垃圾回收，直接晋升为老年代。

误区：一定要注意一个线程内的OutOfMemoryError错误不会导致Java进程的最终结束。其他线程还会好好的。

## 垃圾回收器

1. 串行

   单线程

   堆内存较小，适合个人电脑

2. 吞吐量优先

   多线程

   堆内存较大，多核CPU

   让单位时间内，STW的时间最短，每次垃圾回收的时间可能会长，但是垃圾回收的次数少

3. 相应时间优先

   多线程

   堆内存较大，多核CPU

   尽可能让单次STW的时间最短，每次垃圾回收的时间最短，但是垃圾回收的次数可能会增多

### 串行

<img src="C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220108183329494.png" alt="image-20220108183329494" style="zoom:50%;" />

新生代和老年代的垃圾回收器是分开的，算法也不一样，一个是复制，一个是标记清除

### 吞吐量优先

<img src="C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220108184016824.png" alt="image-20220108184016824" style="zoom:50%;" />

运行的时候用户线程会停止，所有的CPU执行并行的垃圾回收

### 相应时间优先

<img src="C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220108191336575.png" alt="image-20220108191336575" style="zoom:50%;" />

运行的时候可以和用户线程并发的执行。

因为相应时间优先垃圾回收器在垃圾回收的时候会和用户线程并发执行，所以在回收的时候，用户线程会产生新的垃圾，因此这种垃圾回收器不能等到垃圾满了再进行垃圾回收，必须预留一点空间。所以第三个参数就是设置这个预留的空间。

在重新标记的时候，可能之前运行的时候会有新生代的对象引用老年代的对象，那么此时如果我在进行一次对堆对象的扫描，会消耗效率，做了无用功，因为新生代的对象很有可能是垃圾对象，需要垃圾回收的。因此需要将第四个参数设置上。这个参数的作用是在进行重新标记的时候再对新生代对象进行一次垃圾回收，然后再重新标记的时候，扫描的对象就会变少了。

存在的问题：

CMS垃圾回收器回收老年代内存的时候使用的是标记清除算法，因此会出现很多内存碎片，如果在CMS垃圾回收器在工作的时候，新生代内存和老年代内存都不足，此时CMS垃圾回收器会退化为串行垃圾回收器，需要让用户线程停止，然后整理老年代的内存空间，这个时候，垃圾回收的时间就会剧增。

### G1垃圾回收器

和用户线程并发执行的垃圾回收器

定义：Garbage First

JDK9默认支持

适用场景：

* 同时注重吞吐量和低延迟，默认的暂停目标是200ms
* 适合超大堆内存，会将堆划分为多个大小相等的region
* 整体上使用的垃圾回收算法是标记整理算法，region之间使用的是复制算法。

JVM相关的参数：

<img src="C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220108194258638.png" alt="image-20220108194258638" style="zoom:50%;" />

第一个参数是显示启用G1垃圾回收器

#### G1垃圾回收阶段

<img src="C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220108194549598.png" alt="image-20220108194549598" style="zoom:50%;" />

#### Young Collection

#### Young Collection+CM

#### Mixed Collection

#### Full GC 和 Minor GC

#### Young Collection 跨代引用

如果存在跨代引用，那么在新生代垃圾回收的时候就需要遍历老年代的所有对象来判断是否存在新生代的引用，但是这样做效率会十分的低。所以垃圾回收器为老年代内存维护了一个卡表，表示一段内存中的老年代对象是否引用了新生代对象，如果引用了那么这个卡表就标记为脏卡，在从老年代对象中寻找根对象的时候就只需要遍历脏卡就可以。而标记老年代是否有引用这个操作是一个使用队列实现的异步操作。

#### Remark

由于标记阶段垃圾回收器和用户线程是并发执行的，所以有可能会出现某个对象被标记为垃圾之后，又有对象强引用了它。因此为了避免这种情况，在标记阶段，被标记的垃圾JVM会配上一段指令，如果在被标记之后它被引用的情况发生了变化，就会被加入到一个队列当中，状态转换为正在处理中，在remark阶段再接着进行处理。

#### JDK 8u20 字符串去重

#### JDK 8u40 并发标记类卸载

#### JDK 8u60 回收巨型对象

#### JDK 9 并发标记起始时间的调整

#### JDK 9 更高效的回收

## 垃圾回收调优

通过命令查看垃圾回收相关的参数

![image-20220109101459073](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220109101459073.png)

### 调优领域

GC是主要的调优领域，因为GC可能会STW，会影响网络延迟

内存

锁竞争

cpu占用

io

### 确定调优目标

要的是低延迟还是高吞吐量，选择合适的回收器

GMS、G1、ZGC

ParallelGC

### 最快的GC是不发生GC

查看fullGC前后的内存占用，考虑下面几个问题（到低是不是自己的代码出现了问题）

* 数据是不是太多
  * resultSet = statement.executeQuery("select * from 大表")，这种语句就不太好，加载到内存中的数据太多了
* 数据表示是不是太臃肿
  * 对象图：查询出来的用户信息太多，并不需要
  * 对象大小：Java中最小的Object至少占用16个字节

* 是否存在内存泄漏
  * static Map map =  （）
  * 可以使用软弱引用来改善这种长时间存在内存中的对象
  * 如果需要使用缓存，建议使用第三方的缓存框架，而不是Java对象缓存

### 新生代调优

新生代的特点：

* 所有的new操作的内存分配十分廉价
  * TLAB Thread-local allocation buffer：每个线程私有的局部的内存。让每个线程使用自己私有的伊甸园的内存，当多个线程同时创建对象的时候，不会发生冲突。
* 死亡对象的回收代价是0
* 大部分对象用过即死
* Minor GC的时间远低于Full GC

调优第一点：

1. 伊甸园内存放并发的同时请求的所有对象
2. 幸存区能存放 活跃对象但是会被回收以及一定会晋升的对象
3. 晋升阈值配置得当，让长时间存活的对象能尽快晋升

![image-20220109220439863](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220109220439863.png)

第二个参数可以打印幸存区各个年龄的对象的大小以及总大小

### 老年代调优

以CMS为例：

* CMS的老年代内存越大越好：避免浮动垃圾引起的并发失败
* 先尝试不做调优，如果没有Full GC那么已经。。。，否则先尝试调优新生代
* 观察发生Full GC时老年代内存占用，将老年代内存预设调大1/4~1/3，剩下来的内存是为了给浮动垃圾
  * -XX:CMSInitiatingOccupancyFraction=percent

### 案例

![image-20220109222233023](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220109222233023.png)

第一个因为空间不足

第二个因为remark阶段要扫描堆内所有的对象，所以时间长

第三个因为1.7 的方法区使用的是永久代，占用的是堆内存，如果永久代内存不足也会引发full GC 