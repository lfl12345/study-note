# 表

表就是关于特定实体的数据集合，也就是关系型数据库模型的核心

## 索引组织表

在InnoDB中，表都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（index organized table）。在InnoDB存储引擎表中，每张表都应该有个主键，如果在创建表的时候没有显示的定义主键，Innodb存储引擎会按照以下方式选择或创建主键：

* 首先判断表中是否存在非空的唯一索引（unique not null），如果有，则按照所有非空唯一索引的先后顺序选择一个为主键。
* 如果不符合上述条件，Innodb会创建一个6字节大小的指针（为什么是6字节）

使用_rowid可以显示表的主键，但是只能看单个列为主键的情况。

## Innodb逻辑存储结构

从Innodb存储引擎的逻辑存储结构看，所有数据都被逻辑地存放在一个空间中，这个空间称为表空间（tablespace）。表空间由段（segment）、区（extent）、页（page）组成。

![image-20211213110116893](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20211213110116893.png)

### 表空间

表空间是Innodb逻辑结构的最高层，所有的数据都放在表空间中。Innodb默认有一个共享的表空间ibdata1，如果开启了参数innodb_file_per_table，则每张表内的数据可以单独放到一个表空间内。

但是单独的表空间只存放数据、索引、和插入缓冲Bitmap页，其他类型的数据，如回滚（undo）信息、插入缓冲索引页、系统事务信息、二次写缓冲等还是放在原来的共享表空间。这也说明一个问题，即使开启了使用单独的表空间，那么共享表空间ibdata1文件的大小还是会不断增大，并且在事务结束之后里面的（undo）数据不会清除，直到master Thread执行full purge操作之后，会将不再使用的undo空间标记为可用空间，所以尽管空间不会缩小，但是有可能不变，那就是因为使用了之前标记为可用的undo空间

### 段

表空间是由各个段组成的，常见的段有数据段、索引段、回滚段等。

因为Innodb存储引擎表是索引组织的，因此数据即索引，索引即数据。数据段就是B+树的叶子结点，索引段是B+树的非叶子结点。回滚段比较特殊。

### 区

区是由连续的页组成的，尽管可以使用压缩页的方式将页的大小从16KB压缩到2、4、8，但是区的大小总是1M不变的。为了确保区中页的连续性，Innodb存储引擎一次从磁盘申请4~5个区。默认情况下一个区有64个页。

创建表的大小默认是96KB，为什么不是1M呢（一个区的大小），**因为在每个段开始的时候先用32个页大小的碎片页来存放数据，用完这些页之后才是64个连续页的申请（不明白），**这样做的目的是，对于一些小表，或者是undo这类的段，可以在开始时申请较少的空间，节省磁盘容量的开销。

### 页

**页是Innodb磁盘管理的最小单位**。在Innodb存储引擎中，默认每个页的大小为16KB。

Innodb中，常见的页类型有：

* 数据页（B-tree Node）
* undo页（undo log page）
* 系统页（System page）
* 事务数据页（transaction system page）

### 行

Innodb存储引擎是面向行的，也就是数据是按昂进行存放的。

每个页存放的行记录数最多允许16KB/2-200条，也就是7992行记录。

## Innodb行记录格式

Innodb1.x之前提供了Compact和Redundant两种行记录格式。

### Compact行记录格式

compact设计的目的是高效的存储数据。一个页中存放的行数越多，其性能就越高。

| 变长字段长度列表 | NULL标志位 | 记录头信息 | 列1数据 | 列2数据 | 。。。。 |
| ---------------- | ---------- | ---------- | ------- | ------- | -------- |

变长字段长度**列表**（列表就说明有多个）是不固定长度的，它随着行数组中变长字段的增加而增加，他按照列顺序的逆序放置。如果一个字段的长度小于255，用1个字节表示，如果大于255个字节，用两个字节表示。

变长字段的长度不能超过2个字节，因为varchar类型的最大程度限制为65535，

NULL标志位指示了该行数据中是否有NULL值，有就用1表示。

接下来是头部信息，固定用五个字节（40位）表示。

| 名称         | 大小 | 描述                                                         |
| ------------ | ---- | ------------------------------------------------------------ |
|              | 1    | 未知                                                         |
|              | 1    | 未知                                                         |
| deleted_flag | 1    | 该行是否已被删除                                             |
| min_rec_flag | 1    | 为1，如果该记录预先被定义为最小的记录                        |
| n_owned      | 4    | 该就录拥有的记录数                                           |
| heap_no      | 13   | 索引堆中该条记录的排序记录                                   |
| record_type  | 3    | 记录类型，000表示普通，001表示B+树节点指针，010表示Infimum，011表示Supremum，1xx表示保留 |
| next_record  | 16   | 页中下一条记录的相对位置                                     |
| total        | 40   |                                                              |

最后的部分就是实际存储每个列的数据。

需要特别注意的是，**NULL不占该部分的任何空间，即NULL处理占有NULL标志位，实际存储不占有任何空间。**

另外每行数据除了用户定义的列之外，还有两个隐藏列，事务ID列和回滚指针列，分别为6字节和7字节大小。若Innodb表没有定义主键，每行会增加一个6字节的rowid列。

### Redundant行记录格式

| 字段长度偏移列表 | 记录头信息 | 列1数据 | 列2数据 | 。。。。 |      |
| ---------------- | ---------- | ------- | ------- | -------- | ---- |

字段长度偏移列表和Compact格式的变长字段长度列表相同。

头部信息和Compact长度略有不同，同时没有NULL标志位。我认为这里的不同是造成这两种格式的存储效率差别的原因。

在头部信息的heap_no之前和compact格式的含义用法一样，在heap_no之后，多出了10bit的n_fields和1bit的1byte_offs_flag，分别用于记录了**记录列中的数量**和标志偏移列表为1字节还是2字节，同时少了record_type，多出11字节，少了三字节，这也就是多出了8字节的来源。

这里再解释一下为什么Compact比redundant能高效的存储？因为Redundant格式没有NULL标志位，那么一个字段是否可以为NULL不能确定，所以就必须使用额外的空间去存储NULL值用来表示这一行数据中这个列的值为NULL，我认为这就是compact比redundant更高效存储的原因。

### 行溢出数据

Innodb存储引擎可以将一条记录中的某些数据存储在真正的数据页之外。一般认为为BLOB、LOB这类的大对象列类型的存储会把数据放在数据页面之外，但是BLOB可以不将数据溢出页面，而且即便是varchar数据类型依然有可能被存放为行溢出数据。

#### varchar数据类型

varchar官方手册中所说的65535（单位是字节）是这一行所有varchar类型的字节数的总和。

但是实际只能最多存放65532个字节

也就是说如果编码不同GBK最多32767字符，UTF-8存放21845个字符，Latin1存放65532个字符。

即使varchar能存放65532个字节，但是Innodb储存引擎的页大小为16KB，也就是16384个字节，这样一页有可能存放不了一个字段（65535字节）。因此在一般情况下，Innodb存储引擎的数据都是存放在页类型为B-tree node中，但是当发生行溢出时，数据存放在页类型为Uncompress BLOB页中。

但是多长的varchar是保存在单个数据页中的，从多长开始又会保存在BLOB页中呢？

我们可以思考一下：Innodb存储引擎表是索引组织的，即B+Tree的结构，这样每个页中至少应该有两条行记录（否则就失去了B+Tree的意义了，变成了链表了）因此如果页中只能放下一条记录，那么Innodb存储引擎会自动将行数据存放到溢出页中。

对于Text和BLOB的数据类型，和varchar类型一样，至少保证一个页中能存放两条记录，如果不能再考虑把数据溢出到溢出页中。但实际上BLOB类型的数据不会那么小，所以实际数据一般都保存在BLOB页中，**数据页中只保存数据的前768字节。**

### Compressed和Dynamic行记录格式

Innodb1.0.x版本引入了新的文件格式（file format，可以理解为新的页格式）

以前支持的compact和redundant格式称为Antelope文件格式，新的文件格式称为Barracuda文件格式，新的文件格式下拥有两种新的行记录格式：Compressed和Dynamic。

新的两种记录格式对于存放在BLOB中的数据采用了完全的行溢出方式，在数据页中只存放20个字节的指针，实际的数据都存放在Off Page中，而之前的Compact和Redundant两种格式会存放768个前缀字节

Compressed行记录格式的另一种功能就是，存储在其中的行数据会以zlib的算法进行行压缩，因此对于BLOB、TEXT、VARCHAR这类大长度类型的数据能够进行非常有效的压缩。

### char的行结构存储

在前面了解到的行结构的内部存储中每行的变长字段长度列表中都没有存储char类型的长度。

值得注意的是，从MySQL4.1版本开始char(N)，中的N指的是字符的长度，而不是之前版本的字节长度，也就是说在不同的字符集下，char类型列内部存储的可能不是定长的数据。

因此对于多字节的字符编码，char类型不在代表固定长度的字符串了。因此对于多字节字符编码的char数据类型的存储，Innodb存储引擎在内部将其是为变长的字符类型。这也就意味着在变长长度列表中会记录char数据类型的长度。

因此在多字节字符集的情况下，char和varchar的实际行存储基本没有区别。对于未能占满长度的字符填充0x20

![image-20211214104458285](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20211214104458285.png)

## Innodb数据页结构

页是Innodb存储引擎管理数据库的最小磁盘单位。页类型为B-tree Node的页存放的就是表中行的实际数据类。

Innodb数据页有一下7个部分组成：

* 文件头（File header）
* Page Header（页头）
* Infimun 和 Supremum Records
* User Records（用户记录，即行记录）
* Free Space（空闲空间）
* Page Directory（页目录）
* File Trailer（文件结尾信息）

<img src="C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20211215104254725.png" alt="image-20211215104254725" style="zoom: 33%;" />

其中文件头、页头、文件尾的大小是固定的，分别为38、56、8字节，这些空间用来标记该页的一些信息，如checksum，数据页在B+数索引的层数等。其他空间记录了实际的数据，因此大小是动态的。

### File Header

File header用来记录页的一些头信息，一共占用38个字节，记录的信息如下：

* checksum值
* 表空间中页的偏移量
* 当前页的上一个页
* 当前页的下一个页，用于B+Tree的特性决定了叶子结点必须是双向列表。
* 当前页最后被修改的日志序列位置LSN（Log Sequence Number）
* Innodb存储引擎页类型
* 表示页属于那个表空间

### Page header

用来记录数据页的状态信息。

* 该页中记录的数量等

### Infimum和Supremum record

在Innodb存储引擎中，每个数据页中有两个虚拟的行记录，用来限定记录的边界，

Infimum 记录是比该页中任何主键值都要小的值，Supremum记录比任何可能大的值还要大的值。这两个这在页创建的时候被建立，并且任何情况下都不会被删除。在Compact 和 Redundant行格式下，两者占用的字节数各不相同。

### User Record 和 Free Space

User Record是实际存储的行记录，Innodb存储引擎表总是B+树索引组织的。

Free Record指的是空闲空间，同样是一个链表数据结构，在一条记录被删除后，该空间会被加入到空闲链表中。

### Page Directory

Page Directory（页目录）中存放而来记录的相对位置（这里存放的是相对位置，不是偏移量）

由于再Innodb存储引擎中Page Directory是稀疏目录，二分查找的结果只是一个粗略的结果，因此Innodb必须通过recorder header中的next_record来继续查找相关记录。

需要牢记：B+树索引本身并不能找到具体的一条记录，能找到的只是该记录坐在的页，。数据库把页加载到内存中，然后通过page directory进行二分查找。

### File Trailer

为了检测页是否已经完整地写入磁盘（在写入的过程中可能发生磁盘损坏，机器关机等），Innodb存储引擎的页中设置了File Trailer部分。

