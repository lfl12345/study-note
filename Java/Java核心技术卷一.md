# Java核心技术卷一

## 第一章 Java程序设计概述

### 1.1 Java 程序设计平台

Java 是一个完整的平台，有一个庞大的库，其 中包含了很多可重用的代码和一个提供诸如安全性、 跨操作系统的可移植性以及自动垃圾收集等服务的执行环境。

### 1.2 Java“白皮书”的关键术语

> 1 ) 简单性 2 ) 面向对象 3 ) 分布式 4 ) 健壮性 5 ) 安全性 7 ) 可移植性 8 ) 解释型 9 ) 高性能 10 ) 多线程 11 ) 动态性 6 ) 体系结构中立

## 第二章 Java程序设计环境

### 2.1 安装Java开发工具包

#### 2.1.1 下载JDK

| 术语名                   | 缩写 | 解释                                                         |
| ------------------------ | ---- | ------------------------------------------------------------ |
| Java Development Kit     | JDK  | 编写 Java 程序的程序员使用的**软件开发工具包**（SDK）        |
| Java Runtime Environment | JRE  | 运行Java所使用的的软件，包括JVM、Java核心类库和支持文件      |
| Software Development Kit | SDK  | 软件开发工具包一般都是一些软件工程师为特定的软件包、软件框架、硬件平台、操作系统等建立应用软件时的开发工具的集合。 |

### 2.2 使用命令行工具

> javac 程序是一个Java编译器，它将.java文件编译成为.class文件

## 第三章 Java 的基本程序设计结构

### 3.2 Java注释

* Java有三种注释，/** */这种注释可以用来自动生成文档
* 在 Java 中，/* */ 注释不能嵌套

### 3.3 数据类型

> Java是一种强类型语言。这就意味着必须为每一个变量声明一个类型。在 Java 中， 一共有 8 种基本类型（ primitive type ), 其中有 4 种整型、2 种浮点类型、 1 种用于表示 Unicode 编码的字符 单元的字符类型 char 和 1 种用于表示真值的 boolean 类型。**基本数据类型无法赋null值**

#### 3.3.1 整型

> 在 Java 中， 整型的范围与运行 Java 代码的机器无关。

| 类型  | 存储需求     | 取值范围                                       |
| ----- | ------------ | ---------------------------------------------- |
| byte  | 1字节（8位） | -128-127                                       |
| short | 2个字节      |                                                |
| int   | 4个字节      | -2147 483 648 - 2 147 483 647 (正好超过 20 亿) |
| long  | 8个字节      |                                                |

* 长整型数值有一个后缀 L 或 1 ( 如 4000000000L)
* 十六进制数值有一个前缀 0x 或 0X (如 0xCAFE)（前面的是零）
* 八进制有一个前缀 0 , 例如， 010 对应八进制中的 8。（前面的是零）
* 从Java7开始，加上前缀 0b 或 0B 就可以写二进制数（前面的是零）

> 从 Java 7 开始，还可以为数字字面量加下划线，如用 1_000_000(或册1丨丨丨_0100_00丨0_丨0 00_0000 ) 表示一百万。这些下划线只是为丫让人更易读。Java 编译器会去除这些下划线

#### 3.3.2浮点类型

> float 类型的数值有一个后缀 F 或 f (例如，3.14F。) 没有后缀 F 的浮点数值（如 3.14 ) 默 认为 double 类型。当然，也可以在浮点数值后面添加后缀 D 或 d (例如，3.14D) 。

| 类型   | 存储要求 | 取值范围                                                |
| ------ | -------- | ------------------------------------------------------- |
| float  | 4字节    | 大约 ± 3.402 823 47E+38F (有效位数为 6 ~ 7 位）         |
| double | 8字节    | 大约 ± 1.797 693 134 862 315 70E+308 (有效位数为 15 位> |

#### 3.3.3char类型

> char 类型原本用于表示单个字符。不过，现在情况已经有所变化。 如今，有些 Unicode 字符可以用一个 char值描述，另外一些 Unicode 字符则需要两个 char 值。

char 类型的值可以表示为十六进制值（两个字节），其 范围从 \u0000 到 \Uffff。例如：W2122 表示注册符号 ( ), \u03C0 表示希腊字母 it。其实就是相当于表示一个字符，例如：\u0041表示编码值为十进制的65的'A'。

```java
public class test {
    public static void main(String[] args) {
        char a = '\u0041';
        System.out.println(a);//输出A
    }
}
```

> **警告：Unicode 转义序列会在解析代码之前得到处理**
>
> 更隐秘地， 一定要当心注释中的 \u。
>
> ```java
> public class test {
>     public static void main(String[] args) {
>         // Look inside c:\users
>         char a = '\u0041';
>         System.out.println(a);
>     }
> }
> /**
> 由于注释那行\u后面没有跟着一个合法的十六进制数，所以会报错误
> D:\program\spring_mvc注解\demo\spring_annotation_mvc2\src\test\java\test.java:3:28
> java: 非法的 Unicode 转义
> */
> ```

#### 3.3.4 Unicode和char字符

#### 3.3.5 boolean类型

* boolean (布尔）类型有两个值：false 和 true, 用来判定逻辑条件

* **整型值和布尔值之间 不能进行相互转换**。

  ```java
  if(b=0){
  }//这种代码在Java语法就是错误的，但是在c++中却一直是false，原因是Java中不能将int转化为boolean
  ```

### 3.4变量

> * 变量名中可以包含字母、数字、下划线、美元符，数字不能开头
>
> ```java
> //如果以数字开头就会搞不清这两行
> String 123 = "jkjk";
> int c = 123;
> ```
>
> * 变量名大小写敏感
> * 尽管 $ 是一个合法的 Java 字符， 但不要在你自己的代码中使用这个字符。它只用 在**Java 编译器或其他工具生成**的名字中。

#### 3.4.2 常量

> **注意：const 是 Java 保留的关键字，但目前并没有使用。在 Java 中， 必须使用 final 定义常量。**

### 3.5 运算符

#### 3.5.2数值类型之间的转换

![image-20210921093102960](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20210921093102960.png)

在图 3-1 中有 6 个实心箭头，表示无信息丢失的转换；有 3 个虚箭头， 表示可能有精度 损失的转换。

```java
int c = 123456789;
float d = c;
System.out.println(d);
//输出1.23456792E8，失去了一点精度
```

当使用二元操作时，现将两个操作数转换为同一种类型，再进行操作。

* 如果两个操作数中有一个是 double 类型， 另一个操作数就会转换为 double 类型。 
* 否则，如果其中一个操作数是 float 类型，另一个操作数将会转换为 float 类型。 
* 否则， 如果其中一个操作数是 long 类型， 另一个操作数将会转换为 long 类型。 
* 否则， 两个操作数都将被转换为 int 类型。

#### 3.5.3 强制类型转换

java在“大转小”的时候需要强制类型转换，强制类型转换会失去一些精度，多余小的数所表达的位数会被抛弃。

```java
System.out.println(Integer.toBinaryString(300));//结果0000000100101100，十进制300
System.out.println(Integer.toBinaryString(44));//结果         00101100，十进制44
//如果把进行如（byte）300这样的操作，那么结果就是44
```

#### 3.5.7 位运算符

**最后，>>> 运算符会用 0 填充高位，这与>>不同，它会用符号位填充高位。不存在<<< 运算符。**

### 3.6 字 符 串

* 现在只需要知道只要看到 一个 CharSequence 形参， 完全可以传入 String 类型的实参,，

* StringBuilder是线程不安全的，StringBuffer是线程安全的。

### 3.7 输入输出

### 3.8 控制流程

#### 3.8.5 多重选择 switch语句

case 标签可以是： 

* 类型为 char、byte、 short 或 int 的常量表达式。 
* 枚举常量enum。 
* 从 Java SE 7开始， case 标签还可以是字符串字面量。

#### 3.8.6 中断控制流程语句

> 尽管 Java 的设计者将 goto 作为保留字，但实际上并没有打算在语言中使用它。

* break语句可以用来跳出重重循环。

```java
public static void main(String[] args) {
    int a = 0;
    breakBackPoint:
    while(a<10 ){
        //做一些事情
        for(int i=0;i<10;i++){
            if(i>8){
                break breakBackPoint;
            }
        }
        a++;
    }
}
```

### 3.9 大数值

> ​		如果基本的整数和浮点数精度不能够满足需求， 那么可以使用jaVa.math 包中的两个 很有用的类：Biglnteger 和 BigDecimaL 这两个类可以处理包含任意长度数字序列的数值。 Biglnteger 类实现了任意精度的整数运算， BigDecimal 实现了任意精度的浮点数运算。

### 3.10 数组

* 数组长度不要求是常量： newint[n] 会创建 一个长度为 n 的数组。

* 创建一个数字数组时， 所有元素都初始化为 0。boolean 数组的元素会初始化为 fals% 对 象数组的元素则初始化为一个特殊值 null, 这表示这些元素（还）未存放任何对象。

#### 3.10.2 数组初始化以及匿名数组

```java
int[] small Primes = { 2, 3, 5, 7, 11, 13 };//简化的初始化方法
new int { 17, 19, 23, 29, 31, 37 }//匿名数组
```

#### 3.10.3 数组拷贝

使用Arrays的arrayCopy方法或者clone方法。

#### 3.10.4 命令行参数

```java
//main方法中的参数String[] args是一个命令行参数，如果在命令行中执行Java程序，那么可以使用命令为main函数传入参数。例如：
java Message -g cruel world
```

#### 3.10.6 多维数组

> 要想快速地打印一个二维数组的数据元素列表， 可以调用： System.out.println(Arrays.deepToString(a));

#### 3.10.7 不规则数组

可以使用不指定列数的方式初始化数组来创建不规则数组。

```java
int[][] odds = new int[NMAX + 1][] ;
for (int n = 0; n <= NMAX ; n++)
	odds [n] = new int[n + 1];
```

## 第四章 对象与类

### 4.2 使用预定义类

#### 4.2.2 java类库中的LocalDate类

```java
	尽管在使用 Date 类时不必知道这一点，但时间是用距离一个固定时间点的毫秒数（可正
可负） 表示的， 这个点就是所谓的纪元（ epoch), 它 是 UTC 时间 1970 年 1 月 1 日 00:00:00。
UTC 是 Coordinated Universal Time 的缩写，与大家熟悉的 GMT ( 即 Greenwich Mean Time,
格林威治时间）一样，是一种具有实践意义的科学标准时间。
```

### 4.4 静态域与静态方法

#### 4.3.5 隐式参数和显示参数

* 出现在方法名之前的对象为隐式参数
* 方法的参数为显式参数。
* 在每一个方法中， 关键字 this 表示隐式参数（表示此对象）。

#### 4.4.1 静态域

* 静态域属于类不属于某个对象，所有的对象共享一个静态数据。

#### 4.4.2 静态常量

> 静态变量使用得比较少，但静态常量却使用得比较多。

> **注意：**如果查看一下 System 类， 就会发现有一个 setOut 方法， 它可以将 System.out 设 置为不同的流。 读者可能会感到奇怪， 为什么这个方法可以修改 final 变量的值。原因在 于， setOut 方法是一个本地方法， 而不是用 Java 语言实现的。本地方法可以绕过 Java 语 言的存取控制机制。这是一种特殊的方法， 在自己编写程序时， 不应该这样处理。

#### 4.4.3 静态方法

* 静态方法不能访问非静态的属性。
* 静态方法可以通过对象访问非静态的属性以及非静态的方法。

### 4.5 方法的参数

> * 按值调用 （call by value) 表示方法接收的是调用者提供的值。
> * 按引用调用 （ call by reference) 表示方法接收的是调用者提供的变量地址。
> * 一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。

Java总是采用按值调用。所以：

* java中一个方法不能修改一个基本数据类型的参数。
* java中一个方法可以改变一个对象参数的状态。
* 一个方法不能让对象参数引用一个新的对象，因为对象参数也是按值传递，所以只能改变对象的状态，不能改变对象的引用。

### 4.6 对象的构造

#### 4.6.1 重载

* 如果多个方法（比如， StringBuilder 构造器方法）有 相同的名字、 不同的参数，便产生了重载。
* 因此如果要完整的描述一个方法需要指出方法名和方法参数类型，这叫做方法的签名（signature）。
* 返回类型不是方法签名的一部分。也就是说， 不能有两个名字相同、 参数类型也相 同却返回不同类型值的方法。

#### 4.6.2 默认域初始化

* 如果没有显式地给域赋初始值，那么就会被自动赋默认值：数值型为0，boolean为false，对象引用为null。

#### 4.6.8 对象析构与finalize方法

​		可以为任何一个类添加 finalize 方法。finalize 方法将在垃圾回收器清除对象之前调用。 在实际应用中，不要依赖于使用 finalize 方法回收任何短缺的资源， 这是因为很难知道这个 方法什么时候才能够调用。

### 4.7 包

> 使用包的主要原因是确保类名的唯一性。

#### 4.7.2 静态导入

> import 语句不仅可以导人类，还增加了导人静态方法和静态域的功能。

* 如果使用静态导入，就可以使用 类的静态方法和静态域，而不必加类名前缀：

#### 4.7.4 包作用域

* 如果没有指定 public 或 private , 这 个 部 分（类、方法或变量）可以被同一个包中的所有方法访问。

## 第五章 继承

> ​		有些人认为 super 与 this 引用是类似的概念， 实际上，这样比较并不太恰当。这是 因为 super 不是一个对象的引用， 不能将 super 赋给另一个对象变量， 它只是一个指示编 译器调用超类方法的特殊关键字。

> ​		如果子类的构造器没有显式地调用超类的构造器， 则将自动地调用超类默认（没有参数 ) 的构造器。 如果超类没有不带参数的构造器， 并且在子类的构造器中又没有显式地调用超类 的其他构造器’ 则 Java 编译器将报告错误。

> ​		不能将一个超类的引用赋给子类变量

> 在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。

#### 5.1.7 阻止继承：final类和方法

* 不允许扩展的类被称为 final 类。
* 不允许改变语义的方法定义为final方法。
* 构造类之后不允许改变的量定义为final变量。

### 5.2 Object：所有类的子类

#### 5.2.2 编写equals的建议

1. 显式参数命名为 otherObject, 稍后需要将它转换成另一个叫做 other 的变量。
2. 检测 this 与 otherObject 是否引用同一个对象： if (this = otherObject) return true; 这条语句只是一个优化。实际上，这是一种经常采用的形式。因为计算这个等式要比一 个一个地比较类中的域所付出的代价小得多。 
3. 检测 otherObject 是否为 null, 如 果 为 null, 返 回 false。这项检测是很必要的。 if (otherObject = null) return false; 
4. 比较 this 与 otherObject 是否属于同一个类。如果 equals 的语义在每个子类中有所改 变，就使用 getClass 检测： if (getClass() != otherObject.getCIassO) return false; 如果所有的子类都拥有统一的语义，就使用 instanceof 检测： if (!(otherObject instanceof ClassName)) return false; 
5. 将 otherObject 转换为相应的类类型变量： ClassName other = (ClassName) otherObject 
6. 现在开始对所有需要比较的域进行比较了。使用 =比较基本类型域，使用 equals 比 较对象域。如果所有的域都匹配， 就返回 true; 否 则 返 回 false。
7. 如果在子类中重新定义 equals, 就要在其中包含调用 super.equals(other。

### 5.3 泛型数组列表

java中允许在运行时确定数组的大小。

```java
ArrayList<Employee> staff = new ArrayList<Eniployee>();
//Java SE 7中， 可以省去右边的类型参数：
ArrayList<Employee> staff = new ArrayListo<>()；
```

* 在 Java SE 5.0 以后的版本中， 没有后缀 <• .•> 仍然可以使用 ArrayList, 它将被认为是一个删去了类型参數的“ 原始” 类型、

在ArrayList类中可以调用trimToSize修剪数组容量的大小到当前数据中数据的大小。

### 5.4 对象包装器与自动装箱

* 这些对象包装器类 拥有很明显的名字：Integer、Long、Float、Double、Short、Byte、Character 、**Void** 和 Boolean (前 6 个类派生于公共的超类 Number)。
* 对象包装器类是**不可变的**，即一旦构造了包装器，就不 允许更改包装在其中的值。
* 对象包装器类还是 **final** , 因此不能定义它们的子类。

将基本类型用于包装器类型时会自动装箱。

> **自动装箱规范要求 boolean、byte、char <=127， 介于 -128 ~ 127 之间的 short 和 int 被包装到固定的对象中。**
>
> 如果在一个条件表达式中混合使用 Integer 和 Double 类型， Integer 值就会拆箱， 提升为 double, 再装箱为 Double
>
> 装箱和拆箱是编译器认可的，而不是虚拟机。编译器在生成类的字节码 时， 插人必要的方法调用。虚拟机只是执行这些字节码。

将包装器类型用于基本类型时会自动拆箱。

### 5.5 参数数量可变的方法

使用Object（类型）+ ...的方式实现参数可变

编译器需要对使用可变参数的函数的每次调用进行转换， 以便将参数绑定到**数组上**，并在必要的时候 进行**自动装箱**

### 5.6 枚举类

> 枚举类能够统一管理一些全局的变量，封装对于他们的逻辑与方法。还能和switch-case结合，简化大量的if-else，让代码更加优雅。
>
> 枚举类其实也是颗语法糖。

* 使用enum关键字定义枚举类
* 可以在枚举类型中添加一些构造器、 方法和域，**其中构造器必须切默认为private**
* 所有的枚举类型都是 Enum （这是java中已经存在的一个类）类的子类。

1. enum和class、interface的地位一样
2. 使用enum定义的枚举类默认继承了java.lang.Enum，而不是继承Object类。枚举类可以实现一个或多个接口。
3. 枚举类的所有实例都**必须放在第一行展示**（中间用逗号隔开，末尾用分号结束），此时**默认使用无参构造函数**，如果自己定义了构造函数切有参数，那么必须在实例声明的时候显示传入参数，不需使用new 关键字，**不需显式调用构造器**。自动添加public static final修饰。
4. 使用enum定义、非抽象的枚举类默认使用final修饰，不可以被继承。
5. 枚举类的构造器只能是私有的。

### *5.7 反射*

能够分析类能力的程序称为反射（reflective )。

#### 5.7.1 Class类

用于保存java运行时所有对象的信息。虚拟机利用运行时类型信息选择相应的方法执行。

> 注意：一个 Class 对象实际上表示的是一个类型，而这个类型未必一定是一种类。例如， int 不是类， 但 int.class 是一个 Class 类型的对象。

* Class 类实际上是一个泛型类。

```java
public final class Class<T> implements java.io.Serializable,
                              GenericDeclaration,
                              Type,
                              AnnotatedElement
```

#### 5.7.2 捕获异常

异常有两种类型： 未检查异常和已检查异常。例如，访问 null 引用， 都属于未检查异常。

#### 5.7.3 利用反射分析类

反射机制最重要的内容—检查类的结构。

在 java.lang.reflect 包中有三个类 Field、 Method 和 Constructor 分别用于描述类的域、 方 法和构造器。

​		Class类中的 getFields、 getMethods 和 getConstructors 方 法 将 分 别 返 回 类 提 供 的 **public 域、 方法和构造器数组， 其中包括超类的公有成员**。Class 类的 getDeclareFields、 getDeclareMethods 和 getDeclaredConstructors 方法将分别返回类中**声明的全部域、 方法和构 造器， 其中包括私有和受保护成员，但不包括超类的成员。**

### 5.8 继承的设计技巧

1. 将公共的操作和域放在超类
2. 不要使用受保护的域

原因：1、子类集合是无限的，任何一个子类都可以访问protected域。2、java语言中，同一个包也可以访问protected，不管他是不是子类。

3. 使用继承实现“ is-a” 关系
4. 除非所有继承的方法都有意义，否则不要使用继承
5. 在覆盖方法时，不要改变预期的行为
6.  使用多态， 而非类型信息
7. 不要过多地使用反射

## 第六章 接口、lamba表达式与内部类

### 6.1 接口

#### 6.1.2 接口的概念

接口不是类，而是对类的一组需求的描述，这些类要遵循接口描述的统一格式进行定义。（可以将接口看成没有实例域的抽象类）。

接口中方法自动的属于public。

在接口中还可以定义常量。

java8以后接口中可以实现简单的方法。

**警告：**如果实现接口中的方法，那么这个方法必须是public，否则会报错。

> 如果使用Arrays的sort方法对一个对象数组进行排序，如果对象数组没有实现Comparable接口，那么程序就会报ClassCastException 异常。

#### 6.1.2 接口的特性

接口中的域将被自动设为 public static final。

#### 6.1.3 接口与抽象类

不把接口设计为抽象类的原因是接口可以实现一种多继承的机制，但是java不支持多继承，所以用实现接口来代替这种方式。

#### 6.1.4 静态方法

java8之后，允许在接口中增加静态方法。

但是到目前为止，标准库中都是将静态方法放到伴随类中，例如，Collection接口和Collections类，但是我们写的时候不必要写伴随类，直接在类中写静态方法。

#### 6.1.5 默认方法

可以为接口中的方法提供一个默认的实现，但是必须使用default修饰符修饰，这样一个默认方法在继承的类中可以不实现。

**默认方法的一个重要用法是“接口演化” （interface evolution）。**之前写的代码所实现的接口如果要新加一些方法，那么可以把这些方法定义为默认方法，这样之前写的代码就不会有问题了。

#### 6.1.6 解决默认方法冲突

如果先在一个接口中将一个方法定义为默认方法， 然后又在超类或另一个接口中定义了 同样的方法， 会发生什么情况？ java中的规则和解决方法如下：

1. 超类优先。如果超类提供了一个具体方法，同名而且有相同参数类型的默认方法（接口中的方法）会被忽略。
2. 接口冲突。 如果一个超接口提供了一个默认方法，另一个接口提供了一个同名而且 参数类型（不论是否是默认参数）相同的方法， 必须覆盖这个方法来解决冲突。

### 6.2 接口示例

### 6.3 lambda表达式

#### 6.3.1 为什么引入 lambda 表达式

在 Java 中传递一个代码段并不容易， 不能直接传递代码段 。Java 是一种面 向对象语言，所以必须构造一个对象，这个对象的类需要有一个方法能包含所需的代码，具体的表现可以参考策略模式。

#### 6.3.2 lambda 表达式的语法

java8中引入了一个新的操作符“->”，箭头操作符或lambda操作符。

lambda需要函数式接口的支持。

箭头操作符将lambda表达式分成两部分：

* 左侧：指定了Lambda表达式的参数列表——接口中方法的参数列表
* 右侧：指定了表达式中所需执行的功能——接口中要实现 的方法体

语法格式：

1. 无参数，无返回值

   （）->执行的功能，**使用外部的同一界别的变量，那么这个变量必须是final的，和内部类的规则一样**

2. 一个参数，无返回值

   （x）->执行的功能

3. 一个参数

   小括号可以不写，一般都写上。

4. 有多个参数，并且Lambda体中有多条语句，有返回

   Lambda中的多条语句用大括号括起来。

5. Lambda中只有一条语句

   大括号和return都可以不写

6. Lambda表达式的参数列表的数据类型可以省略不写，因为JVM编译器可以通过上下文推断出数据类型，即“类型推断”

#### 6.3.3 函 数 式 接 口

Lambda表达式需要“函数式接口”的支持

函数式接口：接口中只有一个抽象方法。可以使用注解@FunctionalInterface修饰，这个注解可以检查这个接口是否是一个函数式接口。

实际上在极少数情况下会自己定义函数式接口，我们使用内置的函数式接口。

#### Java8内置的四大核心函数式接口

1. Consume<T> :消费型接口
2. Supplier<T> : 供给型接口
3. Function<T,R>: 函数型接口
4. Predicate<T>: 断言型接口

#### 6.3.4 方法引用

[详情](https://blog.csdn.net/weixin_44431458/article/details/120758966)

容Lambda体中的内容有方法已经实现了，我们可以使用方法引用（可以理解为方法引用是Lambda表达式的另外一种表现形式）。

**前提**：Lambda体要实现的方法的返回值和参数列表要和引用的方法的返回值和参数列表一样。

主要有三种语法格式：

1. 对象：：实例方法名
2. 类：：静态方法名
3. 类：：实例方法名 **前提：lambda表达式的第一个参数是实例方法的调用者，第二个参数是实例方法的参数**

#### 6.3.5 构造器引用

语法格式：

1. ClassName：：new

用抽象接口方法的参数列表自动匹配引用的构造器的参数（有参？无参？或者几个参数）。

注意：需要调用的构造器的参数列表需要和抽象方法中的参数列表保持一致。

#### Lambda的数组引用

语法格式：

1. Type：：new

其实和构造器的引用差不多。

#### 6.3.6 变量作用域

* Lambda表达式中捕获的变量只能是最终变量（final）

* lambda 表达式的体与嵌套块有相同的作用域。这里同样适用命名冲突和遮蔽的有关规 则。在 lambda 表达式中声明与一个局部变量同名的参数或局部变量是不合法的。
* 在一个 lambda 表达式中使用 this 关键字时， 是指创建这个 lambda 表达式的方法的 this 参数。

### 6.4 内部类

内部类（ inner class) 是定义在另一个类中的类。

为什么要使用内部类：

1. 内部类方法可以访问该类定义所在的作用域中的数据， 包括私有的数据。
2. 内部类可以对同一个包中的其他类隐藏起来。
3. 当想要定义一个回调函数且不想编写大量代码时，使用匿名 （anonymous) 内部类比较 便捷。

#### 6.4.1 使用内部类访问对象状态

在构造一个内部类的时候，编译器会给内部类的构造方法中传入一个引用外部类的参数，因此在内部类的内部可以访问外部类对象中的数据。

#### 6.4.2 内部类特殊语法规则

* 内部类中声明的所有静态域必须是final的。原因很简单，静态域是本类所有实例共享的，但是对于每一个外部类，他都有一个内部类的实例，如果static域不是final，不同外部类可以改变自己内部类的static域，就造成一个类的static域不唯一。
* 内部类不能有static方法。

#### 6.4.3 内部类是否有用、必要和安全

内部类是一种编译器现象，编译器在编译类文件的时候，会把内部类转化，形成一个常规类文件，然后利用构造函数向这个类中传递外部类的引用，还在外部类中创建了可以访问私有域的方法，用于内部类访问私有域。

![image-20211008095913939](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20211008095913939.png)

![image-20211008100101526](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20211008100101526.png)

编译器这样处理内部类会存在安全问题。

#### 6.4.4 局部内部类

在一个方法中定义局部内部类。

* 局部类不能用 public 或 private 访问说明符进行声明。它的作用域被限定在声明这个局部 类的块中。
* 在这个方法的外部即使是一个类中的其他代码也不能访问局部内部类

#### 6.4.5 由外部方法访问变量（没明白）

与其他内部类相比较，局部类还有一个优点。它们不仅能够访问包含它们的外部类， 还 可以访问局部变量。不过，那些局部变量必须事实上为 final。这说明， 它们一旦赋值就绝不 会改变。

#### 6.4.6 匿名内部类

#### 6.4.7 静态内部类

有时候， 使用内部类只是为了把一个类隐藏在另外一个类的内部，并不需要内部类引用 外围类对象。为此，可以将内部类声明为 static, 以便取消产生的引用。

* 与常规类不同静态内部类可以有静态域和方法。
* 声明在接口中的内部类自动的是static和public。
* 静态内部类默认地是包访问级别。

### 6.5 代理

## 第七章 异常、断言和日志

### 7.1 处理错误

<img src="C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20211010094814246.png" alt="image-20211010094814246" style="zoom:80%;" />

#### 7.1.1 异常分类

Java中所有的异常都是从Throwable类中继承而来。在下一层分为两个分支：Error和Exception。

Error类描述了Java程序运行时系统内部错误和资源耗尽错误。

在Java程序中我们主要使用的是Exception错误。这个层次有分为两个分支：RuntimeException和IOException。由程序错误导致的异常是RuntimeException；程序本身没有问题，但是由像I/O错误这类问题导致的异常属于IOException。

派生于RuntimeException的异常包含下面几种情况：

* 错误的类型转换。
* 数组访问越界
* 访问Null指针

不是派生于RuntimeException的异常包括：

* 试图在文件尾部后面读取数据
* 试图打开一个不存在的文件
* 试图根据给定的字符串查找Class对象，而这个字符串表示的类对象并不存在。

Java语言规范将派生于Error或者RuntimeException类的所有异常称为非受查（unchecked）异常，所有其他异常称为受查（checked）异常。**编译器将核查代码是否已经为所有的受查异常提供异常处理器。**

> 注意：RuntimeException这个名字很容易让人误解，实际上，现在所讨论的所有错误都发生在运行时。

#### 7.1.2 声明受查异常

* 子类覆盖超类的方法，子类声明的受查异常不能比超类的受查异常更通用。
* 如果超类中的方法没有抛出任何受查异常，那么子类也不能抛出任何受查异常。
* 如果一个catch语句试图捕获受查异常，那么它对应的try语句必须有可能抛出该受查异常或者七子类异常，否则编译器会提示编译错误。

#### 7.1.3 如何抛出异常

1.  找到一个合适的异常类。 
2. 创建这个类的一个对象。 
3.  将对象抛出。

#### 7.1.4 创建异常类

习惯上定义的类应该包含两个构造器，一个是默认构造器，另一个是带有详细描述信息的构造器。

### 7.2 捕获异常

#### 7.2.1 捕获异常

* 如果调用了一个抛出受查异常的方法，那么必须对它进行处理或者继续抛出。	
* 如果编写一个覆盖父类的方法，父类的这个方法没有抛出异常，那么这个调用了受查异常的子类方法必须对异常进行处理，不能将异常继续抛出。

#### 7.2.2 捕获多个异常

* 一个try语句可以使用多个catch语句捕获多个异常。
* 也可以使用同一个catch语句捕获多个异常，捕获多个异常时，异常变量隐含的为final变量，不能在语句中对异常进行赋值。

#### 7.2.3 再次抛出异常与异常链

在catch语句中可以抛出一个异常，这样做的目的是改变异常的类型。可以把系统的异常换为自己定义的异常。

```java
public synchronized Throwable initCause(Throwable cause) {
        if (this.cause != this)
            throw new IllegalStateException("Can't overwrite cause with " +
                                            Objects.toString(cause, "a null"), this);
        if (cause == this)
            throw new IllegalArgumentException("Self-causation not permitted", this);
        this.cause = cause;
        return this;
    }

public synchronized Throwable getCause() {
    return (cause==this ? null : cause);
}
```

Throwable中的这两个方法可以用于使用其他异常构造一个异常，从一个异常中获取原因（可能为其他异常）。这种包装技术可以让用户抛出子系统中的高级异常，而不会丢失原始异常的细节。

> 提示：如果在一个方法中发生了一个受查异常，然而这个方法不允许抛出他，但是由不想处理这个异常，那么就可以使用包装技术把这个受查异常包装为一个运行时异常。

#### 7.2.4 finally语句

* 无论try是否遇到异常，finally中的语句都会执行。
* 强烈建议解搞合 try/catch 和 try/finally 语句块。这样可以提高代码的清晰度。外层try加catch语句，内层try加finally语句，这样的设计还具有另一种功能，就是将finally中的异常捕获。
* 无论是try中含有return还是catch中含有throw或者return，执行这些语句之前都会执行finally中的语句。并且如果finally中含有return语句，那么将会覆盖try和catch中的return。
* try，catch，finally语句中，如果在try/catch块中存在return语句，finally块没有return语句，try/catch块会产生一个临时变量(**t’**)存储return 语句中的变量(**t**)，如果这个变量类型是值类型或者不可变对象，则在finally块中对变量t的修改不会影响到try/catch中返回的结果；如果是可变对象类型，则结果会影响；
* 如果finally块中有return语句，则try和catch中的return语句都会忽略；
* 如果finally块中抛出异常，则停止try…catch…finally中的其他操作，直接向上抛出异常。

#### 7.2.5 带资源的 try 语句

在try语句后面使用括号可以定义**一组**需要关闭的资源，这些资源不需要手动关闭，try语句退出的时候会自动关闭这些资源，但是前提是这些资源都实现了AutoCloseable或者Closeable接口。

带资源的try语句可以很好的处理资源关闭时也会抛出异常的情况。try语句原来的异常会重新抛出，而close方法抛出的异常会“被抑制”。这些异常将自动捕获，并由addSuppressed方法添加到原来的异常。也可以调用getSuppressed方法，它可以返回close方法抛并被抑制的异常列表。

#### 7.2.6 分析堆栈轨迹元素

### 7.3 使用异常机制的技巧

1. 异常处理不能代替简单的if判断，在使用异常处理之前可以判断能不能使用if判断把这个异常避免掉，因为if判断的运行时间比异常捕获的处理时间少很多。
2. 不要过分地细化异常，一段代码中如果有很多语句存在异常，那么我们不要对每一个语句都进行异常的捕获，把语句的正常执行和异常的捕获分离开，总的捕获一段代码所产生的的异常。
3. 利用异常的层次结构。不要总是抛出或者捕获高级别的异常，将一种异常转化为另一种异常的时候不要犹豫。
4. 不要压制异常。
5. 异常要早抛出、晚捕获

### 7.4 使用断言

#### 7.4.1 断言的概念

*为什么要有断言呢？*平常的异常处理机制会在程序的整个开发以及上线之后一直存在，如果程序上线还存在某些没有必要的异常处理（比如有时候我们会肯定某些异常不可能发生），那么就会减慢程序的运行。所以就出现了断言。

断言机制允许我们在程序测试阶段向代码中加入一些判断，当程序发布之后，这些语句就可以被移走。

assert关键字的用法有两种形式：

* assert 条件；
* assert 条件：表达式；

这两种形式都会对条件进行判断，如果不满足条件就会抛出一个AssertionError异常，第二种形式中的表达式将被传人 AssertionError 的构造器， 并转换成一个消息字符串。

#### 7.4.2 启用和禁用断言

在启用或禁用断言时不必重新编译程序。启用或禁用断言是类加载器 ( class loader) 的功能。当断言被禁用时， 类加载器将跳过断言代码， 因此，不会降低程序运 行的速度

* 在默认情况下， 断言被禁用。可以在运行程序时用 -**enableassertions 或 -ea** 选项启用：`java -enableassertions MyApp`
* 也可以用选项 -**disableassertions 或 -da** 禁用某个特定类和包的断言：`java -ea:... -da:MyClass MyApp`
* 启用和禁用所有断言的 -ea 和 -da 开关不能应用到那些***没有类加载器的“ 系统类” 上***。对于这些系统类来说， 需要使用 -**enablesystemassertions/-esa** 开关启用断言。

### 7.5 记录日志（改为log4j）

`java.util.logging.Logger;`这个类可以用与日志信息的打印。

#### 7.5.2 高级日志

在一 个专业的应用程序中，不要将所有的日志都记录到一个全局日志记录器中，而是可以自定义 日志记录器。

可以使用getLogger方法创建或者获取日志记录器。

```java
private static final Logger myLogger = Logger.getLogger("com.mycompany.myapp"):
```

为什么要使用static，因为如果这个日志记录器没有被任何变量引用可能会被垃圾回收，为了防止这种事情发生，需要一个静态变量存储日志记录器的一个引用。

如果对 com.mycompany 日志记录器设置了日志级别， 它的子记录器也会继承这个级别 。

java内置的日志记录器具有7个日志级别，默认使用info级别，比info级别高的输出：

1. severe：十分严重的，最高级别
2. WARNING 
3. INFO 
4. CONFIG 
5. FINE
6. FINER
7. FINEST

后三个一般使用其中一个就行。

另外， 还可以使用 Level.ALL 开启所有级别的记录， 或者使用 Level.OFF 关闭所有级别 的记录。

## 第八章 泛型程序设计

使用泛型机制编写的程序代码要比那些杂乱地使用 Object 变量，然后再进行强制类型转换的代码具有更好的安全性和可读性。

### 8.1 为什么要使用泛型程序设计

*泛型程序设计*（Generic programming) 意味着编写的代码可以被很多**不同类型的对象所 重用。**

#### 8.1.1 类型参数的好处

在 Java 中增加范型类之前， 泛型程序设计是用继承实现的。ArrayList 类只维护一个 Object 引用的数组：

这种方式用两个问题：

1. 当获取一个值的时候必须强制类型转换
2. 添加值的时候可以添加任意值，在获取值的时候会造成潜在的错误

泛型提供了一个更好的解决方案： **类型参数**（ type parameters)。ArrayList 类有一个类型 参数用来指示元素的类型，使用这种方式之后，编译器可以检查Arraylist中添加或则获取的值是什么类型。

类型参数的魅力在于：使得程序具有更好的可读性和安全性。

#### 8.1.2 通配符类型

```java
Pair<? extends Employee>
```

通配符类型中允许类型参数发生变化。

### 8.2 定义简单的泛型类

一个泛型类就是一个具有一个或者多个类型变量的类。

泛型类可以有多个类型变量。

类定义中的类型变量指定方法的返回值以及域和局部变量的类型。

在 Java 库中， 使用变量 E 表示集合的元素类型， K 和 V 分别表示表的关键字与值的类型。T ( 需要时还可以用临近的字母 U 和 S) 表示“ 任意类型”。

### 8.3 泛型方法

还可以定义一个带有类型参数的简单方法。

![image-20211025082632791](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20211025082632791.png)

注意：类型变量放在方法修饰符后面，放在方法返回值前面。

当调用一个泛型方法的时候，方法名前面的<>中放入具体的类型。

![image-20211025082827122](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20211025082827122.png)

在这种情况（实际也是大多数情况）下，方法调用中可以省略 <String> 类型参数。编译

器有足够的信息能够推断出所调用的方法。它用 names 的类型（即 String[ ]) 与泛型类型 T[ ]

进行匹配并推断出 T 一定是 String。

### 8.4 类型变量的限定

如果想对类和方法中的类型变量加以限定，比如说必须实现什么方法等，可以使用extends关键字限定类型变量必须是那种类型的子类或者实现了什么接口。

限定类型用“ &” 分隔，而逗号用来分隔类型变量。

```java
<T extends BoundingType>
T extends Comparable & Serializable
```

### 8.5 泛型代码和虚拟机

虚拟机中没有泛型类型对象，所有对象都属于普通类。

#### 8.5.1 类型擦除

Java的泛型是伪泛型，这是因为Java在**编译期**间，所有的泛型信息都会被擦掉，正确理解泛型概念的首要前提是理解类型擦除。Java的泛型基本上都是在编译器这个层次上实现的，在生成的字节码中是不包含泛型中的类型信息的，使用泛型的时候加上类型参数，在编译器编译的时候会去掉，这个过程成为类型擦除。

无论何时定义一个泛型类型，都自动提供了一个相应的原始类型，原始类型的名字就是删去类型参数后的泛型类型名，擦除类型变量并替换为限定类型（无限定类型的变量使用Object）。

原始类型用第一个限定的类型变量来替换， 如果没有给定限定就用 Object 替换。

#### 8.5.2 翻译泛型表达式

当程序调用泛型方法时，如果返回类型被擦除，编译器会插入强制类型转换，例如：

```java
Pair<Employee> buddies = .....;
Employee buddy = buddyies.getFirst();
```

擦除getFirst的返回类型后将返回Object类型，编译器自动插入Employee的强制类型转换，也就是说，编译器会把这个方法调用翻译为两条虚拟机指令：

1. 对原始方法getFirst调用
2. 将返回的Object类型强制转换为Employee类型。

当存取一个泛型域是也要插入强制类型转换。

#### 8.5.3 翻译泛型方法

总之，需要记住有关 Java 泛型转换的事实： 

• 虚拟机中没有泛型，只有普通的类和方法。 

•所有的类型参数都用它们的限定类型替换。 

•桥方法被合成来保持多态。 

•为保持类型安全性，必要时插人强制类型转换。

#### 8.5.4 调用遗留代码

### 8.6 约束与局限性

#### 8.6.1 不能用基本类型实例化类型参数

类型擦除之后， Pair 类含有 Object 类型的域， 而 Object 不能存储 double {to

#### 8.6.2 运行时类型查询只适用于原始类型

虚拟机中的对象总有一个特定的非泛型类型。因此，所有的类型查询只产生原始类型。

```java
if (a instanceof Pair<String>) // Error
if (a instanceof Pair<T>) // Error
Pair<St「ing> p = (Pair<String>) a; // Warning-can only test that a is a Pair
```

#### 8.6.3 不能创建参数化类型的数组

z
