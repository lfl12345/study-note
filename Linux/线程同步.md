协作进程（cooperating process）能与系统内的其他执行进程相互影响。协作进程或能直接共享逻辑地址空间（即代码块和数据），或能通过文件或消息来共享数据。前一种情况可通过线程来实现。然而共享数据的并发访问可能导致数据的不一致。

多线程并发访问共享资源一定会造成竞争条件（race condition）（当多个进程都企图对共享数据进行某种处理，而最后的结果又取决于进程运行的顺序时，则我们认为这发生了竞争条件（race condition））

## 使用互斥锁（mutex）

使用的是**建议锁**，对公共资源进行保护。所有线程在访问公共资源之前应该先拿到锁再去访问，如果直接去访问公共资源还是可以访问到的，因此建议锁不具备强制性。

mutex多个线程的执行过程：当一个线程拿到锁之后，进入临界区，对公共资源进行访问修改，当这个线程还没有释放锁之前，如果CPU被其他线程抢占，抢占的线程应该先去拿锁，此时第一个线程还没有释放锁，因此抢占的线程拿不到锁也就不能对共享资源进行访问和修改，知道第一个线程执行完临界区然后把锁释放之后，其他线程才能拿到锁并访问共享资源。

![image-20211220200114147](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20211220200114147.png)

restrict关键字的作用：一片内存空间的修改只能由指定的指针去操作，使用其他指向这篇内存空间的指针不能操作这个内存。

初始化互斥量有两种方法，静态初始化和动态使用init函数的初始化

## 注意事项

尽量让锁的粒度越小越好

在使用锁的时候一定要注意解锁之后本线程最好不要立马拿到锁。（有限等待）

互斥锁本质是结构体

加锁：--操作，阻塞线程

解锁：++操作，唤醒阻塞在锁上的线程

lock加锁失败会阻塞线程，等待锁的释放

try锁：尝试加锁，成功锁--，失败，返回错误号（EBUSY，锁正忙）

## 死锁

第一种情况：一个线程对一个锁反复加锁；

第二种情况：用于资源A的线程1去获取资源B，拥有资源B的线程2去获取资源A

## 使用读写锁

是一种建议锁

读共享，写独占

写锁优先级高

锁只有一把

读写锁的特性：

1. 读写锁是“写模式加锁”时，解锁前，所有对该锁加锁的线程都会被阻塞。
2. 读写锁是“读模式加锁”时，如果线程以读模式对其加锁成功，如果线程以写模式加锁会阻塞
3. 读写锁是“读模式加锁”时，如果同时有读线程加锁，也有写线程加锁，那么读写锁会阻塞后面的读操作，优先满足写操作。读锁写锁并行阻塞，写锁优先级高

<img src="C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20211220215316077.png" alt="image-20211220215316077" style="zoom:50%;" />

## 条件变量

条件变量本身不是锁，而是等待某一个条件满足，他也会造成阻塞，但是通常要结合锁来使用（参数中需要互斥锁），通常结合互斥锁mutex

<img src="C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20211220221222343.png" alt="image-20211220221222343" style="zoom:50%;" />

初始化方式有两种，静态初始化和动态初始化，和mutex的两种方式一样

pthread_cond_wait函数：阻塞等待一个条件变量

函数的作用：

* 阻塞等待条件变量满足
* 释放已掌握的互斥锁，相当于unlock操作
  * 1、2两步为原子操作
* 当被唤醒，pthread_cond_wait函数返回时，解除阻塞并重新申请获取互斥锁。 

![image-20211220222816448](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20211220222816448.png)

<img src="C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20211220222954917.png" alt="image-20211220222954917" style="zoom:67%;" />

pthread_cond_singal：唤醒阻塞在条件变量的一个线程

pthread_cond_broadcast：唤醒阻塞在条件变量中的所有线程

## 信号量

进化版的互斥量

由于互斥锁的粒度比较大，如果我们希望在多个线程之间对某一变量的部分数据进行共享，使用互斥锁是没有办法做到的，互斥锁只能将整个对象锁住。这样虽然达到了多线程操作共享数据时保证数据正确性的目的，却无形中导致线程的并发性下降。线程从并行执行编程了串行执行。这样和单线程没有什么区别。

信号量是一种折中的处理方式，即能保证并发量，又可以保证数据的一致性，

可以应用在线程同步中，也可以应用在进程同步中。

## 线程错误检测

![image-20211221162452822](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20211221162452822.png)