# Java内存区域与内存溢出异常

## 运行时数据区

JVM在运行Java程序的时候，会把它所管理的内存划分成若干不同的数据区域。这些区域有各自的用途，以及创建的时间和销毁的时间。JVM所管理的内存包括一下几个区域：

* 方法区
* 堆
* 虚拟机栈
* 本地方法栈
* 程序计数器

### 程序计数器

<img src="C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220106221505705.png" alt="image-20220106221505705" style="zoom:50%;" />

#### 定义

程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。

#### 作用

字节码解释器的工作就是通过改变程序计数器中的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖程序计数器来完成。

#### 特点

* 因为多线程需要并发执行（线程切换之后能恢复到正确的位置），所以程序计数器是线程私有的
* 如果线程正在执行Java方法，计数器记录的是正在执行的虚拟机字节码指令地址；如果正在执行本地方法，计数器的值为空（Undefined）
* 此内存区域是唯一一个没有规定OutOfMemoryError情况的区域，也就是不存在这个错误。因为就保存一个地址而已，不存在内存溢出。

### Java虚拟机栈

#### 定义

虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机栈就会同步创建一个栈帧（Stack Frame）用于存储**局部变量表、操作数栈、动态连接、方法出口**等信息。

#### 特点

* 线程私有，栈的生命周期和线程的一样

#### 局部变量表

局部变量表存放了**编译期间可知**的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型）和一个returnAddress类型（指向了一条字节码指令地址）。

这些数据类型在局部变量表中的存储空间以局部变量槽（Slot）表示，其中long和double会占用两个变量槽，其余占用一个。

局部变量表所需要的**槽的数量**（槽的大小并不确定，根据虚拟机）在编译期完成分配，当进入一个方法的时候，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的。

#### 栈内存溢出

StackOverFlowError、OutOfMemoryError

* 栈帧过多：如果线程请求的栈深度大于虚拟机允许的深度
* 栈帧过大，不能分配足够的栈内存。

### 本地方法栈

虚拟机栈为虚拟机执行java方法服务，本地方法栈则是为虚拟机使用到的本地方法服务。

Hot-Spot虚拟机将本地方法栈和虚拟机栈合二为一。

和虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverFlowError、OutOfMemoryError。

### Java堆

Java堆是虚拟机所管理的内存中最大的一块；Java堆是被多个线程共享的一块内存区域，在虚拟机启动的时候创建。

几乎所有的对象实例以及数组都在堆上创建。

Java堆是垃圾回收器管理的内存区域。

将Java堆细分的目的是为了更好地进行垃圾回收或者更快地分配内存。

Java堆可以处于物理上不连续的内存空间中，但是在逻辑上它应该被视为连续的。但是连续的Java堆实现简单、存储高效。

堆内存可以根据虚拟机参数动态分配。

如果堆空间无法再扩展（不足）时，会抛出OutOfMemoryError。

### 方法区

方法区是各个线程共享的内存区域，它用于存储已被虚拟机加载的**类型信息、常量、静态变量、即时编译器编译后的代码缓冲**等数据。

JDK8之前，Hot-Spot虚拟机方法区的实现是永久代，这样可以使得Hot-Spot的垃圾收集器能像管理Java堆内存一样管理这部分内存，省去专门为方法区编写内存管理代码的工作。

JDK8之后，Hot-Spot使用元空间实现方法区。把原本放在永久代的**字符串常量池、静态变量**等移到java堆中，然后使用本地内存实现元空间，把方法区中存储的其他内容存储到元空间中。

### 运行时常量池

**运行时常量池是方法区的一部分**。

Class文件中有一项信息是常量池表（Constant Pool Table），用于存放编译器生成的各种字面量和符号引用，这部分内容在类加载后存放到方法区的运行时常量池中。

运行时常量池**重要的特征是具备动态性**，例如可以使用String的intern方法将一个字符串常量加入运行时常量池中。

既然运行时常量池是方法区的一部分，自然收到方法区的内存限制，如果无法再申请到内存会抛出OutOfMemoryError。

### 直接内存

## HotSpot虚拟机对象探秘

一下对象的探究只包含java的普通对象，通过new创建，不包括数组、Class对象以及**通过复制反序列化创建**的对象。

### 对象的创建

1. 首先检查new指令的参数是否能在**常量池**中定位到一个类的**符号引用**，并且检查这个符号引用所代表的类是否已经被**加载、解析和初始化过**，如果没有必须先执行**类加载过程**。
2. 类加载检查通过之后，虚拟机将为新生对象分配内存。
3. 内存分配完成之后，虚拟机将内存初始化为零，这样就保证了对象的实例字段在java代码中可以不赋初值就直接使用
4. 接下来，jvm还需要对对象进行必要的设置，设置**对象头**
5. 在上面工作完成之后，从jvm的角度来看，一个新的对象已经产生了，但是从java程序的角度来看，对象创建才刚刚开始——构造函数，即Class文件中的\<init>()方法还没有执行，所有的字段都是默认值。
6. 执行完\<init>()方法之后，一个真正可用的对象才算完全构造出来。

### 对象的内存布局

在HotSpot中，对象在堆中的存储布局可以分为三部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。

#### 对象头

HotSpot对象的对象头包含两类信息：

* 用于存储对象自身的运行时的数据，称为Mark Word
* 对象的类型指针

##### Mark Word

存储对象的哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。

对象需要存储的运行时的数据很多，其实已经超过了32、64位Bitmap结构所能记录的最大限度，考虑到空间使用效率，Mark Word被设计成有着动态定义的数据结构，以便在很小的空间中存储尽量多的数据，换句话说就是Mark Word根据对象的状态来决定这个数据结构中存储内容到低表示什么。

![image-20220115092100632](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220115092100632.png)

![image-20220115091944933](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220115091944933.png)

##### 类型指针

对象指向它的类型元数据的指针，jvm通过这个指针来确定该对象是那个类的实例。

##### 数组长度

如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为通过类的元数据没有办法推断出数组的长度，必须通过对象头。

#### 实例数据

实例数据部分是对象真正存储的有效信息，即我们在程序代码中定义的各种类型的字段内容，无论是从父类继承下来的，还是子类中定义的字段都必须记录起来。

#### 对齐填充

并不是必然存在的，也没有特别的意义，它仅仅起到占位符的作用。

由于HotSpot的自动内存管理系统要求对象的起始地址必须是8字节的整数倍，对象头已经设置为8字节的整倍数（1倍或2倍），因此如果对象的实例数据不是8字节的整倍数的话，就需要通过对齐来填充。

### 对象的访问定位

java程序会通过栈上的reference数据来操作堆上的具体对象。

reference引用定位对象的方法有两种：**使用句柄、直接指针**

* 如果使用句柄访问的方式，Java堆中可能划分出来一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例和对象类型数据各自具体的地址信息
* 如果使用直接指针访问，reference中存储的直接就是 对象的地址。

优点：

使用句柄访问的方式的话，如果堆中的对象被移动的话，只用改变句柄池中的指针，而reference中的指针不用改变。

使用直接指针的话，访问速度更快，它节省了一次指针定位的时间开销。HotSpot使用第二种。