# Java内存模型与线程

## 计算机硬件和jvm类比

由于CPU速度很快，但是内存访问的速度很慢，因此设计了高速缓存来作为内存和处理器之间的缓冲，但是这样的解决方式引来了新的问题：缓存一致性。

在多路处理器系统中，每个处理器都有自己的高速缓存，而他们又共享同一主内存，当多个处理器的运算任务都涉及到同一块主内存区域时，可能导致各自的缓存数据不一致。

内存模型就可以理解为在特定操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象，jvm也有自己的内存模型，并且和硬件的内存访问操作以及硬件的缓存访问操作具有高度的可类比性。

## java内存模型

Java内存模型用来屏蔽各种硬件和操作系统的内存访问差异，以实现让java程序在各个平台下都能达到一致的内存访问效果。

### 主内存和工作内存

java内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。

java内存模型规定了所有的变量都存储在主内存中，每个线程还有自己的工作内存，线程的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的数据。不同的线程之间也无法直接访问对方工作内存的变量，线程间变量值的传递均需要通过主内存来完成。

JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在，它覆盖了缓存，写缓冲区，寄存器以及其他硬件和编译器优化。

### 重排序

重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。

编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。

#### as-if-serial语义

as-if-serial语义的意思是：不管怎么重排序（编译器和处理器为了提高并行度），单线程程序执行结果不能被改变。编译器、runtime和处理器都必须遵循as-if-serial语义。

重排序可能会改变多线程执行的结果，也就是多线程环境下，如果发生了重排序，那么结果不可预知。

### 顺序一致性

顺序一致性内存模型是一个理论参考模型。

当程序没有正确同步时，就可能会存在数据竞争。JMM对正确同步的多线程程序的内存一致性做了如下保证：

* 如果程序时是正确同步，程序的执行将具有顺序一致性——即程序的执行结果和该程序在顺序一致性内存模型中的执行结果相同。

顺序一致性内存模型的两大特征：

* 一个线程中的所有操作必须按照程序的顺序来执行
* （不管程序是否同步）所有线程都只能看到一个单一的执行顺序，在顺序一致性内存模型中，每个操作都是必须原子执行且立刻对所有线程可见。

### volatile内存语义

**两项特征：**

* 可见性：对一个volatile变量的读，总是能看到任意线程对这个volatile变量最后的写入。
* 原子性：对于任意单个volatile变量的读写具有原子性（例如64位的long和double），但是类似于++这种复合操作不具有原子性。
* volatile禁止指令重排。

#### volatile读写的内存语义

* 当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存中
* 当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量。

#### volatile读写内存语义的实现

为了实现volatile内存语义，JMM会限制编译器和处理器重排序

使用内存屏障来实现。实现的效果如下：

* volatile写之前的操作不会被编译器重排序到volatile写之后
* volatile读之后的操作不会被编译器重排序到volatile读之前
* 当第一个是volatile写，第二个是volatile读时，不能重排序

为了实现这些效果和内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。

* 在每个volatile写前面插入storestore屏障，保证在volatile写之前，其前面的所有普通写操作已经对任意处理器可见了。
* 在每个volatile写后面插入storeLoad屏障，避免volatile写与后面可能有的volatile读、写操作重排序。
* 在每个volatile读后面插入loadLoad屏障，避免volatile读与之后的普通读重排序
* 在每个volatile读后面插入loadStore屏障，避免volatile读与之后的普通写重排序

### 锁的内存语义

#### **两种语义：**

* 当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中
* 当线程获得锁时，JMM会把该线程对应的本地内存置为无效

#### 实现

ReentrantLock锁内存语义的实现：

ReentrantLock的实现依赖于Java同步器框架AbstractQueuedSynchronizer（AQS）。AQS使用一个整型的volatile变量state来维护同步状态，这个volatile变量是ReentrantLock内存语义实现的关键。

ReentrantLock的**公平锁在释放锁**的最后写volatile变量state，在获取锁时首先读这个volatile变量，根据volatile的happend-before规则，释放锁的线程在写volatile变量之前可见的共享变量，在获取锁的线程读取同一个volatile变量之后将立即变得对获取锁的线程可见。

非公平锁在获取锁时使用的是CAS去改变volatile变量state，CAS操作具有volatile读和写的内存语义，编译器不能对CAS与CAS前面和后面的任意内存操作重排序。

#### CAS如何实现

程序会根据当前处理器的类型来决定是否为cmpxchg指令添加lock前缀，如果程序是在多处理器上运行，就为cmpxchg指令加上lock前缀（Lock cmpxchg）。反之，如果程序时在单处理器上运行，就是省略lock前缀。

lock前缀的作用：

* 确保对内存的读-改-写操作原子执行，在执行指令期间会锁住总线，其他处理器无法通过总线访问内存
* 禁止该指令与之前之后的读写指令重排序
* 把缓冲区中的数据刷新到内存中。

第二点和第三点具有内存屏障的效果，足以实现volatile读和volatile写的内存语义。

#### 总结

* 公平锁和非公平锁释放是，最后都要写一个volatile变量state
* 公平锁获取锁时，首先会去读取volatile变量
* 非公平锁获取锁时，首先会使用CAS更新volatile变量，这个操作同时具有volatile读和volatile写的内存语义。

#### concurrent包的实现

通用化的实现模式：

* 首先声明共享变量volatile
* 使用CAS的原子条件更新来实现线程之间的同步
* 配合以volatile的低些和CAS具有的volatile读写的内存语义来实现线程间的通信

### final域的内存语义

#### 规则

写final域的重排序规则：在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。

读final域的重排序规则：初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。

final域为引用类型时：在构造函数内对一个final引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。

#### 效果

写final域的规则保证：在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了。

读final域的规则保证：在读一个对象的final域之前，一定会先读包含这个final域的对象的引用。

如果想要获得final域的读写效果，还需要一个保证：在构造函数内部，不能让这个被构造对象的引用为其他线程所见，也就是对象引用不能在构造函数中逸出。

final语义可以为java程序员提供初始化安全保证：只要对象是正确构造的（被构造对象的引用在构造函数中没有逸出），那么不需要使用同步就可以保证任意线程都能看到这个final域在构造函数中被初始化之后的值。

### happens-before

#### 定义：

* 对于程序员：如果一个操作hb另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前
* 对于编译器和处理器：两个操作之间存在hb关系，并不意味着java平台的具体实现必须按照hb关系指定的顺序来执行，如果重排序之后的执行顺序，与按照hb关系来执行的结果一样，那么这种重排序并不非法。

#### 规则：

* 程序顺序规则：一个线程中的每个操作，hb于该线程中的热议后续操作
* 监视器锁规则：对一个锁的解锁，hb于随后对这个锁的加锁
* volatile变量规则：对一个volatile域的写，hb于任意后续对这个volatile域的读
* 传递性：如果a hb b，b hb c ，那么 a hb c
* start规则：如果线程A执行ThreadB.start 启动B线程，那么A线程 ThreadB.start操作hb于线程B中的任何操作
* join规则：如果线程A执行操作ThreadB.join 并成功返回，那么线程B中的任意操作hb于线程A从ThreadB.join操作成功返回

### Double Checking和延迟初始化

#### 问题根源

```java
instance = new Singleton();
```

这一行代码的jvm指令可以分解为一下三行：

```java
memory = allocate();	//1:分配对象内存
ctorInstance(memory);	//2:初始化对象
instance = memory;		//3:设置instance指向刚分配的内存地址
```

这三行指令的2和3可能会发生重排序，如果先将instance指向了一片地址，但是没有将地址空间所代码的对象初始化，那么double-checking的时候可能会因为变量未初始化而发生错误。

有两种解决方案：（一个是禁止重排序，一个是上锁）

1. 不允许2,3重排序
2. 允许2,3重排序，但不允许其他线程“看到”这个重排序。

#### 基于volatile解决方案

这个方案是通过禁止2,3重排序来实现的

#### 基于静态内部类

在执行类的初始化期间，jvm会去获取一个锁，这个锁可以同步多个线程对同一个类的初始化。

```java
public class InstanceFactory{
    private static class InstanceHolder{
        public static Instance instance = new Instance();
    }
    public static Instance getInstance(){
        return InstanceHolder.instance;		// 这里将导致InstanceHolder的初始化
    }
}
```

## java线程

现代操作系统调度的最小单元是线程，也叫轻量级进程，在一个进程里可以创建多个线程，这些线程都拥有自己的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。

### 为什么要使用多线程：

* 物尽其用，更好的利用更多的CPU核心
* 让程序有更快的相应时间。

### 线程优先级

现代操作系统基本采用时分的形式调度运行线程，操作系统会分出一个个时间片，线程会分配到若干时间片，当线程的时间片用完了就会发生线程调度，并等待着下次分配。线程分配到的时间片多少也就决定了线程使用处理器资源的多少，而线程优先级就是决定线程需要多或者少分配一些处理器资源的线程属性。

频繁阻塞（休眠或者IO操作）的线程需要设置较高的优先级，而偏重计算的线程则设置较低的优先级，确保CPU不会被独占。

### java线程状态

### 守护线程（Daemon线程）

Daemon线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。这意味着，当一个jvm中不存在非Daemon线程的时候，jvm将会退出，可以通过调用Thread.setDaemon(true)将线程设置为Daemon线程。

守护线程退出，finally块中的代码并不会执行

### 线程的实现

实现线程主要有三种方式：

1. 使用内核线程实现（1:1实现）
2. 使用用户线程实现（1：N实现）
3. 使用用户线程加轻量级进程混合实现（N：M实现）

#### 内核线程实现

一比一实现，内核线程就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。

程序一般不会直接使用内核线程，而是使用内核线程的一种高级接口——轻量级进程（Light Weight Process，LWP），这就是我们通常意义上的线程。

局限性：

* 基于内核实现，线程的操作都需要进行系统调用，而系统调用代价高。
* 每个LWP都需要一个内核线程支持，因此要消耗内核资源，因此一个系统支持的LWP是有限的。

#### 用户线程实现

广义上来讲，一个线程只要不是内核线程，都可以认为是用户线程的一种，从这个定义上来看，轻量级进程也是用户线程，但是轻量级进程始终是建立在内核之上，许多操作都需要进行系统调用，因此效率会受限制，不具备通常意义上用户线程的优点。

狭义上来讲，用户线程指完全建立在用户空间的线程库上，系统内核不能感知到用户线程的存在以及如何实现的。用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。如果程序实现得当，这种线程不需要切换到内核态，因此操作可以是可以非常快速并且低消耗的，也能够支持规模更大的线程数量，部分高性能数据库中的多线程就是用户线程实现的。

优势：不需要系统内核支援。

劣势：没有系统内核支援，实现很复杂

#### 混合实现

内核线程和用户线程一起使用的实现方式，在这种混合实现下，及存在用户线线程，也存在轻量级进程，用户线程还是完全建立在用户空间，因此用户线程的创建，切换，析构等操作依然廉价，并且可以支持大规模的用户线程并发。

而操作系统支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能以及处理器映射，同时用户线程的系统调用要通过轻量级进程来完成，这大大降低了整个进程被全阻塞的风险。

#### java线程的实现

Hotspot虚拟机每个java线程都是直接映射到一个操作系统原生线程来实现的，而且中间没有额外的间接结构，所以HotSpot不会去干涉线程调度，全是操作系统决定的。





