## IO模型



## IO多路复用

### BIO有什么缺点？

BIO中的B表示的是阻塞的意思，使用ServerSocket绑定端口之后，服务端会监听该端口，等待accept事件，accept函数会阻塞当前主线程。当我们收到accept事件时，程序就会拿到一个客户端与服务端连接的socket，针对这个socket服务端可以进行读写，但是socket的读写方法都是会阻塞当前线程的，一般我们会使用多线程的方式进行c/s交互，但是这种解决方式当客户端数量增多的时候，服务端的线程数量就会变得很多，服务端的负载变大，线程的上下文切换也会大大增加服务端的负载。

### 针对C10K这样的需求，NIO靠什么解决的问题？

BIO之所以处理不了C10k这样的需求，就是因为BIO是阻塞操作的。因为NIO API具有非阻塞特性，就可以使用一个线程去检查n个socket。NIO的包为我们提供了一个selector选择器，我们需要把要检查的socket注册到selector中，然后主线程阻塞在selector的select方法里，当选择器发某个socket就绪了，就会唤醒主线程，主线程可以通过selector获取到就绪的socket，之后进行相应的处理。

selector其实是Java底层使用native api进行包装的，在底层是jvm虚拟机去使用系统调用实现的。

### 多路复用操作系统函数select()工作原理？

我们每次调用select函数的时候，都会涉及到**用户态和内核态的切换**，同时需要传递需要检查的socket集合，其实就是需要检查的文件描述符(fd)。

select函数被调用之后，内核首先会按照fd集合去检查内存中的socket套接字状态，这个检查的复杂度是O(N)的，然后检查完一遍之后，如果有就绪的socket，就直接返回，不会阻塞当前的线程，否则就说明当前文件描述符集合没有就绪状态的socket，这时候就需要阻塞当前调用的线程，直到某个socket有数据之后，才会唤起线程。

select去监听文件描述符的时候，文件描述符的数量是有限制的，默认最大可以监听1024个。

### 多路复用操作系统函数select()默认监听socket数量为什么是1024？

因为fd_set(select函数的参数之一)这个参数的结构是一个bitmap位图结构，这个结构就是一个长的二进制数，这个bitmap的默认长度是1024个bit。

默认值给1024，出于性能考虑。因为当内核监听到某个socket就绪之后，就会对位图进行置位，表示socket已经就绪了，但是用户的线程并不知道到底哪个fd就绪了，只知道就绪的个数，因此还需要一遍遍历去寻找就绪的fd。因此如果bitmap太长，程序的运行时间将会增加，也不利于用户态到内核态的参数传递（数据拷贝），系统调用速度会降低。

### 多路复用操作系统函数select()第一遍O(N)未发现就绪socket，后续在某个socket就绪以后，select如何感知？是不停轮询吗？

这个和操作系统的进程调度以及中断有关系。

select函数第一遍轮序如果没有发现就绪的socket，就会把当前进程保留给需要检查的socket等待队列中。socket的结构有三块核心区域，分别是读缓存、写缓存和等待队列。select函数把当前线程放到每一个需要检查的socket等待队列中之后，会把当前进程从工作队列中移除，当前进程被挂起，select函数不在会被运行。

如果客户端往服务端发送数据，数据从网线到网卡，网卡在到DMA硬件的这种方式将数据写入到内存中，着整个过程CPU是不参与的，当整个过程完成之后，就会触发网络数据传输完毕的中断程序，这个中断程序会把CPU正在运行的程序停掉，CPU就会处理中断程序的逻辑。

中断程序的逻辑大概为根据内存中的数据包，分析出数据包是那个socket的数据，因为数据传输使用的是tcp/ip协议，保证数据包是有端口号的，根据端口号找到socket实例，找到之后，把数据导入socket的读缓冲区，导入完成只有就会检查socket的等待队列是否有等待者，如果有的话，就把等待者移到工作队列中，中断程序到这一步就执行完了。

进程回到工作队列中，有机会获取CPU时间片，此时select函数检查就会发现已经有就绪的fd，然后将此fd打上标记，返回。

### 多路复用操作系统函数poll和select主要区别？

最大的区别就是传入的参数不同了。

select使用的bitmap结构，poll使用的是数组结构（也有说是链表），表示需要检查的socket集合，主要是为了解决select bitmap长度是1024这个问题，poll使用数组没有这个限制，就可以让线程监听超过1024个socket。

### 为什么会有epoll这个技术，他产生的背景是什么？

主要是为了解决select和poll的缺陷。

select和poll的缺陷：

* select和poll需要进程传入需要监听的文件描述符集合，牵扯到用户态内核态转换，参数传递，比较耗费性能。但是每次可能只有几个fd就绪，select和poll函数在内核层面不会保留任何数据信息，所以说每次调用都需要数据拷贝。
* select和poll返回值是一个int，只能代表有多少fd就绪了，没办法表示那个socket就绪，需要轮询使用新的系统调用去判断那个socket就绪，这时就走了弯路。

### epoll函数的工作原理是什么？

epoll就是为了解决以上两种缺陷。这样就需要epoll函数在内核空间内，对应一个数据结构去存储数据，这个数据结构其实就是一个eventpoll对象，eventpoll对象可以通过epoll_create去创建，创建完成之后，系统返回一个eventpoll对象id，相当于我们在内核中开辟了一小块空间，我们也知道这块空间的位置。

eventpoll的结构有两块重要的区域，一块是存放需要监听的socket文件描述符列表，另一块是就绪列表。还有一个等待队列

epoll_ctl系统调用可以通过epollid增删改查内核空间上的eventpoll对象的注册的fd

epoll_wait通过epollid监听对应eventpoll实例上注册的fd，默认阻塞线程

### eventpoll对象的就绪列表数据是如何维护的？

这个过程和select函数判断就绪状态的socket过程十分类似。

首先我们会使用epoll_ctl函数讲一个fd添加到eventpoll实例中，内核程序会将当前eventpoll对象追加到socket等待队列当中，然后等待中断程序执行完毕，但是中断程序发现等待队列内等待的不是一个进程，是一个eventpoll对象的引用，然后就根据eventpoll引用，将当前的socket引用追加到eventpoll的就链表的末尾。

eventpoll还有一个等待队列，等待队列中存放的是调用epoll_wait的进程，当中断程序将socket追加到链表之后，就会检查eventpoll等待队列中的进程，将进程放入工作队列中，进程就可以继续执行，然后epoll_wait函数被执行，返回。

### epoll是如何实现获取就绪的socketfd的？

调用epoll_wait会传入一个数组指针，epoll_wait正常返回之前，会把就绪的socket事件、信息拷贝到这个数组里

### epoll_wait 是否可以设置为非阻塞的？

可以。默认是非阻塞的，有参数可以设置阻塞的时间长短，如果设置为0，表示非阻塞，调用之后立即返回

### eventpoll对象中存放需要检查的socket信息是采用什么数据结构？为什么？

采用的是红黑树的数据结构。因为eventpoll中的socket经常有增删改查的需求，这个需求红黑树一定很合适，它能保持一种相对稳定的查找效率，复杂的应该是O(LogN)。

hashmap原理、扩容、hashmap怎么缩容（红黑树退化链表）

hashtable、hashmap、synchronizedmap、concurrentmap（详细说明）

**代理模式（静态、动态、cglib缺点）**

快排归并的区别，时间复杂度的推导

从输入url到显示页面的过程（dns、tcp、http细节）

dns解析出错，怎么排查错误

tcp、udp

http、https理解、秘钥交换过程

SQL语句口述

mysql索引

创建索引的原则(区分度，是否是查询时使用，插入性能和读取性能权衡，减少回表) 