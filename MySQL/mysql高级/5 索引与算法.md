# 索引和算法

InnoDB存储引擎支持以下几种常见的索引：

* B+树索引
* 全文索引
* 哈希索引（自适应的Hash索引，Innodb的特性之一，人们不能干预一张表是否有hash索引）

B+树索引并不能找到一个给定键值的具体行，B+树索引只能找到被查找数据行所在的页，，然后数据库将页读入内存，再在内存中查找。

## B+树

B+树是由B树和索引顺序访问方法演化而来的。B+树是为磁盘或其他直接存取辅助设备设计的一种平衡查找树。在B+树中，所有记录结点都是按键值的大小顺序存放在同一叶子结点上，由叶子结点指针进行连接。

### B+树的插入

考虑到索引节点和叶子结点存储的不同情况，B+树的插入操作有三种情况，对应三种不同的算法：

* 叶子结点没满，索引结点没满，直接将记录插入到叶子结点中
* 叶子结点满了，索引结点没满
  * 拆分叶子结点
  * 将中间的结点放入到索引结点中
  * 小于中间结点的记录放在左边
  * 大于或等于中间结点记录放到右边
* 叶子结点满了，索引结点没满
  * 拆分叶子结点
  * 小于中间节点的记录放在左边
  * 大于中间记录的结点放在右边
  * 拆分索引结点
  * 大于中间结点的记录放在左边
  * 大于等于中间结点的记录的放在右边
  * 中间结点放入上一层的索引页中

但是因为B+树主要用于磁盘，页的拆分意味着磁盘的操作，所以应该尽可能的减少页的拆分操作。因此，B+数同样提供了类似于二叉平衡树的旋转功能。

旋转发生在叶子结点已经满了，但是其左右兄弟结点没有满的情况下。这时B+树不会急于去做页拆分操作，而是将记录移到所在页的兄弟节点上。在通常情况下，左兄弟会被首先检查用来做旋转操作。

### B+树的删除操作

B+树使用填充因子来控制树的删除变化，50%是填充因子可设的最小值。B+树的删除操作根据删除完之后叶子节点和索引结点填充度的不同分为三种情况：

* 叶子结点大于填充因子，中间结点大于填充因子，直接将记录从叶子结点删除，如果该结点还是Index Page的节点，用该节点的右节点代替。
* 叶子结点小于填充因子，中间结点大于填充因子，合并叶子结点和他的兄弟结点，同时更新Index Page
* 叶子结点小于填充因子，中间结点小于填充因子，
  * 合并叶子结点和他的兄弟结点
  * 更新Index Page
  * 合并Index Page和他的兄弟结点

## B+树索引

B+树索引的本质就是B+树在数据库中的实现。但是由于B+树索引在数据库中有一个特点高扇出性，因此B+树的高度一般都在2-4层，这也就是说在查找某一键值的行记录时最多只需要2到4次IO

数据库中的B+树索引可以分为：聚集索引和辅助索引，他们都是B+树，高度平衡的。聚集索引和辅助索引不同的是，叶子结点存放的是否是一整行的信息。

### 聚簇索引

InnoDb存储引擎是索引组织表，即表中数据按照主键顺序存放。而聚集索引就是按照每张表的主键构造一颗B+树，同时叶子结点中存放的即为整张表的行记录数据，也将聚集索引的叶子结点称为数据页。和B+树数据结构一样，每个数据页都通过一个双向链表来进行连接。

由于实际的数据页只能按照一颗B+树进行排序，因此每张表只能拥有一个聚集索引。在多数情况下，查询优化器倾向于采用聚集索引：

* 因为聚集索引能够在B+树索引的叶子节点上直接找到数据。
* 此外，由于定义了数据的逻辑顺序，聚集索引能够特别快地访问针对范围值的查询。

聚集索引的存储并不是物理上连续的，而是逻辑上连续的，有两点可以体现：

* 页通过双向链表连接，页按照主键的顺序排序
* 每个页中的记录也是通过双向链表进行维护的，物理存储上可以同样不按照主键存储

聚集索引的另一个好处是，它对于主键的排序查找和范围查找速度非常快。

### 辅助索引

叶子结点不包含记录的全部数据，叶子结点除了包含键值以外，每个叶子结点中的索引行中还包含了一个书签。该书签用来告诉InnoDB存储引擎哪里可以找到和索引相对应的行数据。由于InnoDB存储引擎表是索引组织表，因此InnoDB存储引擎的辅助索引的书签就是相应行数据的聚集索引键。

一张表中可以有多个辅助索引。当通过辅助索引来寻找数据时，InnoDB存储引擎会遍历辅助索引并通过叶级别的指针获取指向主键索引的主键，然后再通过主键索引来找到一个完整的行记录。

### B+树索引的分裂

之前介绍的B+树结构的分裂并没有涉及并发，而并发场景下的分裂才是B+树索引实现最为困难的部分。

B+树索引页的分裂并不总是从页的中间记录开始，这样可能会导致页空间的浪费。因为插入是根据自增顺序进行的，如果插入数据后从中间分裂，那么分裂后的左边页不会再有数据插入，从而导致空间的浪费。

若数据的插入是随机的，那么取页的中间记录作为分裂点的记录；

若往同一方向插入数据，那么取插入页的最后一个记录分裂。

### B+树索引的管理

#### 1 索引管理

索引的创建和删除可以通过两种方法，一种是alter table，另一种是create/drop index。

用户可以对整个列的数据进行索引，也可以只索引一个列的开头部分数据。

#### 2 Fast Index Creation

在MySQL5.5版本之前存在一个问题就是MySQL数据库对于索引的添加或者删除这类DDL操作，MySQL数据库的操作过程为：

* 首先创建一张新的临时表，表结构为通过命令Alter table新定义的结构
* 然后把原表中数据导入到临时表
* 接着删除原表
* 最后把临时表重命名为原来的表名

如果使用这种方式，用户对一张大表进行索引的添加和删除操作，会需要很长时间。更致命的是，如果有大量事务需要访问正在被修改的表，这意味着数据库服务不可用。

后来InnoDB引擎开始支持一种称为Fast Index Creation（FIC 快速索引创建）的索引创建方式。

对于辅助索引的创建，InnoDB存储引擎会对创建索引的表上加上一个S（共享读锁）锁。在创建的过程中，不需要重建表。

删除辅助索引的操作就更简单：

* InnoDB存储引擎只需要更新内部视图，并将辅助索引的空间标记为可用，同时删除MySQL数据库内部视图上对该表的索引定义即可

但是由于FIC在索引的创建过程中对表加上了S锁，因此在创建的过程中只能对该表进行读操作，若有大量的事务需要对目标表进行写操作，那么数据库服务同样不可用。此外，FIC方式只限定于辅助索引，对于主键的创建和删除同样需要重建一张表。

#### 3 Online Schema Change

Online Schema Change（在线架构改变，OSC）是由FaceBook实现的一种在线执行DDL的方式。所谓的在线指的是在事务的创建过程中，可以读写事务对表进行操作，这提高了原有MySQL数据库在DDL操作时的并发性。

#### 4 Online DDL

虽然FIC可以让Innodb避免创建临时表，从而提高索引创建的效率。但是索引创建的时候会阻塞表上的DML操作。OSC虽然解决了上述的部分问题，但是还是有很大的局限性。

MySQL后来的版本开始支持Online DDL (在线数据定义)操作，允许辅助索引创建的同时，还允许其他像Insert、update、delete这类DML操作。

此外不仅是辅助索引，下面这几类DDL操作都可以通过“在线”的方式进行操作：

* 辅助索引的创建和删除
* 改变自增长值
* 添加或删除外键约束
* 列的重命名

通过新的Alter table语法，用户可以选择索引的创建方式：

```sql
alter table tbl_name
| add {index|key} [index_name]
[index_type] (index_col_name,....) [index_option] ...
algorithm [=] {default|inplace|copy}
lock [=] {default|none|shared|exclusive}
```

algorithm指定了创建或删除索引的算法：

* copy表示按照创建临时表的方式
* inplace表示索引的创建和删除不需要创建临时表
* default表示根据参数old_alter_table来判断是通过inplace还是copy

lock部分为索引创建或删除时对表添加锁的情况，可有的选择为：

* none，对目标表不加任何锁，事务仍然可以读写操作，不会受到阻塞，因此这种模式并发度最大
* share，加读锁，并发的读事务仍然可以，但是写事务不行
* exclusive，加互斥锁，读写事务都不能进行，因此会阻塞所有线程
* default，首先判断是否可以使用none，然后判断是否可以使用share，最后判断是否可以使用exclusive

Innodb实现Online DDL的原理是在执行创建或删除操作的同时，将Insert，update，delete这类DML操作日志写入到一个缓存中，等待完成索引创建后再将重做应用到表上，以此达到数据的一致性。

需要注意的是，由于Online DDL在创建索引完成后再通过重做日志达到数据库的最终一致性，这意味着在索引的创建过程中，SQL优化器不会选择正在创建中的索引。

## Cardinality值

并不是所有查询条件中出现的列都需要添加索引。一般的经验是：在访问表中很少一部分时使用B+树索引才有意义。如果某个字段的取值范围很小，称为低选择性，如果取值范围很大，称为高选择性，高选择性的字段使用B+树索引是最合适的。

可以通过show index结果中的列Cardinality来观察字段是否具有高选择性。

Cardinality的值非常关键，他表示索引中不重复记录数量的预估值，需要注意，它是一个预估值，不是一个准确值。在实际应用中，Cardinality/n_rows_in_table应尽可能的接近于1.如果非常小，那么就需要考虑这个索引是否真的需要。

### Innodb中Cardinality的统计

Cardinality的统计是放在存储引擎层的，因为每个引擎的B+树的实现方式各不相同。

实际情况中，索引的更新情况是非常频繁的，如果每次索引在发生操作的时候就对Cardinality进行一次统计，那么将会给数据库带来很大的负担。另外需要考虑的是，如果一张表很大，那么统计Cardinality的时间也会很长。因此数据库对于Cardinality的统计都是通过采样的方法来完成的。

Cardinality的更新发生在两个操作中：insert和update，Innodb更新Cardinality的策略为：

* 表中1/16的数据已经发生改变
* stat_modified_counter>2000 000 000

默认InnoDB存储引擎对8个叶子结点进行采用，采样过程如下：

* 取得B+树索引中叶子结点的数量，即为A
* 随机取得8个叶子结点，统计每个页中不同记录的个数，记为P1，P2.。。。
* 根据采样信息给出Cardinality的预估值

每次得到的Cardinality的值可能是不同的。

## B+树索引的使用

### 联合索引

联合索引是指对表上的多个列进行索引。

### 会走联合索引的情况

当where条件是a，b，c三个时，一下情况会走联合索引：

* 查询条件是a，b，c时，无论是什么顺序，由于优化器优化，都会走联合索引
* 查询条件是a，b时，会走联合索引
* 查询条件是a，c时，也会走联合索引，但是Extra信息里面多了一行：**Using index condition**，意思是先条件过滤索引，过滤完索引后找到所有符合索引条件的数据行，随后用where子句中的其他条件去过滤这些行，这种情况只有a条件用到联合索引，c条件回表到聚集索引过滤。
* 查询条件是b，c时，不会走联合索引
* 查询条件是a时，会走联合索引
* 查询条件是b时，不会走联合索引
* 查询条件是c时，不会走联合索引；

总结：

联合索引符合最左匹配原则，按照索引建立的顺序，一个查询可以只使用索引中的一部分，但是只能是最左侧部分。但是最左前缀匹配和where后面的顺序没有关系，优化器会优化可以使用最左前缀匹配的查询

另外，where a = ？and c = ？也会走联合索引，但是只有a条件命中，c条件不走联合索引。

还有，需要避免索引失效的情况，如：like %XXX，或者条件中使用函数等。

### 覆盖索引

InnoDB支持覆盖索引，即从辅助索引中就可以得到查询的记录，而不需要查询聚集索引中的记录。

使用覆盖索引的一个好处是 辅助索引不包含整行记录信息，故其大小远远小于聚集索引，因此可以减少IO操作

覆盖索引的另一个好处是对于某些统计问题而言的，因为辅助索引远小于聚集索引，选择辅助索引可以减少IO操作，故优化器的选择为使用辅助索引解决统计问题（count）

当查询条件是联合索引的第二个key，同时是统计操作，并且是覆盖索引的，优化器会选择辅助索引

### 优化器选择不使用索引的情况

这种情况多发生于范围查找，JOIN连接操作等情况。

当用户需要的是所有信息，但是查询条件的索引不能覆盖，这时如果使用辅助索引，还需要一次随机访问才能查询到所有的信息，这个还不如直接按照聚簇索引顺序扫描一遍呢。

### 索引提示

MySQL数据库支持索引提示，显示地告诉优化器使用那个索引。可能有以下两种情况需要使用索引提示：

* MySQL数据库优化器错误地选择了某个索引，导致SQL语句运行的很慢
* 某SQL语句可以选择的索引非常多，这时优化器选择执行计划的时间开销可能会大于SQL语句本身

使用force index（index_name）来强制SQL语句使用某一个索引

### Multi-Range Read优化

目的是为了减少磁盘的随机访问，并将随机访问转化为较为顺序的数据访问。

MRR优化有以下几个好处：

* MRR使数据访问变得较为顺序。在查询辅助索引时，首先根据查到的结果按照主键进行排序，并按照主键排序的顺序进行书签查找。
* 减少缓冲池中页被替换的次数
* 批量处理对键值的查询操作

MRR对于**范围查询和JOIN查询操作**的工作方式如下：

* 将查询到的辅助索引键值存放于一个缓存中，这时的缓存中的数据是根据辅助索引键值排序的
* 将缓存中的键值根据RowID进行排序
* 根据RowID的排序顺序来访问实际的数据文件

此外，Mulit-Range Read还可以将某些范围查询，拆分为键值对，一次来进行批量的数据查询，这样做的好处是可以在拆分的过程中，直接过滤一些不符合查询条件的数据。

### Index Condition Pushdown（ICP）优化

使用（索引下沉）优化之后，MySQL会在去出索引的同时，判断是否可以进行where条件的过滤，也就是将where的部分过滤操作放在了存储引擎层。

## 哈希算法

### InnoDB中的哈希算法

InnoDB使用哈希算法来对字典进行查找，其中冲突机制采用链表方式，哈希函数采用除法散列方式。

### 自适应hash索引

自适应hash索引是数据库自己创建的，DBA无法干预，自适应哈希索引经过哈希函数映射到一个哈希表中，因此对于字典类型的查找非常迅速，但是对于范围查找就无能为力了。

## 全文检索



## mysql索引失效的场景

总结：LOL ，+-*/，  not、 null，no method，no convert我就是我，不一样的版本，不一样的我

1. like，最左前缀原则，开头以%开头的时候

2. or，前后都是索引，失效，只要有一个不是索引就会失效

3. left，联合查询的最左前缀原则

4. 当索引字段计算在加减乘除中，索引必然失效——select from table where age-1=10。这种情况，数据库需要全表扫描出所有的Id字段值，然后对其进行计算，计算之后再与参数值进行比较。如果每次执行都经历上述步骤，性能损耗很大。

   可以优化的方式是：现在内存中进行计算好预期的值，或者在SQL语句条件的右侧进行参数值的计算。

5. not 非！=，is not 取非结果集就会导致索引失效

6. is null，is not null，允许索引值为null，b+只处理不为null，不对null进行创建。创建字段的时候最好不要允许字段为null，最好设置一个默认值

7. no method 当索引列使用到mysql内置函数的时候，会导致索引失效

8. no convert 当使用varchar和int做对比的时候，mysql会自动将int转为varchar，使用内置的函数convert，因此就导致了索引失效

9. select * from table where a > 3 a是一个辅助索引，在不同的版本中索引的使用情况是不同的。根本原因是select * 查询所有的信息，需要聚簇索引。

   因为MySQL5.6版本开始支持Multi-Range Read优化，MRR优化是为了减少磁盘的随机访问，并且将随机访问变为顺序的数据访问。

   MRR优化的好处：

   * 使数据访问变得较为顺序，在查询辅助索引的时候，首先根据得到的结果，按照主键进行排序，并按照主键排序的顺序进行书签查找
   * 减少缓冲池中页被替换的次数
   * 批量处理对键值的查询操作




