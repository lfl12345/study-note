# MySQL锁

根据加锁的范围，MySQL里面的锁大致可以分为全局锁、表级锁和行锁三类。

## 全局锁

全局锁就是对整个数据库实例加锁，MySQL提供了一个加全局读锁的方法：

```sql
flush table with read lock(FTWRL)
```

如果我们需要让整个库处于**只读状态**的时候，就可以使用这个命令，之后其他线程的一下语句会被阻塞：

* 数据更新语句（增删改）DML
* 数据定义语句（建表，修改表结构等）DDL
* 更新类事务的提交语句

如果要释放全局锁，需要执行以下命令

```sql
unlock tables
```

如果会话断开，全局锁会自动释放。

全局锁的典型使用场景是，做全库逻辑备份。也就是把整库每张表都select出来存成文本。这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据和预期的不一样。

### 全局锁的缺点

加上全局锁，意味着整个数据库都是只读状态。那么如果数据库里有很多数据，备份就会花费很多时间，关键是备份期间，业务只能读数据，而不能更新数据，这样会造成业务停止。

### 备份数据库的时候，避免使用全局锁的方式

如果数据库的引擎支持的事务支持可重复读隔离级别，那么在备份数据库之前先开启事务，会先创建Read View，然后整个事务执行期间都在使用这个Read View，而且由于MVCC的支持，备份期间业务依然可以对数据进行更新操作。

因为在可重复读隔离级别下，即使其他事务更新了表的数据，也不会影响备份数据库时的Read View，这就是事务的隔离性，这样备份期间备份的数据一直是在开启事务时的数据。

备份数据库的工具mysqldump，在使用mysqldump时加上`-single-transaction`参数的时候，就会在备份数据库之前先开启事务。这种方法只适用于支持可重复读隔离级别的事务的存储引擎。

Innodb存储引擎默认的事务隔离级别是可重复读，因此可以采用这种方式来备份数据库。

## 表级锁

MySQL中的表级锁有一下几种：

* 表锁
* 元数据锁（MDL）
* 意向锁
* AUTO-INC锁

### 表锁

如果我们想对一张表加锁，可以使用一下方式：

```sql
# 表级别的共享锁，也就是读锁
lock tables table_name read;
# 表级别的独占锁，也就是写锁
lock tables table_name write;
```

需要注意的是，表锁除了可以限制其他线程的读写以外，也会限制本线程接下来的读写操作。

也就是说如果本线程对学生表加了共享表锁，那么本线程 接下来如果要对学生表执行写操作的语句，是会被阻塞的，当然其他线程对学生表进行写操作时也会被阻塞，直到本线程将锁释放。

要释放表锁，可以使用下面的命令，他会释放当前会话所有的表锁。

```sql
unlock tables
```

另外当会话退出，也会释放所有的表锁。

不过尽量避免在使用Innodb引擎的表使用表锁，因为表锁的颗粒度太大，会影响并发性能，Innodb厉害的地方就在于实现了粒度更细的行级锁。

### 元数据锁

我们不需要显示的使用MDL，因为当我们对数据库表进行操作时，会自动给这个表加上MDL：

* 对一张表进行CRUD操作时，加的是MDL读锁
* 对一张表做结构变更操作的时候，加的是MDL写锁。

MDL是为了保证当前用户对表执行CRUD操作时，防止其他线程对这个表结构做了变更。

当有线程在执行select语句（加MDL读锁）的期间，如果有其他线程要更改该表的结构（申请MDL写锁），那么将会被阻塞，直到执行完select语句（释放MDL读锁）。

反之，当有线程对表结构进行变更（加MDL写锁）的期间，如果有其他线程执行了CRUD操作（申请MDL读锁），那么就会被阻塞，直到表结构变更完成（释放MDL写锁）。

#### MDL不需要显示调用，那锁是什么时候释放的？

MDL锁在事务提交之后才会释放，这就意味着在事务执行期间，MDL是一直持有的。

那如果数据库有一个长事务，那在对表结构做变更操作的时候，可能会发生意向不到的事情，例如：

* 首先，线程A先启动了事务，但是一直没有提交，然后执行一条select语句，此时就先对该表加上MDL读锁；
* 然后，线程B也执行了同样的select语句，此时并不会阻塞，因为读读并不冲突。
* 接着，线程C修改了表字段，此时由于线程A的事务并没有提交，也就是MDL读锁还在占用这，这时线程C就无法申请到MDL写锁，就会被阻塞。

如果在线程C阻塞后，后续有对该表的select语句，就都会被阻塞，如果此时有大量该表的select语句的请求来到，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了。

#### 为什么后续申请读锁的线程会被阻塞？

因为申请MDL锁的操作会形成一个队列，队列中写锁获取优先级高于读锁，一旦出现MDL写锁等待，会阻塞后续该表的所有CRUD操作。

所以为了能安全的对表结构进行变更，在对表结构变更前，先要看看数据库中的长事务，是否有事务已经对表加上了MDL读锁，如果可以考虑kill掉这个长事务，然后再做表结构的变更。

### 意向锁

* 在使用Innodb引擎的表里对某些记录加上 共享锁 之前，需要先在表级别加上一个 意向共享锁；
* 在使用Innodb引擎的表里对某些记录加上 独占锁 之前，需要先在表级别加上一个 意向独占锁；

也就是，当执行插入、更新、删除操作，需要先对表加上 意向独占锁， 然后对该记录加独占锁。

而普通的select是不会加行级锁的，普通的select语句是利用MVCC实现一致性读，是无锁的。	

使用下面的select也是可以对记录加共享锁和独占锁的：

```sql
# 先在表上加上意向共享锁，然后对读取的记录加独占锁
select ... lock in share mode;
# 先在表上加意向独占锁，然后对读取的记录加独占锁
select ... for update;
```

意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（lock tables ... read）和独占表锁（lock tables ... write）发生冲突。

表锁和行锁是满足读读共享、读写互斥、写写互斥的。

如果没有 意向锁 ，那么加独占表锁时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。

如果有了 意向锁 ，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加独占表锁时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录。

所以意向锁的目的是为了快速判断表里是否有记录被加锁。

### AUTO-INC锁

在为某个字段声明AUTO_INCREMENT属性时，之后可以在插入数据时，可以不指定该字段的值，数据库会自动给该字段赋值递增的值，这主要是通过AUTO-INC锁实现的。

AUTO-INC锁是特殊的表锁机制，锁不是在一个事务提交之后才释放，而是在执行完插入语句后就会立即释放。

在插入数据时，会加一个表级别的AUTO-INC锁，然后被AUTO-INCREMENT修饰的字段赋值递增的值，等插入语句执行完后，才会把AUTO-INC锁释放掉。

那么，一个事务在持有AUTO-INC锁的过程中，其他事务如果要向该表插入语句都会被阻塞，从而保证插入数据时，别AUTO_INCREMENT修饰的字段的值是连续递增的。

但是，AUTO-INC锁在对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。

因此MySQL5之后，Innodb存储引擎提供了一种轻量级锁来实现自增。

在插入数据的时候，会为被AUTO_INCREMENT修饰的字段加上轻量级锁，然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放。

Innodb存储引擎提供了Innodb_autoinc_lock_mode的系统变量，是用来控制选择用AUTO_INC锁，还是轻量级锁。

* 当innodb_autoinc_lock_mode = 0，就采用AUTO-INC锁
* 当innodb_autoinc_lock_mode = 2，就采用轻量级锁
* 当innodb_autoinc_lock_mode = 1，这个是默认值，两种锁混合使用，如果能确定插入记录的数量就采用轻量级锁，不确定时就采用AUTO-INC锁。

不过，当innodb_autoinc_lock_mode = 2是性能最高的方式，但是会带来一定的问题。因为并发插入的存在，在每次插入时，自增长的值可能是不连续的，这在有主从复制的场景中是不安全的。

## 行级锁

Innodb引擎是支持行级锁的，而MyISAM引擎并不支持行级锁。

行级锁的类型主要有三类：

* Record Lock，记录锁，也就是仅仅把一条件记录锁上
* Gap lock，间隙锁，锁定一个范围，但是不包含记录本身，
* Next-Key lock：Record lock + Gap lock的组合，锁定一个范围，并且锁定记录本身。

普通的select语句是不会对记录加锁的，如果要在查询时对记录加行锁，可以使用以下两种方式：

```sql
# 对读取的记录加共享锁
select ... lock in share mode;
# 对读取的记录加独占锁
select ... for update;
```



























