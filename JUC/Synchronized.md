# Synchronized

## MarkWord结构

![image-20220429141406274](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220429141406274.png)

**对象的内存布局**

<img src="C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220429141649503.png" alt="image-20220429141649503" style="zoom:50%;" />

**MarkWord**

MarkWord的第一部分用于存储对象自身的运行时数据，例如哈希码，GC分代年龄等。这部分数据在长度为32位和64位的Java虚拟机中会分别占用

**class metadata pointer**

这一部分用于存储对象的类型指针，该指针指向它的类元数据，JVM通过这个指针确定对象是哪个类的实例。该指针的位长度为JVM的一个字大小，即32位的JVM为32位，64位的JVM为64位。

如果应用的对象过多，使用64位的指针将浪费大量内存，统计而言，64位的JVM将会比32位的JVM多消耗百分之五十的内存。所以JVM会默认开启指针压缩，开启之后将占用4字节（不开启占用8字节）。

jvm设置 -XX：+UseCompressedClassPointers开启了类型指针压缩

​			   -XX：+UseCompressedOops开启了普通对象指针压缩

**length**

如果对象是一个数组，那么对象头还需要有额外的空间用于存储数组的长度，这部分数据的长度也随着JVM架构的不同而不同：32位的JVM上，长度为32位；64位JVM则为64位。

64位JVM如果开启+UseCompressedOops选项，该区域长度也将由64位压缩至32位。

## 偏向锁

偏向锁是JDK6中引入的一项锁优化措施，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。

偏向锁会 偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁一直没有被其他的线程获取，则持有偏向锁的线程将用于不需要再进行同步。

### 偏向锁失效

偏向锁不一定一直有效，虚拟机开启偏向锁的启动参数为：XX：+UseBiasedLocking，JDK6之后HotSpot会默认开启偏向锁。但是这个偏向锁的开启是存在延迟的，大概的延迟时间在4秒左右，这个延迟指的是如果一个对象的创建在虚拟机启动后的4秒内，那么这个对象的偏向锁是失效的，也就是偏向标志位为0；如果一个对象的创建在虚拟机启动4秒之后，那么这个对象的偏向锁是有效的，MarkWord中偏向标志位为1。我们可以通过参数-XX:BiasedLockingStartupDelay=0将这个延迟设置为0，但是不建议这样做。

原因：JVM启动时会进行一系列的复杂活动，例如装载配置，系统类初始化等等。在这个过程中会使用大量Synchronized关键字对对象加锁，并且这些锁大多都不是偏向锁。如果加了偏向锁，那么锁撤销升级又要消耗性能。所以为了减少初始化事件，jvm默认延时加载偏向锁，这个延时的时间大概是4s左右，具体时间因机器而异。

**对象头的状态的创建过程**

![image-20220501220318277](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220501220318277.png)

### 偏向撤销

偏向锁撤销的情况：

* 线程通过CAS操作替换Thread ID失败时

* 检查Mark Word对象中的Thread ID不是本线程的ID时，会执行偏向撤销

* 当调用Object类的hashCode方法或者System类的identityHashCode方法后，偏向锁会被撤销。

  因为在java中如果一个对象计算了hashCode，那就应该一直保持该值不变，这个值是强制保持不变的，它通过在对象头总存储计算结果来保证第一次计算过后，再次调用该方法取到的hashCode永远不会发生改变。因此当对象被计算过hashCode之后，它的偏向状态将被撤销，并且在页无法进入偏向状态。

### 偏向锁撤销底层实现

在并发环境中，如果想撤销偏向锁状态，就必须知道被写入Mark Word中的偏向线程的状态以及线程的精确信息。所以此时竞争者会向JVM提交一个STW（stop the Word）的请求，在偏向线程达到safepoint时来获取它的精确状态。但是这个STW不会引起整体的STW。

* 如果偏向线程此时还处于同步代码块中，jvm会将Mark Word的信息转移到偏向线程的栈帧的lock record（displaced Mark Word，偏向锁向轻量级锁升级），
* 如果偏向锁不在同步代码块中，则将偏向状态设置为0并改为无锁状态。

### 批量重偏向

批量重偏向指的是：如果对象虽然被多个线程访问，但是没有竞争，这时偏向了线程T1的对象仍有机会重新偏向T2，重偏向会重置对象的Thread ID。

当撤销偏向锁阈值超过20次后，jvm会觉得自己偏向错了，于是会再给这些对象加锁时重新偏向至新的加锁线程。

批量重偏向并不会将已经升级的轻量级锁或重量级锁对象降级，而是新的偏向对象不再会因为Thread ID不同而被撤销偏向状态

**触发条件：**单次偏向撤销的次数（revocation_count）达到20次，就会进行批量重偏向

**控制参数：**-XX:BiasedLockingBulkRebiasThreshold=20



### 批量撤销

对于批量撤销，正在被线程持有的偏向锁通过safe point比那里所有的java线程栈，将偏向锁升级为轻量级锁，并将未被线程正在持有的偏向锁，直接将锁对象的可偏向状态设置为0，禁用偏向状态。

### epoch

epoch可以理解为一个时间戳或者偏向锁的版本，epoch会存储在可偏向对象的Mark Word中，以及类的class信息中也会保存一个epoch的值。

因为对于明显多线程竞争的场景下使用偏向锁是不合适的，例如生产者-消费者队列。生产者线程获得了偏向锁，消费者线程再去获取锁的时候，就涉及到这个偏向锁的撤销（revoke）操作，而这个撤销操作时比较昂贵的。

但是如果判断那些对象适合偏向锁呢？jvm采用以类为单位的做法，jvm内部为每一个类维护一个偏向锁计数器，这个计数器对这个类的对象的偏向锁撤销操作进行计数。当这个值达到指定的阈值之后，jvm就认为这个类的偏向锁有问题，需要进行重偏向（rebias）。**对所有属于这个类的对象进行重偏向的操作就叫做批量重偏向（bulk rebias）**，jvm之前的做法是对heap进行遍历，后来引入了epoch。当需要bulk rebias时，就对这个类的epoch值加一，以后分配这个类的对象的时候Mark字段 里就是这个epoch值了，同时还要对当前已经获得偏向锁的对象的epoch值加一，但是如果有的线程获取完偏向锁之后离开了同步区域，那么这个对象的epoch不会加一。这样判断这个对象是否获得偏向锁的条件就是：

* Mark Word字段后3位是101，
* thread ID字段和当前线程的id
* epoch字段和当前对象所属类的epoch一样。

如果epoch值不一样，即使thread id一样，这个偏向锁也是无效的，相当于进行了批量重偏向，只是因为线程获取完偏向锁后离开了同步代码。

如果一个类的重偏向计数器继续增加到一个阈值，那么jvm就认为这个类不合适偏向锁了，就要进行批量撤销（bulk revoke）。于是就多了一个判断条件，要查看所属类的字段，看看是否允许对这个类使用偏向锁。

## 轻量级锁

### 工作流程

在进入同步代码块时，如果对象没有被锁定（锁标志位为01），虚拟机会在当前线程的栈帧中开辟一个空间Lock Record（锁记录），用来存储当前Mark Work的拷贝（hashCode信息和分代年龄信息）。被拷贝的Mark Word官方称为displaced Mark Word。

随后使用CAS操作尝试把对象的Mark Work更新为指向Lock Record的指针

* CAS成功，更新标志位为00，并进入同步代码块
* CAS失败，检查Mark Word中的指针是不是已经指向自己
  * 如果已经指向，则获取成功
  * 如果不是，那么代表有轻量级锁的竞争，此时膨胀为重量级锁。

### 轻量级锁是否会自旋？

当轻量级锁使用CAS失败之后并不会进行自旋

## 重量级锁

### 自旋优化

jvm的开发团队研究发现，大多数的应用上共享数据状态只会持续很短一段时间，为了这段时间去挂起和恢复线程并不值得，与其直接挂起，不如让它多等一会儿，但是不放弃处理器的执行时间，如果这个自旋的开销小于一次挂起和唤醒的开销，那么这个自旋操作就是值得的，这就是所谓的自旋锁。但是如果当竞争很激烈的时候，大量的线程处于自旋状态，那么不断地自旋开销将会很大。

#### 自适应自旋

自旋的次数不在是一个固定的值，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态决定的。

如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机会认为这次自旋页很有可能成功，进而允许自旋等待相对更长的时间。

但是如果这个锁很少成功获得锁，那么以后要获得这个锁时将可能 直接省略掉自旋的过程（此时自旋反而会增加Synchronized的开销，所以就没有自旋的必要了）

### ObjectMonitor对象

这个对象可以用来保存Mark Word中的信息，同时也是实现线程互斥同步的核心。

重要属性：

* owner，表示拥有该monitor的线程
* cxq队列：单向链表，所有请求锁的线程首先会被放在这个队列中，cxq是一个临界资源，jvm通过CAS原子指令来讲ObjectWaiter写入队列的头部，cxq队列是一个后进先出的栈（cxq队列中的线程在执行动作时会挣扎一下看看能否获得到锁，并不是直接就挂起）
* entryList队列：双向链表，当cxq队列不为空时，Owner会在unLock时根据不同的策略（QMode），将cxq中的数据移动到entryList中，**并指定entryList列表头部的第一个线程为OnDeck线程。**
* WaitSet队列：因为调用wait方法而被阻塞的线程会放到该队列中。

### 重量级锁的加锁过程

CAS尝试把monitor的owner设置为当前线程：

* 如果成功或者是重入，那么进入同步代码块
* 如果失败，先尝试一下再次获取锁，然后进入自适应自旋N次获取锁。如果最后获取到锁，那么成功进入同步代码块；如果最后还是无法获取锁，将线程封装为ObjectWaiter并使用CAS插入cxq队列头部，挂起线程。

### 重量级锁的解锁过程



## 锁消除和锁粗化

### 锁消除

锁消除是指虚拟机**即时编译器**在运行时检测到某段需要同步的代码块根本不可能存在共享数据竞争而实施的一种对锁进行消除的优化策略。

锁消除的主要判断依据来源于**逃逸分析**，逃逸分析能够确定一个变量不会逃出线程，无法被其他线程访问，那么这个变量的读写就不会有竞争，对这个变量实施的同步措施也就可以安全的消除。

### 锁粗化

如果有一系列的操作都对同一个对象反复加锁和解锁，甚至在一个循环体中，那么即使没有线程竞争，频繁的进行互斥操作也会导致不必要的性能开销。

如果虚拟机探测到这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围粗化（扩展）到整个操作序列的外部





















