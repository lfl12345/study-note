# 类文件结构

## 无关性的基石

虚拟机和字节码是构成平台无关性和语言无关性的基石。

## Class类文件结构

![image-20220125084623328](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220125084623328.png)

Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构只有两种数据类型：无符号数和表。

- **无符号数**表示的是类文件中这个信息所占的字节数，以及这个信息的大小。用u1、u2、u4、u8表示字节数多少。
- **表** 是由多个无符号数或者其他表作为数据项构成的复合数据类型，表的命名以_info结尾。

### 魔数

每个class文件的前四个字节表示的是魔数信息，表示它是否是一个class类型的文件。Java的类文件魔数为 `0xCAFEBABE`。

### 版本

接下来的四个字节存储的是Class文件的版本号，前两个存储的是次版本号，后两个是主版本号。次版本号一般不用。

### 常量池

从第9个字节开始就是常量池的入口，常量池是Class文件中：

- 与其他项目关联最多的的数据类型；
- 占用 Class 文件空间最大的数据项目；
- Class 文件中第一个出现的表类型数据项目。

由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常**量池容量计数值。**这个计数值是从1开始的，第0个常量用来表示“不引用任何一个常量池项目”。

常量池主要存放两大类常量：

* 字面量，比较接近于java语言层面的常量概念，例如文本字符串、被声明为final的常量值等
* 符号引用，用一组符号来描述所引用的目标，属于编译原理方面的概念，包括：
  * 类和接口的全限定名
  * 字段的名称和描述符
  * 方法的名称和描述符

常量池中的每一项都是一个表类型，这个表类型中可能包含：

* tag：表示常量的类型，总共有17种常量类型
* length：常量占用的字节数
* bytes：常量信息（使用字节表示）
* index：指向别的常量的索引，例如可能指向一个utf8类型的常量字符串

### 访问标志

常量池结束之后，紧接着的2个字节表示访问标志（access_flags），这个标志用于识别一些类或者接口层次的访问信息，例如：这个Class是类还是接口，是否定义为public类型。

### 类继承信息

访问标志下来是 类索引（this_class）、父类索引（super_class）、和接口索引集合（interfaces）。

* 类索引 用于确定这个类的全限定类名
* 父类索引 用于确定这个类的父类的全限定类名
* 接口索引集合 用来描述这个类实现了那些接口，如果接口计数字段为0，则没有接口

### 字段表集合

字段表用于描述接口或类中生命的变量。Java语言中的字段包括类级别变量以及实例级别变量。

字段表集合的内容：

* 字段修饰符，用access_flags表示
* 字段简单名称索引，name_index
* 字段或方法的描述符索引，descriptor_index，这两个索引都是对常量池项的引用。
* 属性个数，attributes_counts
* 属性信息表，attributes

> 全限定名：类全名中的"."换为"/"
>
> 简单名称：指没有类型和参数修饰的方法或者字段名称
>
> 描述符：用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。

字段表所包含的固定信息到descriptor_index就全部结束了，不过在descriptor_index之后跟随着一个属性表集合，用于存储一些额外的信息，字段表可以在属性表中附加描述零至多项的额外信息。

字段表集合不会出现从父类或者父接口继承而来的字段，但是会出现原来没有的字段，例如内部类为了保持对外部类的访问，内部会生成外部类的引用字段。

### 方法表集合

方法表集合的内容：

* 访问标志（access_flags）
* 名称索引（name_index）
* 描述符索引（descriptor_index）
* 属性表集合（attributes）

方法中的java代码，经过javac编译器编译成字节码执行之后，存放在方法属性表集合中一个名为"code"的属性里面。

和字段表集合相应地，如果父类方法在子类中没有被重写，方法表集合中就不会出现来自父类的方法信息。但是同样的，用可能会出现由编译器自动添加的方法，例如：类构造器\<clinit>()方法和实例构造器\<init>()方法。

### 属性表集合

Class文件、字段表、方法表都可以携带自己的属性表集合，用来描述某些场景专有的信息。

#### Code属性

Java程序方法体中的代码经过Javac编译之后，最终变为字节码指令存储在Code属性中。并非所有的方法表都有Code属性，接口和抽象方法中就有可能没有。

Code属性表的结构：

* attribute_name_index，指向属性名称的索引，Code属性的名称就是Code。

* max_stack，表示操作数栈的最大深度。
* max_locals，表示了局部变量表所需要的空间，就是变量槽的个数，或者说最大同时存在的临时变量的个数
* code_length，表示代码编译为字节码指令的长度，最大值为2的32次方，但是jvm规定代码字节码指令长度最长为65535.
* code，具体的字节码
* exception_table_length和exception_table，异常表信息集合
* attributes_count和attributes，属性表信息集合
