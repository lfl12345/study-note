# 基础架构——查询语句执行过程

![image-20211206111141326](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20211206111141326.png)

大体上来说MySQL可以分为Server层和存储引擎层两部分。

* Server层包括连接器、查询缓存（MySQL8之后移除了）、分析器、优化器、执行器等，涵盖了MySQL的大多数核心功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这层实现，比如存储过程、触发器、视图等。

* 存储引擎层负责数据的存储和**提取**。存储引擎层的架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认存储引擎。

在创建表的时候可以自己定义存储引擎，不同的存储引擎表数据的存取方式不同，支持的功能也不同。

不同的存储引擎共用一个server层。

## 客户端

### 连接MySQL

MySQL客户端在应用层下面与服务器的主要连接方式有四种：Unix套接字、内存共享、命名管道、TCP/IP套接字。

#### Unix套接字：

在Linux和Unix环境下，可以使用Unix套接字进行MySQL服务器的连接；Unix套接字其实不是一个网络协议，只能在客户端和MySQL服务器在同一台电脑上才可以使用。使用`show variables like 'socket'`查找套接字文件。使用'mysql -uroot -S /tmp/mysql.sock'进行以UNIx套接字方式连接数据库服务器

#### 命名管道和内存共享

在window系统中客户端和MySQL服务器在同一台电脑上，可以使用命名管道和共享内存的方式。命名管道开启：-shared-memory=on/off。共享内存开启：-enable-named-pipe=on/off

#### TCP/IP套接字

在任何系统下都可以使用的方式，也是使用最多的方式。

前面两种方式，因为客户端和服务器在同一台主机上，也就是一台主机的两个应用，所以这也就是进程间的通信方式，而在不同主机上就不一样了，就需要网络中tcp/ip建立。

### mysql通信过程

mysql客户端和服务器的通信底层基于TCPIP，所以必然需要经理tcp的三次握手，但是等待tcp连接建立之后还不能发送sql命令，这只是应用层下层建立了连接，mysql客户端和服务器这种应用层程序还需要进行权限验证才能互相发送消息，这才是客户端和服务器之间的交互。

### mysql客户端和服务端的交互过程

主要分为两部分：握手认证阶段，命令执行阶段。这里的握手认证和tcp的握手认证不一样。

#### 握手认证阶段

握手认证阶段为客户端和服务器建立连接之后进行：

1. 服务器 ->客户端：握手初始化消息
2. 客户端->服务器：登录认证消息
3. 服务器->客户端：认证结果消息

#### 命令执行阶段

客户端认证成功后，会进入命令执行阶段，交互过程如下：

1. 客户端->服务器：执行命令消息
2. 服务器->客户端：命令执行结果

为什么还要进行三次握手？[答案](https://blog.csdn.net/LYue123/article/details/89256577?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link)

为什么是服务端主动给客户端发送认证？

## 连接器

第一步，客户端要先连接到数据库上，这时候接待客户端的就是连接器，连接器负责和客户端建立连接、获取权限、维持和管理连接。连接的命令一般这么写：

```shell
mysql -h$ip -P$port -u$user -p$password
```

连接命令中的mysql是客户端工具，用来和服务器建立连接，在完成经典的TCP握手之后，连接器就要开始认证客户端的身份，这个时候就要用到用户名和密码。

* 如果用户名和密码不对，就会收到没有权限的错误，然后客户端程序结束执行
* 如果用户名密码认证通过，连接器会到权限表里面查询用户所拥有的的权限，**之后这个连接里面的权限判断逻辑都将依赖与此时读到的权限**。这也就意味着，一个用户成功建立连接后，即使使用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建连接才会使用新的权限设置。

客户端如果太长时间没动静，连接器就会自动将他断开。这个时间是由参数wait_timeout控制的，默认是8小时。

![image-20211206113856588](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20211206113856588.png)

数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。

建立连接的过程通常是比较复杂的，所以建议在使用中尽量减少建立连接的动作，也就是尽量使用长连接。

但是使用长连接之后就会出现一些问题，可能会发现，有时候MySQL占用内存涨得特别快，这是因为MySQL在执行的过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放，所以如果长连接累积下来，可能导致内存占用太大，被系统强行傻死（OOM），从现象上看就是MySQL异常重启了。

### 如何解决长连接占用内存过大问题？

1. 定期断开长连接。使用一段时间或者程序里面判断执行一个占用内存的大查询后，断开连接，之后要查询的时候再连接。
2. 如果是MySQL5.7或者更新的版本，可以在每次执行一个比较大的操作后，通过执行mysql_reset_connection来重新初始化连接资源。这个过程不需要重连或者重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。

## 查询缓存

连接建立完成后，你就可以执行select语句了。执行逻辑就会来到第二步：查询缓存。

MySQL拿到一个查询请求之后，会先到查询缓存中看看，之前是否执行过这条语句。之前执行过的语句和结果会以key-value的形式缓存在内存中。key是查询的语句，value是查询的结果。如果这个查询能在缓存中找到key那么这个value会被直接返回给客户端（在返回之前，要做权限验证，验证用户是否有权限）。

如果语句不在查询缓存中，就会继续后面的执行阶段。执行完后，执行结果会被存入到查询缓存中。

但是大多数情况不建议使用查询缓存，因为查询缓存往往弊大于利。

### 为什么不建议使用查询缓存？

1. 查询缓存的失效非常频繁，只要对一个表有更新，这个表上所有的查询缓存都会被清空。
2. 对于更新压力大的数据库来说，查询缓存的命中率会非常低
3. 如果业务是一张静态表，可以使用查询缓存。

好在MySQL也提供了这种“按需使用”的方式。你可以将参数query_cache_type设置成DEMAND，这样对于默认的SQL语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用SQL_CACHE显式指定，像下面这个语句一样：

```sql
select SQL_CACHE * from T where ID=10；
```

MySQL8版本直接将查询缓存的整块功能删掉了。

## 分析器（解析）

如果没有命中查询缓存，就要开始真正执行语句了。

首先MySQL需要知道一条SQL语句要做什么，因此需要对SQL语句做解析。

分析器首先会做**“词法分析”**。输入的SQL语句是由多个字符串和空格组成，MySQL需要识别出里的字符串分别是什么，代表什么。

MySQL从你输入的"select"这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名T”，把字符串“ID”识别成“列ID”。

由此可以看出，MySQL判断一张表和一个列是否存在是在分析阶段做的。

做完了以上的识别之后，就要做**语法分析**。根据词法分析的结果，语法分析器会根据语法规则判断数据的SQL是否满足MySQL语法。如果语句不对，就会报错。

## 优化器

经过了分析器，MySQL就知道一条SQL语句到低要做什么了。但是在开始执行之前，还需要经过优化器的处理。

优化器的作用：

* 在表里面有多个索引的时候，决定使用那个索引
* 在一个语句有多表关联的时候（join），决定各个表的连接顺序。
  * 例如如果两个表做连接，是选择先通过条件选择第一张表中的数据，然后连接第二张表，最后判断第二张表的数据，
  * 或者是先选择通过条件选择第二张表中的数据，然后连接第一张表，最后根据第一章表中的条件选择数据。
  * 这两种执行方法的逻辑结果是一样的，但是执行效率会有不同，而优化器的作用就是选择哪一种方案。

### 但是优化器是怎么选择索引的？有没有可能选错？

## 执行器

MySQL通过分析知道了SQL语句要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。

**开始执行的时候，要先判断一下客户端对表是否有相应的执行权限**，如果没有就会返回没有权限的错误，（在工程实现上，如果命中查询缓存，会在查询缓存放回结果的时候，做权限验证。查询也会在优化器之前调用precheck验证权限)）

如果有权限，就会打开表继续执行。打开表的时候，执行器就会根据表的引擎的定义，去使用这个引擎提供的接口。

例如我们在表T中查询ID字段（没有索引），那么执行器的流程是这样的：

1. 调用InnoDB引擎接口去这个表的第一行，判断ID的值是不是10，如果不是跳过，如果是将这行存在结果集中。
2. 调用引擎接口取下一行，重复相同的判断逻辑，直到取到这个表的最后一行。
3. 执行器将上述遍历过程中所有满足条件的行组成的结果集作为结果返回给客户端。

这条语句就执行完了。

对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些**接口都是引擎中已经定义好的**

### 慢查询日志

你会在数据库的**慢查询日志中**看到一个**rows_examined**的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。

在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此**引擎扫描行数跟rows_examined并不是完全相同的。**我们后面会专门有一篇文章来讲存储引擎的内部机制，里面会有详细的说明。

## 相关问题

### 如果一个SQL语句中的字段不存在，那么这个错误在那个阶段报出来？

在分析器阶段。分析器阶段会进行词法分析和语法分析，判断表、字段是否存在以及语法时候符合MySQL规范。

高性能MySQL中的解析器和预处理器。

### 为什么用户权限的检查不在优化器之前做？

有些时候，SQL语句要操作的表不只是SQL字面上那些。比如如果有个触发器，得在执行器阶段（过程中）才能确定。优化器阶段前是无能为力的。

MySQL框架有几个组件，各自的作用是什么？

Server层和存储引擎层的作用？

执行器的执行查询语句的流程是什么样的？

### 为什么抛弃查询缓存？

* 匹配规则太严，查询命中率不高
* 如果包含某些和时间有关的函数，查询缓存容易出现错误
* 查询缓存的更新条件很多，很容易就被更新了

# 日志系统——更新语句执行过程

经过配置，MySQL可以恢复到半个月内任意一秒的状态。那么MySQL究竟是如何做到这一点的呢。

首先可以确定的说，查询语句所经过的那一套流程，更新语句同样会走一遍。

1. 在执行更新语句之前，需要通过**连接器**连接数据库
2. 然后如果有关于这个更新语句中表的查询缓存，那么关于这个表的查询缓存结果全部被清空。这也是一般不建议使用查询缓存的原因。
3. 接下来分析器会通过词法和语法解析知道这是一条更新语句。
4. 优化器决定使用那个索引
5. 执行器负责具体的执行
6. 然后执行引擎上场，找到这一行数据，然后返回给执行器，执行器接着更新。

但是与查询流程不一样的是，更新流程还涉及到两个重要的日志模块——redo log（重做日志）和binlog（归档日志）。这两个日志在MySQL中十分重要。redo log和binlog在设计上也有很多值得借鉴的地方。

## 重要的日志模块——redo log

在MySQL中，如果每一次的更新操作都需要写入磁盘，然后磁盘也要找到对应的那条记录，然后更新，整个过程的IO成本、查找成本都很高。为了解决这个问题，MySQL的设计者就使用了redo log这个日志模块来提升更新操作的效率。

### WAL技术

WAL技术的全称为：Write-Ahead- Logging，它的关键就是先写日志，再写磁盘。也就是如果一条更新语句来了，我们先将这个更新的操作写到日志中，然后更新内存中的数据，最后找一个合适的时间点将日志中的更新操作真正的更新到磁盘对应的那条数据上。

具体来说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log中，并更新内存，这个时候更新操作就算完成了。同时InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘中，而这个更新往往是在系统比较空闲的时候做。

### redo log 写操作过程

InnoDB中的redo log是固定大小的，比如可以配置一组4个文件，每个文件的大小是1GB，redo log总共就可以记录4GB的操作。从4个文件的头开始写，写到某位就又回到开头循环写，如下图所示：

![image-20211208105756226](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20211208105756226.png)

write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。

write pos 和checkpoint之间的文件是空着的部分，可以用来记录新的操作，如果write pos追上 checkpoint，这时候就不能再执行新的更新，必须先停下来擦除掉一些记录，把checkpoint推进一下。

### InnoDB的crash-safe（失败-安全）能力

有了redo log InnoDB就可以保证即使数据库发生异常重启之后，之前提交的记录都不会丢失，这个能力成为**crash-safe**

因为InnoDB对于一个数据的更新操作是先在redo log日志中记录更新，这个日志也在磁盘上，然后再在内存中更新，最后找时间更新到磁盘中具体的数据。所以即使数据库发生重启了，内存中更新的数据没有了，那么也可以通过redo log找到之前提交的记录，这样就可以保证crash-safe。

## 重要日志模块——binlog

MySQL从整体来看，其实有两块：一块是Server层，**它主要做的是MySQL功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。**上面说到的redo log是InnoDB引擎特有的日志，而Server层也有自己的日志，称为binlog（归档之日）。

### MySQL为什么会有两份日志？

因为最开始MySQL里面并没有InnoDB引擎，MySQL自带的引擎是MyISAM，但是MyISAM没有crash-safe的能力，binlog日志只能用于归档。而InnoDB是另一个公司以插件的形式引入MySQL的，既然只依靠binlog是没有crash-safe能力的，所以InnoDB 使用另外一套日志系统——也就是redo log来实现crash-safe能力。

### redo log和binlog的不同点

1. redo log是InnoDB引擎特有的，binlog是MySQL的server层实现的，所有引擎都可以使用
2. redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1”。
3. redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写“是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。

## 执行器和InnoDB执行update的内部流程

```sql
create table T(ID int primary key, c int);
update T set c=c+1 where ID=2;
```

1. 执行器先找引擎取ID=2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID2这一行的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后返回。
2. 执行器拿到引擎给的行数据，把这个值加1，得到新的一行数据，再调用引擎接口写入这行新数据。
3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态，然后告知执行器执行完了，随时可以提交事务。
4. 执行器生成这个操作的bin log，并把binlog写入磁盘。
5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交状态，更新完成。

过程如下图所示：浅色代表InnoDB中执行的，深色代表执行器中执行的。

![image-20211208113137115](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20211208113137115.png)

## 两段提交

update语句执行流程的最后三步将redo log的写入拆成了两个步骤：prepare和commit，这就是两段提交。

### 为什么需要两段提交呢？

前面说过了，**binlog会记录所有的逻辑操作，并且是采用“追加写”的形式。**如果你的DBA承诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有binlog，同时系统会定期做整库备份。这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备。

当数据库需要恢复到某一个时刻我们可以这样做;

1. 首先，找到最近的一次全量备份，将这个备份恢复到临时库；
2. 然后从备份的时间点开始，将备份的binlog一次取出来，重新放到要恢复的那个时刻之前。

这样临时库就和误删之前的线上库一样了，然后就可以把表数据从临时库取出来代替原来的库

因为数据库是依靠binlog来实现恢复的，所以要保证redo log和binlog中的数据一致性，因此需要两段提交。这里我们不妨使用反证法来证明为什么需要两段提交：

1. **先写redo log 后写binlog**。这种情况下假设redo log写完，binlog还没有写完的时候，MySQL进程异常重启。由于我们之前说过，redo log写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复数据库中的值是修改后的值。

   但是由于binlog没有写完数据库就crash了，这时候binlog里面没有记录修改数据的那条语句，因此，之后备份日志的时候，存起来的binlog里面就没有那条语句。

   此时如果使用binlog来恢复临时库的话，由于那条语句的binlog缺失，临时库就会少了这一次更新，恢复出来的这条语句就是没有修改之前的值，因此会造成数据库数据的不一致性。

2. **先写binlog后写redo log**。如果binlog写完之后数据库crash，由于redo log还没有写，失败恢复以后这个事务无效，所有这一条更改语句没有生效。但是binlog里面已经记录了这条更改语句的日志，所以，在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的数据是更改过后的数据。

可以看到，如果不使用“两段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。

### 什么时候需要恢复临时库？

1. 误操作数据库之后要使用binlog来恢复数据。
2. 要扩容的时候，需要搭建一些备库来增加系统的读能力的时候

最常见的做法是用全量备份加上应用binlog来实现数据库恢复。

## 相关问题

### binlog的两种模式

当redo log完成了prepare，而binlog又失败了，那么事务本身会回滚。

在重启之后，需要通过检查binlog来确认redo log中处于prepare的事务是否需要commit，如果binlog中存在这个事务的记录，那么redo log中的prepare事务不需要回滚，如果没有则需要回滚。既然这样的话，是不是不需要二段提交，直接以binlog的为准，如果binlog中不存在的，就认为是需要回滚的？

> 1. binlog没有被用来做崩溃恢复，所以一定要有redo log
>
> 2. 因为数据库系统一开始就是这样设计的，所以不能只依赖binlog

这个问题还是不明白！

### update的步骤：

1.首先客户端通过tcp/ip发送一条sql语句到server层的SQL interface
2.SQL interface接到该请求后，先对该条语句进行解析，验证权限是否匹配
3.验证通过以后，分析器会对该语句分析,是否语法有错误等
4.接下来是优化器器生成相应的执行计划，选择最优的执行计划
5.之后会是执行器根据执行计划执行这条语句。在这一步会去open table,如果该table上有MDL，则等待。
如果没有，则加在该表上加短暂的MDL(S)
(如果opend_table太大,表明open_table_cache太小。需要不停的去打开frm文件)
6.进入到引擎层，首先会去innodb_buffer_pool里的data dictionary(元数据信息)得到表信息
7.通过元数据信息,去lock info里查出是否会有相关的锁信息，并把这条update语句需要的
锁信息写入到lock info里(锁这里还有待补充)
8.然后涉及到的老数据通过快照的方式存储到innodb_buffer_pool里的undo page里,并且记录undo log修改的redo
(如果data page里有就直接载入到undo page里，如果没有，则需要去磁盘里取出相应page的数据，载入到undo page里)
9.在innodb_buffer_pool的data page做update操作。并把操作的物理数据页修改记录到redo log buffer里
由于update这个事务会涉及到多个页面的修改，所以redo log buffer里会记录多条页面的修改信息。
因为group commit的原因，这次事务所产生的redo log buffer可能会跟随其它事务一同flush并且sync到磁盘上
10.同时修改的信息，会按照event的格式,记录到binlog_cache中。(这里注意binlog_cache_size是transaction级别的,不是session级别的参数,
一旦commit之后，dump线程会从binlog_cache里把event主动发送给slave的I/O线程)
11.之后把这条sql,需要在二级索引上做的修改，写入到change buffer page，等到下次有其他sql需要读取该二级索引时，再去与二级索引做merge
(随机I/O变为顺序I/O,但是由于现在的磁盘都是SSD,所以对于寻址来说,随机I/O和顺序I/O差距不大)
12.此时update语句已经完成，需要commit或者rollback。这里讨论commit的情况，并且双1
13.commit操作，由于存储引擎层与server层之间采用的是内部XA(保证两个事务的一致性,这里主要保证redo log和binlog的原子性),
所以提交分为prepare阶段与commit阶段
14.prepare阶段,将事务的xid写入，将binlog_cache里的进行flush以及sync操作(大事务的话这步非常耗时)
15.commit阶段，由于之前该事务产生的redo log已经sync到磁盘了。所以这步只是在redo log里标记commit
16.当binlog和redo log都已经落盘以后，如果触发了刷新脏页的操作，先把该脏页复制到doublewrite buffer里，把doublewrite buffer里的刷新到共享表空间，然后才是通过page cleaner线程把脏页写入到磁盘中

![image-20211208133327359](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20211208133327359.png)

### 同样都是IO操作，为什么WAL技术可以提升效率

redo log是顺序写的，并且可以组提交，甚至可以设置缓存，因此可以提升数据库的操作效率。
