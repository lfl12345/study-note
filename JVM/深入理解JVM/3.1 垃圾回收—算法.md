# 垃圾收集器—算法

垃圾收集器需要完成的三个任务：

1. 哪些内存需要回收
2. 什么时候回收
3. 如何回收

栈和程序计数器都是线程私有的，线程结束内存也就回收了，因此垃圾收集器主要关注的就是堆内存和方法区中的内存如何收集。

## 如何判断对象已死

![image-20220122143651016](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220122143651016.png)

### 引用计数法

#### **算法描述：**

* 在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一
* 当引用失效时，计数器值就减一
* 任何时刻计数器为零的对象就是不可能在被使用的对象

主流的java虚拟机都没有采用这种算法

#### **缺点：**

* 很难解决两个对象循环引用的问题。当两个对象循环引用对方，但是没有任何其他的引用引用他们，他们应该被回收，但是简单的使用引用计数法没有办法回收。

### 可达性分析算法

#### **算法描述：**

* 通过一系列称为GC Roots的跟对象作为起始点集
* 从这些结点开始根据引用关系向下搜索，搜索过程所走过的路径称为引用链
* 如果某个对象到GC Roots之间没有任何引用链，这个对象就应该被回收

#### **那些对象可以作为GC Root？**

* 栈内存中：
  * 在虚拟机栈的本地变量表中引用的对象，例如参数、局部变量、临时变量
  * 本地方法栈中Native方法引用的对象
* 方法区内存中：
  * 类静态属性引用的对象
  * 常量引用的对象，例如字符串常量池中的引用
* 其他：
  * 虚拟机内部的引用：基本数据类型对应的Class对象、常驻异常对象、系统类加载器
  * 被同步锁（synchronized）持有的对象

### 四种引用

由于使用强引用无法描述那种“食之无味，弃之可惜”的对象，因此JDK在1.2之后有引用的概念进行了扩张，将引用分为：强引用、软引用、弱引用、和虚引用，这四种引用的强度依次减弱。

#### 强引用

直接使用new或者等号赋值的变量与对象之间的关系是强引用关系。存在强引用关系的对象绝对不会被垃圾回收掉

#### 软引用

只有在内存不足的情况下，JVM会回收仅有软引用引用的对象，也就是JVM经过了一次垃圾回收之后内存还不足够的情况。

软引用的创建需要借助java.lang.ref包下的SoftReferenc类。

软引用可以与引用队列(ReferenceQueue)联合使用。当softObj软引用的obj被GC回收之后，softObj 对象就会被塞到queue中，之后我们可以通过这个队列的poll()来检查你关心的对象是否被回收了，如果队列为空，就返回一个null。反之就返回软引用对象也就是softObj。

图片缓存框架中缓存图片就是通过软引用实现的。

#### 弱引用

只要发生了垃圾回收，仅有弱引用引用的对象会被回收掉。

弱引用（WeakReference）同样也可以配合ReferenceQueue 使用，也同样适用于内存敏感的缓存。ThreadLocal中的key就用到了弱引用。

#### 虚引用

虚引用（PhantomReference）无法影响对象的存活时间，也无法通过虚引用去或得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被回收器回收的时候收到一个系统通知。

### 宣告对象死亡的两次标记过程

当使用可达性分析判断某个对象不可达之后，这个对象也不是必死无疑。要真正宣告一个对象的死亡，最多会经历两次标记过程：

* 在发现对象没有引用链引用它时，进行第一次标记
* 然后根据对象是否有必要执行finalize()方法对对象进行筛选
  * 如果对象没有覆盖finalize方法或者方法已经被虚拟机调用过，那么这个对象没有必要执行finalize方法
  * 如果被判断需要执行finalize方法，这个对象会被放置在一个队列中，稍后由一个虚拟机自动创建的低优先级线程执行队列中的对象的finalize方法。
* 收集器会对队列中的对象进行第二次小规模的标记，如果一个对象在它的finalize方法中将自己和引用链上的对象又进行了关联，那么这个对象最后不会被回收，如果没有，那么这个对象最后会被垃圾回收。

需要注意的是：

如果一个对象在之前执行finalize方法的时候成功逃离了回收，那么下一次将不会逃离回收，因为在第一个阶段的时候 ，他会被判断为不需要执行finalize方法的对象，因为他已经执行过一次了。

finalize方法的运行代价高，不确定性大，无法保证各个对象的调用顺序，已经被官方明确声明为不推荐使用的语法。

### 方法区的回收

方法区的 GC 主要回收：**废弃常量** 和 **无用的类**。

- 废弃常量：例如一个字符串 "abc"，当没有任何引用指向 "abc" 时，它就是废弃常量了。**常量池中的其他类（接口）、方法、字段的符号引用也与此相似**
- 无用的类：同时满足以下 3 个条件的类。
  - 该类的所有实例已被回收，Java 堆中不存在该类的任何实例；
  - 加载该类的 Classloader 已被回收；
  - 该类的 Class 对象没有被任何地方引用，即无法在任何地方通过反射访问该类的方法。

在大量使用**反射、动态代理**、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要jvm具备类卸载的能力。

## 垃圾收集算法

![image-20220122204626013](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220122204626013.png)

以下介绍的垃圾收集算法均属于**追踪式垃圾收集算法**的范畴。

### 分代收集理论

当前jvm的垃圾回收器，大多都遵循了一个经验法则：分代收集理论，这个理论建立在两个分代假说上。

* 弱分代假说：绝大多数对象都是朝生夕死的
* 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡。

划分内存区域存在的明显的困难：对象不是孤立的，对象之间会存在跨代引用。

为了解决这个问题，就需要对分代收集理论添加第三条经验法则：

* 跨代引用假说：跨代引用相对于同代引用来说仅占极少数。

根据这种假说，我们就不必为了少量的跨代引用去扫描另一块分区，只需要建立一个**全局的数据结构——记忆集**，这个结构把老年代划分成若干小块，标识出老年代那一块内存存在跨代引用。伺候发生Minor GC时，只有包含了跨代引用的小块内存中的对象才会被加入到GC Roots进行扫描。

### 标记—清除算法

算法分为**标记**和**清除**两个阶段

#### 算法描述

* 首先标记出所有需要回收的对象
* 标记完成之后，统一回收掉所有被标记的对象

#### 缺点

* 执行效率不稳定，标记和清除两个阶段效率都很低
* 内存碎片化问题

### 标记—复制算法

为了解决标记—清除算法面对大量对象可回收对象时执行效率低的问题。

#### 算法描述

* 将可用空间分为大小相等的两块，每次只使用其中的一块
* 当一块内存使用完之后，将存活对象复制到另一块内存中，将这一块内存全部清除

#### 优点

* 在多数对象都可回收的情况下，不用考虑碎片问题，回收简单、高效

#### 缺点

* 在多数对象都不可回收的情况下，对象复制开销大
* 将可用的内存空间降低一半，空间浪费多。

#### 改进算法

由于绝大多数新生代中的对象熬不过第一轮收集，因此并不需要按照1:1的方式来划分新生代的内存空间。

**Appel式回收：**

* 把新生代划分为一块内存较大的Eden内存空间、两块内存较小的Survivor空间
* 每次内存分配的时候只使用Eden和一块Survivor空间
* 发生垃圾收集时，将Eden中存活的对象以及Survivor中的对象复制到另一块Survivor空间中，然后清除Eden和原来的Survivor空间

### 标记—整理算法

标记—复制算法在对象存活率较高的内存区域执行效率会非常低，因此老年代并不适合使用标记—复制算法。针对老年代的特征，又提出了一种新的算法——标记整理算法

#### 算法描述

* 先标记，然后将存活对象将内存的一端移动，最后清除掉边界以外的空间。

#### 算法利弊

标记清除和标记整理本质的区别就是**是否移动对象**，**移动对象这一操作有利有弊**：

* 在对象存活率较高的空间移动对象的花销很大，同时移动对象的时候必须Stop the world，这样更坏
* 但是如果不移动对象，内存碎片对于内存的分配来说很不利，需要很复杂的算法为对象分配内存，因为内存不是连续的。

基于以上两点：是否移动对象都存在弊端，移动对象回收时会更复杂，不移动则内存分配时会更复杂。从垃圾收集的停顿时间来看，不移动对象停顿时间更短，甚至可以不用停顿，但是从这个程序的吞吐量来看，移动对象会更划算。

## HotSpot回收算法实现

如果要高效的实现垃圾回收，垃圾回收器必须解决一下的问题。

### 根节点获取

现在可达性分析算法耗时最长的引用链查找过程已经可以做到和用户线程一起并发，但是根节点的获取必须在一个能保障一致性的快照中才可以进行（不会出现在分析根节点的过程中，根节点的引用关系还在不断的变化）。

由于目前jvm都是准确式垃圾收集（jvm知道内存中的数据是对象还是引用），因此如果我们在启动虚拟机或者程序运行的过程中，创建了某个引用为GC Roots，我们就可以直接将他们保存起来，然后在获取根节点的时候直接获取，不需要扫描，这个结构就是OopMap。

### 安全点

但是如果执行每一条产生GC Roots的指令的时候都需要进行保存，那么就需要大量的存储成本。

实际上jvm设置了一些**安全点**，当程序运行到这些安全点的时候，会检查是否有新的GC Roots产生，从而将GC Roots放入OopMap中。

有了这些安全点，就说明程序并非在任何位置都能停下来接收垃圾回收，如果没有到安全点程序就停止进行垃圾回收，那么有一些GC Roots还没有被加入OopMap中。因此程序必须在安全点才能停下。

Hotspot实现程序在安全点主动停下的方式是通过**设置一个标志位的方式**。各个线程会不断的**轮询这个标志**，一旦发现中断标志为真（也就是需要停下来进行垃圾回收时），就在自己最近的安全点上主动挂起，轮询的标志和安全点是重合的。

Hotspot使用内存保护陷阱的方式实现轮询标志。在这个标志，程序会去访问一个不可访问的内存地址，然后会报错，程序就在错误处理处进行挂起，从而实现程序的中断。

### 安全区域

安全点可以保证执行的程序正确的停止，但是没有执行的程序无法正确的停止在安全点上。这时候就需要引入**安全区域**来解决这个问题。

安全区域是指能够保证在某一段代码片段中，引用关系不会发生变化。

当线程执行到安全区域时，它会把自己标识为 Safe Region，这样 JVM 发起 GC 时是不会理会这个线程的。当这个线程要离开安全区域时，它会检查系统是否在 GC 中，如果不在，它就继续执行，如果在，它就等 GC 结束再继续执行。

### 记忆集和卡表

记忆集只是定义了记录这种存在跨代引用对象的行为意图，并没有给出具体实现，只是一种抽象的数据结构，卡表是Hotspot中对于记忆集的具体实现。

内存块（老年代）被分为很多个卡页，如果一个页中存在着跨代引用，那么这个页在卡表中的标记就会变为1，表示这是一个脏页，在垃圾回收的时候，只用扫描这些脏页就可以。

### 写屏障

我们已经解决了如何使用记忆集来缩减GC Roots扫描范围的问题，但是还没有解决**卡表元素如何维护的问题**，例如他们合适变脏读、谁把它们变脏等。

在引用字段赋值操作的后面加入写屏障，完成卡表状态的更新。

为了避免伪共享问题，不要采用无条件的写屏障，而是先检查一下卡表标记，当卡表标记元素没有被标记过时才将其标记为变脏。

### 并发的可达性分析

堆内存使用的越多，可达性分析过程越长。因此必须将这个过程设计为和用户线程并发的过程

如果用户线程和可达性分析并发，可能会产生两个问题：

* 原本要死亡的对象被错误的标记为存活，这个问题不大
* 原本存活的对象错误的标记为死亡，这个问题就大了，会引起程序的错误。

当且仅当一下两个条件产生的时候会发生原本存活的对象被标记为死亡：

* 赋值器插入一条从已经被扫描过的对象到确定要死亡的对象。
  * 此时这个确定要死亡的对象由于有了新的引用要被定义为存活，但是由于扫描器不会再扫描已经扫描过的对象，所以这个对象还是要死亡。
* 赋值器删除了全部从正扫描到一半的对象到刚刚又被已扫描过对象引用的被确定为死亡的对象。
  * 如果赋值器没有删除从灰色到白色对象的引用，那么这个对象还是能被扫描到的，

为了解决并发扫描中对象消失的问题，我们只需要破坏以上的两个必要条件之一就行，也就产生了两种解决方案

* 增量更新：破坏的是第一个条件。当黑的对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。可以简化理解为：黑色对象一旦插入指向白色对象的引用之后，他就变为灰色的了。
* 原始快照：破坏第二个条件。当灰色对象要删除指向白色对象的引用关系时，就将这个删除的引用记录下来，并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。可以简化理解为：无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照进行搜索。

以上无论是对引用关系的删除还是插入，都是使用写屏障来实现记录的。

CMS基于增量更新，G1使用原始快照。































