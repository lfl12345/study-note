# 经典垃圾收集器

## Serial收集器

Serial收集器是一个**单线程**的收集器，他在进行垃圾回收的时候，必须暂停其他工作线程，直到收集完毕。

**单线程**不仅仅代表他在进行垃圾收集的时候只有一个线程，而且用户线程必须停止Stop the World。

Serial收集器收集新生代，Serial Old收集老年代示意图如下：

![image-20220123170833722](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220123170833722.png)

仍然是HotSpot虚拟机在客户端模式下的默认新生代收集器

### 优点

* 简单高效，和其他收集器的单线程相比，对于内存资源受限的情况下，它是所有收集器里额外内存消耗最小的。
* 对于单核处理器或处理器核数较小的环境来说，serial收集器由于没有线程交互的开销，专心做垃圾回收自然可以或得更高的单线程收集效率。

## ParNew收集器

ParNew收集器实质上是Serial收集器的多线程并行版本，除了同时使用多个线程进行垃圾回收之外，其他都和Serial收集器一样，**除了Serial之外，只有它能和CMS收集器配合工作。**

![image-20220123201350906](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220123201350906.png)

ParNew收集器在单核处理器的环境中绝对不会有必Serial收集器更好的效果，甚至由于存在线程交互的开销，在多核情况下也不能保证收集效率超过Serial收集器。

## Parallel Scavenge收集器

**新生代收集器**，基于标记—复制算法实现，也是能够并行收集的多线程收集器。

### 特点

Parallel Scavenge收集器的目标是达到一个可控制的**吞吐量**，而CMS等收集器的关注点是尽可能的缩短垃圾收集时用户线程的停顿时间。因为与吞吐量关系密切，Parallel Scavenge收集器也经常被称作“吞吐量优先收集器”。

**吞吐量**：处理器用于处理运行用户代码的时间与处理器总消耗时间的比值。

虚拟机参数：

* 控制最大垃圾收集时间，虚拟机尽量保证垃圾收集的时间不超过这个时间。
* 控制吞吐量大小，用于控制虚拟机GC的时间和运行用户线程的时间。
* 自动控制新生代的伊甸园和存活区内存大小，这种方式称为自适应调节策略。

## Serial Old收集器

是Serial收集的老年代版本，是一个单线程收集器，使用标记、整理算法。这个收集器**主要用于客户端模式下HotSpot虚拟机的使用。**

在服务端下，可以作为CMS收集器发生失败时的后备预案，在并发收集发生Concurrent Mode Failure时使用。

## Parallel Old收集器

是Parallel Scavenge收集器的老年版本，支持多线程并行收集，基于标记、整理算法。

## CMS收集器

![image-20220124150158403](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220124150158403.png)

第一款真正意义上的并发收集器。是一款老年代收集器，基于标记、清除算法实现，但是当碎片过多的时候也会进行标记、整理。

以获取最短回收停顿时间为目标，适合互联网网站或者基于浏览器的BS系统的服务端上，这类应用通常较为关注服务的相应速度。

### 运行过程：

* 初始标记，初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快；
* 并发标记，并发标记就是寻找引用链的过程，耗时长，但是和用户线程并发执行；
* 重新标记，重新标记是为了修正并发标记期间，因用户线程的并发而导致标记对象发生变动的那一部分记录，停顿时间也不太长；
* 并发清除，并发清除，由于不需要移动存活对象，所以可以和用户线程并发。

![image-20220124150209291](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220124150209291.png)

### 缺点

* CMS收集器对处理器资源非常敏感。事实上，面向并发设计的程序都对CPU资源比较敏感。
* CMS无法处理**浮动垃圾**，因此在并发标记和并发清理阶段，有可能出现Concurrent Mode Failure失败而进入一次完全的STW，使用Serial Old进行垃圾清理。因此在使用CMS清理老年代的时候，不是到了内存不够了才清理，而是要预留一点空间。
* 基于标记、清除，会产生内存碎片。可以配置参数在进行full GC的时候进行内存整理。

## Garbage First （G1）收集器

![image-20220124155604888](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220124155604888.png)

他开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。它是一款面向服务端的垃圾收集器。

G1开创的基于Region的堆内存布局 是它能够实现在指定长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒这样的功能 的关键。

G1不在坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间或者老年代空间。Region中还有一类特殊的Humongous区域，专门用来存储大对象。

虽然G1保存新生代老年代的概念，但是新生代和老年代不再是固定的，他们都是一系列区域（不需要连续）的动态集合。G1之所以能建立可预测的停顿时间模型是因为G1收集器会跟踪各个Region里面的垃圾堆积的价值大小，然后维护一个优先队列，每次根据规定的停顿时间优先处理价值大的区域。

### 运行过程

* 初始标记，标记一下GC Roots能直接关联到的对象。
* 并发标记，从GC Roots开始对堆中对象进行可达性分析。
* 最终标记，用于处理并发阶段结束后仍遗留下来的最后那最少量的SATB记录（原始快照算法）
* 筛选回收，更新Region的统计数据，对各个Region的回收价值和成本进行排序。因为涉及到活对象的移动，所以要停止用户线程。

![image-20220124154330145](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220124154330145.png)

G1除了并发标记之外，其他阶段都要STW，所以它并非纯粹的追求低延时，而是在延迟可控的情况下或得尽可能高的吞吐量。

### G1和CMS的比较

优点：

* G1可以指定最大停顿时间、分Region的内存布局、按受益动态确定回收集
* CMS是标记、清除算法，G1是标记整理加标记复制算法，没有内存碎片

确定：

* G1需要更多的内存记录卡表，CMS只需要记录老年代到新生代，但是G1都要。
* G1各种算法的操作十分复杂，要消耗更多的运算资源。


