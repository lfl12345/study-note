# InnoDB存储引擎

InnoDB是**事务安全**的MySQL存储引擎。通常来说InnoDB存储引擎是**OLTP应用**中核心表的首选存储引擎。

> OLTP：联机事务处理（Online Transaction Processing），是传统的关系型数据库的主要应用，主要是基本的、日常的事务处理，例如银行交易。它表示事务性非常高的系统，以小的事务以及小的查询为主。

## 概述

InnoDB是第一个完整支持ACID事务的MySQL存储引擎，它的特点是**行锁设计、支持MVCC、支持外键、提供一致性非锁定读，**同时被设计用来最有效的利用以及使用内存和CPU。

许多实践证明了InnoDB是一个**高性能、高可用、高可扩展**的存储引擎。

## InnoDB体系架构

InnoDB存储引擎主要由后台线程和内存池组成。

InnoDB存储引擎中有多个内存块，这些内存块组成了一个大的内存池，负责：

* 维护所有进程/线程需要访问的多个内部数据结构
* 缓存磁盘上的数据，方便快速的读取，同时在对磁盘文件的数据修改之前在这里缓存
* 重做日志（redo log）缓冲 

后台线程的主要任务是：

* 刷线内存池中的数据，保证缓冲池中的内存缓冲是最近的数据
* 将已经修改的数据文件刷新到磁盘文件
* 保证数据库在发生异常情况时能恢复到正常运行状态

### 后台线程

InnoDB是多线程模型，后台有不同的线程负责不同的任务

#### Master Thread

负责脏页刷新，合并插入缓冲，undo页的回收等

#### IO Thread

InnoDB中大量使用AIO来处理IO请求，这样可以极大提高数据库性能。IO Thread的工作主要是负责这些IO请求的回调。

#### Purge（清除净化） Thread

事务被提交之后，其所使用的undolog可能不在需要，因此需要PurgeThread来回收已经使用并分配的undo页。

可以支持多个Purge Thread进行回收

#### Page Cleaner Thread

将脏页的刷新操作放到单独线程中完成，减轻原来Master Thread的工作以及对用户查询线程的阻塞。

### 内存

包括缓冲池，重做日志缓冲和额外内存池

#### 缓冲池

缓冲池是一块内存区域，通过内存来弥补磁盘速度较慢对数据库性能的影响。

读取页操作时：首先将从磁盘读到的页存放到缓冲池中，这个过程称为将页“FIX”在缓冲池中，下一次再读到相同的页时，首先判断页是否在缓冲池中，如果在，该页被命中，直接读取，如果不在，从磁盘读取。

更新操作时：首先修改在缓冲池中的页，然后以一定的频率刷新到磁盘上，注意：页从缓冲池刷新回磁盘的操作并不是在每次页发生更新时触发，而是通过一种称为Checkpoint的机制刷新回磁盘。

缓冲池中缓存的数据页类型有：索引页，数据页，undo页，插入缓冲，自适应哈希索引，InnoDB存储的锁信息，数据字典信息等。缓存索引页和数据页占了很大一部分。

<img src="C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220205102417359.png" alt="image-20220205102417359" style="zoom:67%;" />

Innodb可以支持多个缓冲池实例，每个页根据哈希值平均分配到不同缓冲池实例中，减少数据库内部资源竞争，增加数据库的并发处理能力

#### 管理缓冲池—LRU list

通常来说，数据库中的缓冲池是通过LRU算法来管理的。但是InnoDB存储引擎对传统的LRU算法做了一些优化，在InnoDB的存储引擎中，LRU列表中还加入了**midpoint位置**，读取到的新页，虽然是最新的，但是并不是直接放到list的首，而是放到midpoint位置，默认为长度的5/8处。

midpoint之后的了表称为old列表，之前的列表称为new列表。（默认页的生存周期都比较短）

为什么要加入midpoint位置？

* 某些SQL操作可能要读取很多页，但是这些页很长时间就会使用这一次，那么这种操作就会将热点页从LRU列表中移除，因此设置midpoint点可以防止这种事情发生。

但是什么时候将页放到LRU的热端？

* 通过设置参数innodb_old_blocks_time，表示页读取到mid位置后需要多长时间才会被加入到LRU列表的热端

#### 管理缓冲池—Free List

LRU列表用来管理已经读取到的页，但是当数据库刚启动时，LRU列表是空的，即没有任何的页。这时候空页都存放在Free列表中。

当需要从缓冲池中分页时，首先重Free列表中查找是否有可用的空闲页，如果有则将该页从Free列表中删除，放入LRU列表中。否则，根据LRU算法，淘汰LRU列表末尾的页，将该内存空间分配给新的页。

由于Innodb支持压缩页功能，即将原本16KB的页压缩到1KB、2、4、8KB。由于页大小发生改变，LRU列表也要发生改变。对于非16KB的页，是通过unzip_LRU列表进行管理的。

#### 管理缓冲池—Flush List

在LRU列表被修改后，称该页为脏页（dirty page），即缓冲池中的页和磁盘上的页的数据产生了不一致。此时数据库会通过checkpoint机制将脏页刷新回磁盘，而**flush列表中的页就是脏页列表**。

需要注意的是，脏页即存在于LRU列表中，也存在与FLUSH列表中，LRU用来管理缓冲池中页的可用性，flush列表用来管理页刷新回磁盘，二者不影响。

#### 重做日志缓冲

InnoDB首先将重做日志信息存放到这个缓冲区，然后按照一定频率将其刷新到重做日志文件，重做日志缓冲一般不需要设置得很大，因为一般情况下每一秒会将日志缓冲刷新到日志文件，因此用户只需要保证每秒产生的事务量在这个缓冲大小之内即可。

通常情况下，8M的重做日志缓冲池除以满足大部分应用，重做日志缓冲会在一下情况下刷新到磁盘：

* Master Thread每一秒将重做日志刷新到磁盘
* 每个事务提交时会将重做日志缓冲刷新到重做日志文件
* 当重做日志缓冲池剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件。

#### 额外的内存

在对一些数据结构本身的内存进行分配时，需要从额外的内存池中进行申请，当该区域的内存不够时，会从缓冲池中进行申请。

## checkpoint技术

checkpoint技术所做的事情就是将缓冲池中的脏页刷回到磁盘

当前事务数据库系统普遍采用Write Ahead Log策略，就是当事务提交时，先写重做日志，再修改页。当由于发生宕机导致数据丢失时，通过重做日志来完成数据的恢复，这也是事务ACID中 D（Durability持久性）的要求

checkpoint技术是为了解决一下几个问题：

* 缩短数据库的恢复时间
* 缓冲池不够用时，将脏页刷新到磁盘
* 重做日志不可用时，刷新脏页

对于InnoDB而言，通过LSN（Log Sequence Number）来标记版本的，而LSN是8字节的数字，单位是字节，每个页有LSN，重做日志有LSN，Checkpoint也有LSN。

Innodb有两种Checkpoint：

* Sharp Checkpoint：在数据库关闭时将所有脏页刷新回磁盘，默认工作方式。
* Fuzzy Checkpoint

Innodb中可能发生一下几种情况的Fuzzy Checkpoint：

* Master Thread Checkpoint
* FLUSH_LRU_LIST Checkpoint
* Async/Sync Flush Checkpoint
* Dirty Page too much Checkpoint

Master Thread中发生的Checkpoint以每秒或每十秒速度从缓冲池中的**脏页列表中**刷新一定比例的页回磁盘，这个过程是异步的。

FLUSH_LRU_LIST Checkpoint是因为Innodb需要保证LRU列表中需要有差不多100个空闲的页可供使用。这个检查被放到Page Cleaner线程中执行。**此时的脏页是LRU尾部的脏页**

Async/Sync Flush Checkpoint指的是重做日志文件不可用的情况。此时脏页是从**脏页列表中**选取的。它是为了保证重做日志循环使用的可用性。

Dirty Page too much Checkpoint即脏页数量太多导致InnoDB存储引擎强制进行Checkpoint，其目的总的来说还是为了保证缓冲池中有足够可用的页。

## Master Thread工作方式

## Innodb关键特性

### 插入缓冲

#### **Insert Buffer**

Innodb缓冲池中有Insert Buffer信息固然不错，但是Insert Buffer和数据页一样，也是物理页的一个组成部分。

**Insert Buffer产生的原因：**

因为Innodb是一个索引组织表，聚集索引会按照主键的顺序排放，因此大部分的插入情况都是顺序的，不需要随机的读取另一个页中的记录，因此对于这类情况下的插入操作，速度是非常快的。

> 并不是所有主键的插入都是顺序的，若主键类是UUID这样的类，那么插入和辅助索引一样，同样是随机的。
>
> 即使主键是自增类型，但是插入的是指定的值，而不是NULL值，那么同样可能导致插入并非连续的情况。

但是在Innodb中还存在另一种所以——辅助索引，甚至一张表中有很多辅助索引，对于辅助索引的插入不再是顺序的了，这时候就需要离散地访问非聚集索引（因为非聚集的插入可以在任意大小任意位置进行插入，所以就会造成随机读取，可能插入的某个索引页，或数据页不在内存中，需要从磁盘加载数据到内存中），由于随机读取的存在而导致了插入性能下降。这是由于B+树的特性决定了非聚集索引插入的离散性。

**详细操作：**

Insert Buffer是针对于非聚集索引的插入或更新操作的。

当对非聚集索引进行插入或更新操作时，

* 不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，
  * 若在，则直接插入，
  * 若不在，则先放到一个Insert Buffer对象中，这个时候这条数据实际没有插入到物理页上，只是存放在一个位置，然后再以一定的频率和情况进行Insert Buffer和辅助索引页子节点的merge操作，这时候通常能将多个插入合并到一个操作中，因为在一个索引页中，这就大大提高了对非聚集索引插入的性能。

Insert Buffer的使用需要同时满足一下两个条件：

* 索引是辅助索引，如果是聚集索引，直接插入即可，因为没有随机访问，
* **索引不是唯一的**，如果索引是唯一的，那么在插入之前还要随机的去判断索引是否重复，这就没有使用插入缓冲的必要了。

缺点：

* 如果大量的插入操作使用了Insert Buffer，此时数据库发生了宕机，势必有大量的Insert Buffer没有合并到实际的非聚集索引中去，因此此时数据库恢复可能需要很长时间。
* 在密集写的情况下，Insert Buffer会占用过多缓冲池内存。

#### **Change Buffer**

Change Buffer可以看做是Insert Buffer的升级，有了Change Buffer，Innodb可以对DML操作——Insert，delete，update，都进行缓冲，针对他们的缓冲分别为：Insert Buffer，DELETE Buffer，Purge Buffer。

change Buffer针对的对象仍然是非唯一的辅助索引。

### 两次写

如果说Insert Buffer带给InnoDB存储引擎的是性能上的提升，那么doublewrite(两次写)带给Innodb存储引擎的是数据页的可靠性。

当发生数据库宕机时，可能Innodb存储引擎正在写入某个页到表中，而这个页只写了一部分，比如16KB的页，只写了前面4KB，之后就发生宕机了，这种情况被称为部分写失效（partial page write）。

但是，不是还有redo呢，如果发生写失效，可以通过重做日志进行恢复。这是一个办法，但是在MySQL恢复的过程中是检查page的checksum，checksum就是page的最后事务号，发生partial page write问题时，page已经损坏，找不到page中的事务号（不知道为什么找不到），就无法恢复。

所以在应用重做日志之前，用户需要一个页的副本，当写入失效发生时，先通过页的副本来还原该页，再进行重做，这就是doublewrite。

doublewrite由两部分组成，

* 一部分是内存中的doublewrite buffer，大小为2MB，
* 另一部分是物理磁盘上共享表空间中连续的128个页，即2个区，大小同样为2MB

在对缓冲池总的脏页进行刷新时，并不直接写磁盘，而是会通过memcpy函数将脏页先复制到内存中的doublewrite buffer，之后通过doublewrite buffer再分两次，每次1MB顺序地写入共享表空间的物理磁盘 上，然后马上调用fsync函数，同步磁盘，避免缓冲写带来的问题。

因为doublewrite页是连续的，因此这个过程是顺序写的，开销并不是很大。在完成doublewrite页的写入之后，再将doublewrite buffer中的页写入各个表空间中，此时的写入则是离散的。

### 自适应哈希索引

哈希是一种非常快的查找方式，一般情况下复杂度为O(1)，即一般仅需要一次查找就能定位到数据。而B+树的查找次数，取决于B+树的高度，在生产环境中，B+树的高度一般为3-4层，故需要3-4次的查询

Innodb存储引擎会监控对表上各索引页的查询。如果观察到建立哈希索引可以带来速度提升，则建立哈希索引，称之为自适应哈希索引（adaptive hash index，AHI）。AHI是通过缓冲池的B+树页构造而来的，因此建立的速度很快，而且不需要对整张表构建哈希索引。Innodb存储引擎会自动根据访问的频率和模式来自动的为某些热点页建立哈希索引。

AHI有一个要求，即对这个页的连续访问模式必须是一样的。也就是查询条件必须等值搜索并且每次都一模一样。

Innodb会建立AHI的前提：

* 对一个查询模式访问了100次
* 页通过该访问模式访问了N次，其中N=页中记录*1/16



### 异步IO

为了提高磁盘操作性能，当前的数据库系统都采用异步IO的方式来处理磁盘操作。Innodb也使用异步IO的方式。

AIO的优点：

* 用户可以在发出一个IO请求后，再发出一个IO请求，当全部IO请求发送完毕后，等待所有IO操作完成，不用在发送一次IO请求之后，等待IO完成后，再发送下一个IO请求
* 可以进行IOMerge操作。也就是将多个IO合并为1个IO，如果用户需要访问的页是连续的三个页，那么AIO底层就会判断这三个页是连续的，然后AIO底层会发送一个IO请求，连续的读取一次。

在Linux和window操作系统中，操作系统提供了内核级别AIO的支持，称为Native AIO，但是Mac OSX不支持内核级别的AIO。



### 刷新邻接页

**工作原理：**

当刷新一个脏页时，Innodb存储引擎会检测该页所在区的所有页，如果是脏页，那么一起进行刷新。

**好处：**

通过AIO可以将多个IO写入操作合并为一个IO操作，故该工作机制在传统机械磁盘下有着显著优势。

**存在的问题：**

* 如果刷新邻接页是不是可能将不怎么脏的页进行了写入，而该页之后又会很快变为脏页，然后还需要再一次的写入
* 固态硬盘有着较高的IOPS，是否需要这个特性

所以，对于传统的机械硬盘建议使用这个特性，而对于固态硬盘，则建议关闭此特性。

