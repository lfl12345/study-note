# HTTP

## 了解Web和网络基础

WWW（World Wide Web，万维网）这一名称，是Web浏览器当年用来浏览超文本的客户端应用程序时的名称，现在则用来表示这一系列的集合，也可简称为Web。

现在HTTP协议已经超出了Web这个框架的局限，被运用到各种场景中。

### URI和URL

URL（Uniform Resource Locator，统一资源定位符）。URL就是使用Web浏览器等访问Web页面时需要驶入的网页地址，比如http://hackr.jb/就是URL。

URI是Uniform Resource Identifier的缩写，URI就是某个协议方案表示的资源定位标识符。URI用字符串表示某一互联网资源，而URL表示资源的地点（互联网上所处的位置）。可见URL是URI的子集。

绝对URI的格式：

![image-20220209204258596](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220209204258596.png)

使用http:或https:等协议方案名获取访问资源时要制定协议类型。不区分字母大小写，最后附加一个冒号。

## http简介

HTTP协议规定，请求从客户端发出，最后服务端相应请求并返回，换句话说，肯定是先从客户端开始建立通信的，服务端在没有接收到请求之前不会发送相应。

请求报文是由**请求方法**，**请求URI**，**协议版本号**，可选的**请求首部字段**和**请求体构**成的。

![image-20220209204935547](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220209204935547.png)

相应报文基本上是由**协议版本，状态码**（表示请求成功或失败的数字代码），用以解释状态码的**原因短语**，可选的**相应首部字段**以及**相应体**。

![image-20220209205045514](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220209205045514.png)

HTTP是一种不保存状态，即**无状态协议**。HTTP协议自身不对请求和相应之间的通信状态进行保存。也就是说在HTTP这个级别，协议对于发送过来的请求或者相应都不做持久化处理。

HTTP/1.1虽然是无状态协议，但是为了实现期望保持状态功能，引入了**Cookie技术**，有了Cookie再使用HTTP协议通信，就可以管理无状态。

HTTP/1.1中可以使用的**方法**：

* GET：获取资源，GET方法用来请求访问已被URI识别的资源

* POST：传输实体主体，虽然GET方法也可以传输实体主体，但一般不用GET方法进行传输，而是用POST方法。

* PUT：传输文件，就像FTP协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求URI指定的位置，但是由于HTTP/1.1的PUT方法自身不带验证机制，任何人都可以上传文件，存在安全性问题，因此Web网站不使用该方法。

* HEAD：获得报文首部，HEAD方法和GET方法一样，只是不返回报文主体部分，用于确认URI的有效性以及资源更新的日期时间。

  ![image-20220209211626454](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220209211626454.png)

* DELETE：删除文件，是和PUT相反的方法，DELETE方法按请求URI删除指定资源，但是HTTP/1.1的DELETE方法本身和PUT方法一样不带验证机制，所以一般的Web网站也不使用DELETE方法。当配合Web应用程序的验证机制或者遵循REST标准时还是有可能开放使用的

* OPTIONS：询问支持的方法，用来查询针对请求URI指定的资源支持的方法

  ![image-20220209211948556](C:\Users\lfl\Desktop\大三上\Linux\课件和实验\image-20220209211948556.png)

* TRACE：追踪路径，TRACE方法是让Web服务端将之前的请求通信环回给客户端的方法。发送请求时，在Max-Forwards首部字段中填入数值，每经过一个服务端就将该数字减1，当数值刚好减到0时，就停止继续传输，最后接收到请求的服务端则返回状态码200 OK。

* CONNECT：要求用隧道协议连接代理，CONNECT方法要求在于代理服务器通信时建立隧道，实现隧道协议进行TCP通信。主要使用SSL（Secure Sockets Layer，安全套接层）和TLS（Transport Layer Security，传输安全层）协议把通信内容加密后经网络隧道传输。

  CONNECT方法的格式如下：

  ![image-20220209215612318](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220209215612318.png)

  ![image-20220209215621320](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220209215621320.png)

<img src="C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220209215651328.png" alt="image-20220209215651328" style="zoom:80%;" />

**持久连接：**

HTTP协议的初始版本中，每进行一次HTTP通信就要断开一次TCP连接：

<img src="C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220209220151271.png" alt="image-20220209220151271" style="zoom:80%;" />

当需要一次性发送很多HTTP请求的时候，就会产生很多无谓的TCP连接的建立和断开。

为了解决TCP连接的问题，HTTP/1.1推出了持久化连接（HTTP Persistent Connections，也称为HTTP Keep-alive或HTTP connection reuse）方法。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态。

**管线化（流水线发送）**

持久连接使得多数请求以管线化（pipelining）方式发送称为可能，不必等待相应就可以发送下一个请求。这样就可以做到同时并行发送多个请求。

<img src="C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220209221341602.png" alt="image-20220209221341602" style="zoom:80%;" />



**使用Cookie管理状态**

Cookie会根据从服务端发送的相应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。

## http报文内的http信息

用于HTTP协议交互的信息称为HTTP报文，客户端的HTTP报文称为请求报文，服务端的报文称为相应报文。

HTTP报文本身是由多行（用CR+LF作为换行符）数据构成的字符串文本。

HTTP报文大致可分为**报文首部**和**报文主体**两块。两者由最初出现的空行（CR+LF）来划分。通常，并不一定要有报文主题。

<img src="C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220209224652959.png" alt="image-20220209224652959" style="zoom:80%;" />

### 请求报文和相应报文的结构

<img src="C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220209224812047.png" alt="image-20220209224812047" style="zoom:80%;" />

请求报文和相应报文的首部内容由以下数据组成：

* 请求行：包含用于请求的方法，URI和HTTP版本
* 状态行：包含表名相应结果的状态码，原因短句和HTTP版本
* 首部字段：包含表示请求和相应的各种条件和属性的各类首部，一般有4种首部，分别为：通用首部，请求首部，相应首部，实体首部
* 其他：可能包含HTTP的RFC里未定义的首部（Cookie等）

### 编码提升传输速率

HTTP在传输数据时可以按照数据原貌直接传输，也可以在传输过程中通过编码提升传输速率。通过在传输时编码，能有效地处理大量的访问请求。

#### 压缩传输的内容编码

内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体有客户端接收并负责解码。

常用的内容编码有一下几种：

* gzip（GNU zip）
* compress（UNIX系统的标准压缩）
* deflate（zlib）
* identity（不进行编码）

#### 分割发送的分块传输编码

在HTTP通信过程中，请求的的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。

这种把实体主体分块的功能称为分块传输编码

分块传输编码会将实体主体分成多个部分（块）。每一块都会用16进制来标记块的大小，而实体主体的最后一块会使用“0（CR+LF）”来标记。

使用分块传输编码的实体主体由接收的客户端负责解码，恢复到编码前的实体主体。

HTTP/1.1中存在一种称为**传输编码**的机制，它可以在通信时按某种编码方式传输，但只定义作用于分块传输编码中

### 多部分对象集合

HTTP协议中采纳了多部分对象集合，发送的一份报文主体内容可含有多类型实体。通常是在图片或者文本文件等上传时使用。

多部分对象集合包含的对象如下：

* mulitpart/form-data

  在web表单文件上传时使用

  <img src="C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220210073809772.png" alt="image-20220210073809772" style="zoom:80%;" />

* mulitpart/byteranges

  状态码206（Partial Content，部分内容）相应报文包含了多个范围的内容时使用

  <img src="C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220210073847305.png" alt="image-20220210073847305" style="zoom:80%;" />

在HTTP报文中使用多部分对象集合时，需要在首部字段中加入Content-type。

在多部分对象集合的每个部分类型中，都可以含有首部字段。另外可以在某个部分中嵌套使用多部分对象集合。

### 获取部分内容的范围请求

指定范围发送的请求叫做范围请求（Range Request）。

执行范围请求时，会用到首部字段Range来指定资源的byte范围。byte范围的指定形式如下：

<img src="C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220210074519462.png" alt="image-20220210074519462" style="zoom:80%;" />

<img src="C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220210074531083.png" alt="image-20220210074531083" style="zoom:80%;" />

针对范围请求，响应会返回状态码为206Part Content的相应报文。对于多重范围的范围请求，相应会在首部字段Content-type标明multipart/byteranges后返回相应报文。

如果服务器无法相应范围请求，则会返回状态码200 OK和完全的实体内容。

### 内容协商机制

内容协商机制是指客户端和服务器就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言，字符集，编码方式等作为判断的基准。

包含在请求报文中的某些首部字段就是判断的基准：

* Accept
* Accept-Charset
* Accept-Encoding
* Accept-Language
* Content-Language

内容协商技术有三中类型：

* 服务器驱动协商
* 客户端驱动协商
* 透明协商



## 返回结果的http状态码

状态码的职责是当客户端向服务器发送请求时，描述返回的请求结果，借助状态码，用户可以知道服务器是正常处理了请求还是出现了错误。

状态码以3位数字和原因短语组成。

数字中的第一位指定了响应类别，后两位无分类。相应类别有以下五种：

|      | 类别                             | 原因短语                   |
| ---- | -------------------------------- | -------------------------- |
| 1XX  | Informational（信息性状态码）    | 接收的请求正在处理         |
| 2XX  | Success（成功状态码）            | 请求正常处理完毕           |
| 3XX  | Redirection（重定向状态码）      | 需要进行附加操作以完成请求 |
| 4XX  | Client Error（客户端错误状态码） | 服务器无法处理请求         |
| 5XX  | Server Error（服务器错误状态码） | 服务器处理请求出错         |

### 2XX成功

2XX的相应结果表名请求被正常处理了

#### 200 OK

表示从客户端发送的请求在服务端被正常处理了。

#### 204 Not Content

表示服务器接收的请求已经成功处理，但在返回的相应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。比如：当从浏览器发出请求处理后，返回204相应，那么浏览器显示的页面不发生更新

一般只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。

#### 206 Partial Content

表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。相应报文中包含有Content-Range指定范围的实体内容。

### 3XX重定向

3XX相应结果表明浏览器需要执行某些特殊的处理以正确处理请求。

#### 301 Moved Permanemtly

永久性重定向。该状态码表示请求的资源已经被分配了新的URI，以后应该使用资源现在所指的URI。

#### 302 Found

临时性重定向。该状态码表示请求的资源已经被分配了新的URI，希望用户（本次）能使用新的URI访问。

和301 Moved Premanently状态码相似，但是302状态码代表的资源不是被永久移动，只是临时性质的。

#### 303 See Other

该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。

303状态码和302 Found状态码有着相同的功能，但是303状态码明确表示客户端应当采用GET方法获取资源，这点和302状态码有区别。

#### 304 Not Modified

该状态码表示客户端发送附带条件的请求（指GET方法的请求报文中包含If-Match，If-Modified-Since，If-None-Match,If-Range,If-Unmodified-Since中任一首部）时，服务器端允许请求访问资源，但是未满足条件的情况。304状态码返回时，不包含任何相应的主体部分。

304虽然被划分在3XX类别中，但是和重定向没有关系。

#### 307 Temporary Redirect

临时重定向。该状态码与302Found有着相同的含义。尽管302标准禁止POST变换为GET，但实际使用是大家并不遵守。

307会遵守浏览器标准，不会从POST变为GET。但是对于处理响应时的行为，每种浏览器可能会出现不同的情况。

### 4XX客户端错误

4XX表示客户端是发生错误的原因所在。

#### 400 Bad Request

表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像200 OK一样对待该状态码

#### 401 Unauthorized

该状态码表示发送的请求需要有通过HTTP认证的认证信息，若之前已经进行过一次请求，则表表示用户认证失败。

<img src="C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220212174817224.png" alt="image-20220212174817224" style="zoom:80%;" />

返回含有401的相应必须包含一个适用于被请求资源的WWW-Authenticate首部用于质询用户信息。当浏览器初次接收到401响应，会弹出认证用的对话窗口。

#### 403 Forbidden

该状态码表明对请求资源的访问被服务器拒绝了。服务端没有必要给出拒绝的详细理由，但如果想做说明的话，可以在实体的主体部分对原因进行描述。

未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源IP地址试图访问）等列举的情况都可能是发生403的原因。

#### 404 Not Found

表明服务器上无法找到请求的资源。除此之外，也可以在服务端拒绝请求且不想说明理由时使用。

### 5XX服务器错误

表明是服务器本身发生的错误

#### 500 Internal Server Error

表明服务器端在执行请求时发生了错误。也有可能是Web应用存在的bug或某些临时故障。

#### 503 Service Unavailable

该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入Retry-After首部字段再返回给客户端

## HTTP首部



## 确保Web安全的https

### HTTP的缺点

由于HTTP协议未加密，因此有许多不足：

* 通信使用明文（不加密），内容可能会被窃听
* 不验证通信方的身份，因此有可能遭遇伪装
* 无法证明报文的完整性，所以有可能报文已经被篡改

#### 使用明文可能被窃听

HTTP本身没有加密功能，所以HTTP报文的发送是以明文的形式。

为什么通信时不加密就是一个缺点，这是因为，按照TCP/IP协议族的工作机制，通信内容在所在的通信线路上都有可能遭到窥视。

即使已经过加密处理的通信，也会被窥视到通信内容，这点和未加密的通信时相同的。只是说如果通过加密，就有可能让人无法破解报文信息的含义，但加密处理后的报文信息本身还是会被看到的。

加密技术加密的对象：

* 通信的加密：HTTP没有加密机制，但是可以通过和SSL（Secure Socket Layer，安全套接层）或TLS（Transport Layer Security，安全层传输协议）的组合使用，加密HTTP的通信内容。

  使用SSL建立安全通信路之后，就可以在这条路上进行HTTP通信了。与SSL组合使用的HTTP被称为HTTPS（HTTP Secure，超文本传输安全协议）或HTTP over SSL

* 内容的加密：这种情况下，客户端需要对HTTP报文内容进行加密处理后再发送请求。当然，为了做到有效的内容加密，前提是要求客户端和服务器同时具备加密和解密机制。但是由于该方式不同于SSL或TLS将整个通信线路加密处理，所以内容仍有被篡改的风险。

#### 不验证通信方的身份，就有可能遭遇伪装

HTTP协议中的请求和响应不会对通信方进行确认，因此任何人都可以发起请求。另外，服务器只要接收到请求，不管对方是谁都会返回一个响应。因此不确定通信方，会存在一下各种隐患：

* 无法确定发送至目标的Web服务器是否是按真实意图返回响应的那台服务器，有可能是已经伪装的Web服务器
* 无法确定响应返回到的客户端是否是按照真实意图接收响应的那个客户端。有可能是已经伪装的客户端
* 无法确定正在通信的对方是否具备访问权限，因为某些服务器上保存着重要的信息，只想发给特定用户通信的权限。
* 无法判定请求来自何方，出自谁手
* 即使是无意义的请求也会照单全收。无法阻止海量请求下的DoS攻击（Denial Of Service，拒绝服务攻击）

**查明对手的证书：**

SSL可以确定通信方。SSL不仅提供加密处理，而且还使用了一种被称为证书的手段，可以用于确定方。

证书由值得信任的第三方机构颁发，用来证明服务器和客户端是实际存在的。另外，伪造证书从技术角度来说是异常困难的一件事。所以只要能够确认通信方（服务器和客户端）持有证书，即可判断通信方的真实意图。

通过使用证书，以证明通信方就是意料中的服务器。这对使用者个人来讲，也减少了个人信息泄漏的危险性。

另外，客户端持有证书即可完成个人身份的确认，也可用于对Web网站的认证环节。

#### 无法证明报文完整性，可能已遭篡改

由于HTTP协议无法证明通信的报文完整性，也就没有办法确认发出的请求/响应和接收到的请求/响应是前后相同的。传输的内容在传输途中可能已经被篡改为其他内容。

**如何防止篡改**：

最常用的是MD5和SHA-1等散列值校验的方法，以及用来确认文件的数字签名方法。但是这些方法事实上并不便捷，可靠。

无论使用以上那种方法，都需要操作客户端的用户本人亲自检查验证下载的文件是否就是原来服务器上的文件。浏览器无法自动帮用户检查。

可惜的是，这些方法依然无法百分百确认结果正确。因为PGP和MD5本身被改写的话，用户是没有办法意识到的。

为了有效防止这些弊端，有必要使用HTTPS。SSL提供认证和加密处理及摘要功能。

### HTTP+加密+认证+完整性保护=HTTPS

为了解决HTTP的无法加密、无法认证通信双方以及无法保证内容的完整性这些问题，需要在HTTP上再加入加密处理和认证等机制。我们把添加了加密及认证机制的HTTP称为HTTPS（HTTP Secure）

#### HTTPS是身披SSL外壳的HTTP

HTTPS并非是一种应用层的新协议。只是HTTP通信接口部分用SSL和TLS协议代替而已。

通常HTTP直接和TCP通信。当时用SSL时，则演变成先和SSL通信，再由SSL和TCP通信了。

<img src="C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220213100501909.png" alt="image-20220213100501909" style="zoom:80%;" />

SSL是独立于HTTP的协议，所以其他运行在应用层的协议也可以配合SSL协议使用。

#### 相互交换秘钥的公开秘钥加密技术

SSL采用一种叫做**公开秘钥**加密的加密处理方式。现在的加密算法是公开的，但是秘钥是保密的，加密和解密都会用到秘钥。

##### **共享秘钥加密的困境**

加密和解密同用一个秘钥的方式称为**共享秘钥加密**，也被叫做**对称秘钥加密**。

缺点：但是如果在转发秘钥时，秘钥就有可能落入攻击者之后，另外还要设法安全地保管接收到的秘钥。

##### **使用两把秘钥的公开秘钥加密**

公开秘钥加密方式很好解决了共享秘钥的困境。

公开秘钥加密使用一对**非对称的秘钥**。一把叫做**私有秘钥**，另一把为**公开秘钥。**私有秘钥自己保管，公开密钥可以任意发布，任何人都可以获取。

使用公开秘钥加密方式，发送秘钥的一方使用对方的公开秘钥进行加密处理，对方收到被加密的信息后，再使用自己的私有秘钥进行解密。利用这种方式，不需要发送用来解密的私有秘钥，也不必担心秘钥被攻击者窃听而盗走。

另外如果想使用密文和公开秘钥，恢复到信息原文是异常困难的。

##### HTTPS采用混合加密机制

HTTPS采用共享秘钥和公开秘钥加密两者并用的混合加密机制。若秘钥能够实现安全交换，那么有可能会考虑仅使用共享秘钥加密来通信。但是公开秘钥和共享秘钥相比，其处理速度要慢。

所以在交换秘钥环节使用公开秘钥加密方式，之后的建立通信交换报文阶段则使用共享秘钥加密方式。

<img src="C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220213101817781.png" alt="image-20220213101817781" style="zoom:80%;" />

#### 证明公开秘钥正确性的证书

但是，公开秘钥加密方式还是存在一些问题。那就是无法证明秘钥本身就是货真价实的公开秘钥。真正的公开秘钥可能会被中间的攻击者替换掉。

为了解决这个问题，可以使用有数字证书认证机构（CA，Certificate Authority）和其他相关机构颁发的公开秘钥证书。

数字证书认证机构处于客户端和服务器都可信赖的第三方机构的立场上。数字认证机构的业务流程：

* 服务器的运行人员向数字认证机构提出公开秘钥的申请。
* 数字证书认证机构在判明提出者的身份后，对已申请的公开秘钥做数字签名
* 然后分配这个已签名的公开秘钥，并将该公开秘钥放入公钥证书后绑定在一起。

服务器会将这份有数字证书认证机构颁发的公钥证书发送给客户端，已进行公开秘钥加密方式通信。

接到证书的客户端可使用数字证书认证机构的公开密钥，对那张证书上的数字签名进行验证，一旦验证通过，客户端可明确两件事：

1. 认证服务器的公开秘钥是真实有效的数字证书认证机构
2. 服务器的公开密钥值得信赖。

##### 用以确认客户端的客户端证书

用客户端证书证明服务器正在通信的对方始终是预料之内的客户端。

### HTTPS的安全通信机制

1. 客户端通过发送Client Hello报文开始SSL通信。报文中包含客户端支持的SSL的指定版本，加密组件列表（所使用的加密算法和秘钥长度等）
2. 服务器可进行SSL通信时，会以Server Hello报文作为应答。和客户端一样，在报文中包含SSL版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。
3. 之后服务器发送Certificate报文，报文中包含公开秘钥证书。
4. 最后服务器发送Server Hello Done报文通知客户端，最初阶段的SSL握手协议部分结束。
5. SSL第一次握手结束之后，客户端以Client Key Exchange报文作为回应。报文包含通信加密中使用的一种 Pre-master secret的随机密码串。该报文已使用步骤3中的公开秘钥进行加密。
6. 接着客户端继续发送Change Cipher Spec报文。该报文提示服务器，在此报文之后的通信会采用Per-master secret秘钥加密。
7. 客户端发送Finished报文，该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能正确解密该报文作为判断标准。
8. 服务器同样发送Change Cipher Spec报文。
9. 服务器同样发送Finished报文
10. 服务器和客户端的Finished报文交换完毕之后，SSL连接就算建立完成了。当然，通信会受到SSL的保护。从此处开始进行应用层协议的通信。
11. 应用层协议通信，即发送HTTP相应
12. 最后由客户端断开连接。断开连接时，发送close_notify报文。

在以上流程中，应用层发送数据时会附加一种叫做MAC（Message Authentication Code）的报文摘要。MAC能够查知报文是否遭到篡改，从而保护报文的完整性。

<img src="C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220213104733359.png" alt="image-20220213104733359" style="zoom:80%;" />

#### SSL速度慢吗

HTTPS也存在一些问题，就是使用SSL时，它的处理速度会变慢，会消耗CPU和内存资源。

SSL的慢分两种：

* 通信慢
* 大量消耗CPU及内存资源，导致处理速度慢

#### 为什么不一直使用HTTPS

有些Web网站不会一直使用HTTPS。

* 加密通信消耗CPU和内存资源，处理速度慢
* 要节约购买证书的开销

## 面试问题

### HTTP优化方案

* TCP复用：TCP连接复用是将多个客户端的HTTP请求复用到一个TCP连接上，可以使用负载均衡设备来完成
* 内容缓存：将经常使用的内容缓存起来，这样客户端就可以直接从内存中获取相应的数据
* 压缩，将文本数据压缩，减少带宽
* SSL加速：使用SSL协议加密，在通道内加密并加速	

# HTTPS RSA握手过程

TLS第一次握手：

* 客户端首先发送一个Client Hello消息，消息里面有客户端使用的TLS版本号，支持的密码套件列表，以及生成的随机数（Client Random），这个随机数会被服务端保留，它是生成对称加密秘钥的材料之一

TLS第二次握手：

* 当服务端收到客户端的Client Hello消息后，会确认TLS版本号是否支持，然后从密码套件列表中选择一个密码套件，以及生成随机数（Server Random）。
* 接着返回Server Hello消息，消息里面有服务器确认的TLS版本号，也给出了随机数（Server Random），然后从客户端的密码套件列表选择了一个合适的密码套件
* 然后服务端为了证明自己的身份，会发送Server Certificate给客户端，这个消息里含有数字证书
* 随后，服务端发了Server Hello Done消息，目的是告诉客户端，我已经把该给你的东西都给你了，本次打招呼完毕。

TLS第三次握手：

* 客户端验证完服务器的身份之后，客户端会再生成一个新的随机数，用服务器的RSA公钥加密该随机数，通过Change Cipher Key Exchange消息传给服务端
* 客户端使用三个随机数生产会话秘钥后，然后发送一个Change Cipher Spec消息，告诉服务端开始使用加密方式发送消息
* 最后，客户端再发送一个Encrypted Handshake Message（Finished）消息，把之前所有发送的数据做个摘要，再用会话秘钥加密一下，让服务器做个验证，验证加密通信是否可用和之前握手信息是否有被中途篡改过

TLS第四次握手：

* 服务器也是同样的操作，发送Change Cipher Spec和Encrypted Handshake Message消息，如果双方都验证加密和解密没问题，那么握手正式完成

# HTTPS握手过程中，客户端如何验证证书

CA证书的签发过程：

* 首先CA认证机构会把持有者的公钥，用途，颁发者，有效时间等信息打成一个包，然后对这些信息进行Hash计算，得到一个Hash值
* 然后CA会使用自己的私钥将该Hash值加密，生成Certificate Signature，也就是CA对证书做了签名
* 最后将Certificate Signature添加在文件证书上，形成数字证书。

客户端校验服务端的数字证书的过程：

* 首先客户端会使用同样的Hash算法获取该证书的Hash值H1
* 通常浏览器和操作系统中集成了CA的公钥信息，浏览器收到证书后，可以使用CA的公钥解密Certificate Signature内容，得到一个Hash值H2
* 最后比较H1和H2，如果值相同，那么就是可信赖的整数，否则认为证书不可信







































































































