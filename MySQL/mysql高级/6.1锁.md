#  锁

InnoDB存储引擎锁的实现提供一致性的非锁定读，行级锁支持。行级锁没有相关额外的开销，并可以同时得到并发性和一致性。

全局锁：

* flush tables with read lock；unlock tables

表级锁：

* 表锁
* 元数据锁
* 意向锁
* AUTO-INC锁 自增长锁

行级锁：

* Record lock
* Gap Lock
* Next-key lock

## lock和latch

latch一般被称为闩锁（轻量级的锁），因为其要求锁定的时间必须非常短。若持续时间长，那么应用的性能会非常差。在Innodb中，latch有可以分为mutex（互斥锁）和rwlock（读写锁）。它的目的是用来保证并发线程操作临界区资源的正确性，并且通常没有死锁检测机制。

lock的对象是事务，用来锁定的是数据库中的对象，如表，页，行。并且一般lock的对象仅在事务commit或rollback后进行释放（不同事务隔离级别释放时间可能不同）。lock有死锁机制。

## Innodb中的锁

### 锁的类型

Innodb实现了两种标准的行级锁：

* 共享锁（S lock），允许事务读一行数据
* 排他锁（X lock），允许事务删除或更新一行数据。

Innodb支持多粒度锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。

为了支持在不同粒度上进行加锁操作，Innodb存储引擎支持一种额外的锁方式，称之为**意向锁**。意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度上进行加锁。

InnoDB支持意向锁设计比较简练，其意向锁即为表级锁。设计的主要目的是为了在一个事务中揭示下一行将被请求的所类型，支持两种意向锁：

* 意向共享锁（IS Lock），事务想要获取一张表中某几行的共享锁
* 意向排他锁（IX Lock），事务想要获取一张表中某几行的排他锁

由于Innodb支持的是行级别的锁，因此意向锁其实不会阻塞除了全表扫描以外其他任何请求。

Innodb存储引擎在INFORMATION_SCHEMA架构下添加了三张表，通过这三张表我们可以简单地监控当前事务并分析其可能存在的锁问题，使用`select * from information_schema.表名`来查看信息：

* INNODB_TRX，查看事务信息，如事务id，事务状态，事务等待的锁等
* INNODB_LOCKS，查看锁信息，如锁id，事务id，锁模式，锁类型（行锁还是表锁），要锁的表
* INNODB_LOCK_WAITS，很直观地反应当前事务的等待，如申请锁资源的事务id，申请的锁id，阻塞的事务id，阻塞的锁id，这里只有id信息，可以联合前两张表进进行联合查询。

### 一致性非锁定读（MVCC）

一致性的非锁定读是指Innodb通过多版本控制的方式来读取当前执行时间数据库中行的数据。如果读取的行正在执行deleted或update操作这时读取操作不会因此等待行上锁的释放，相反的，innodb会去读取行的一个**快照数据。**之所以称为非锁定读，是因为不需要等待访问行上x锁的释放。

快照数据是指该行的之前版本的数据，该实现通过undo段来完成 ，undo用来在事务中回滚数据，因此快照数据本身是没有额外的开销。

非锁定读机制极大的提高了数据库的并发性。在不同事务隔离级别下，读取的方式不同，并不是每个事务隔离级别下都采用非锁定的一致性读，此外，即使都使用的是非锁定的一致性读，但是对于快照数据的定义也各不相同。

使用行多版本技术带来的并发控制称之为多版本并发控制（Multi Version Concurrency Control，MVCC）

在事务隔离级别read committed和repeatable read下，innodb使用非锁定的一致性读。然而他们对于快照的定义却不相同：

* read committed级别下，非一致性读总是读取被锁定行的最新一份快照数据
* repeatable read，非一致性读总是读取事务开始时的行数据版本

### 一致性锁定读

默认模式下，innodb的select操作使用一致性非锁定度，但是在某些情况下，用户需要显式地对数据库读取操作进行加锁以保证数据逻辑的一致性。而这要求**数据库支持加锁语句**，Innodb对于select语句支持两种一致性的锁定读操作：

* select 。。。 for update，对读取行记录加X锁，
* select 。。。lock in share model，加一个S锁

这两个锁定语句必须在事务中使用，事务提交了，锁也就释放了

### 自增长与锁

innodb内存结构中，对每个含有自增长值的表都有一个自增长计数器，当对含有自增长的计数器的表进行插入操作时，这个计数器会被初始化。

插入操作会依据这个自增长的计数器值加一赋予自增长列。这个实现方式称为AUTO-INC Locking。这种锁其实是采用一种特殊的表锁机制，为了提高性能，锁不是在一个事务完成之后才释放，而是在完成对自增长值插入的SQL语句后立即释放。

**AUTO-INC Locking缺点：**

* 对于有自增长列的并发插入性能较差，事务必须等待前一个插入的完成
* 对于insert。。。select的大数据量的插入会影响插入的性能，因为另一个事务中的插入会被阻塞

后来，Innodb提供了一种轻量级互斥的自增长实现机制，这种机制大大提高了自增长插入的性能，并且提供了一个参数innodb_autoinc_lock_mode来控制自增长模式，默认值为1。

**自增长插入分类：**

* insert-like，指所有插入语句
* simple insert，能在插入前就确定插入行数的语句
* bulk inserts，插入前不能确定插入行数的语句，如insert。。。select
* mixed-mode inserts，插入中一部分自增长，一部分确定的

**innodb_autoinc_lock_mode的设置对自增的影响：**

* 0，通过表锁AUTO-INC Locking方式
* 1，对simple insert使用互斥量（mutex）去对内存中的计数器进行累加操作，对bulk inserts还是使用表锁，这种配置下，如果不考虑回滚，自增值列增长还是连续的。
* 2，insert-like都是使用互斥量，这可能会使自增长列不是连续的

**在innodb存储引擎中，自增长列必须是索引，同时必须是索引的第一个列。**

### 外键与锁

外键主要用于引用完整性约束检查。对于一个外键，Innodb会自动加一个索引，这样可以避免表锁。

对于外键值的插入或更新，首先需要查询父表中的记录，即select父表。但是对于父表的select操作，不是使用一致性非锁定读的方式，因为这样会发生数据不一致的问题，因此此时使用的是select。。。lock in share mode方式，加一个S锁。

## 锁的算法

### 行锁的三种算法

* record lock，单个行记录上的锁
* gap lock，间隙锁，锁定一个范围，但是不包含记录本身
* next-key lock：gap lock+record lock，锁定一个范围，并且锁定记录本身

record lock总是会锁住索引记录。

next-key lock会锁住一个key到下一个key的这个区间，是一个范围，它设计的目的是为了解决Phantom Problem。除了next-key lock技术还有previous-key locking技术。

当查询的索引含有唯一属性时，InnoDB存储引擎会对Next-Key lock进行优化，将其降级为Record lock，即锁住索引本身，而不是范围。

如果是辅助索引，不仅会加上Next-key lock，还会对下一个键值加上gap lock，例如如果执行下面的语句：

```sql 
select * from z where b = 3 for update
```

假设b是辅助索引，加上next-key lock之后，会锁住（前一个键值，3）的键值记录，但是还加上了下一个键值的gap lock，因此还锁住了（3，下一个键值）区间。

**在辅助索引上使用如上机制是为了防止Phantom Problem的发生**，如果没有Gap lock，那么在3后面可以插入b为3的记录，会产生同一个事务中，查询同一张表查询的结果不一样。

可以通过两种方式显示**关闭gap lock：**

* 将事务隔离级别设置为read committed
* 将参数innodb_locks_unsafe_for_binlog设置为1

如果配置了上面的，除了外键约束和唯一性检查需要的gap lock，其余情况仅使用record lock。但是上述配置破坏了事务的隔离性，可能导致主从数据不一致。

**提醒：**对于唯一键值的锁定，Next-Key Lock降级为Record Lock仅存在于查询所有的唯一索引列。若唯一索引由多个列组成，而查询仅是查找多个唯一索引列中的其中一个，那么查询其实是range类型查询，而不是point类型查询，因此Innodb存储引擎依然使用Next-Key Lock进行锁定。

### 解决Phantom Problem

**Phantom Problem（幻读）是指在一个事务下，连续执行两次同样的SQL语句可能导致不同的结果，第二次的SQL语句可能会返回之前不存在的行。**

在MySQL的默认事务隔离级别下，InnoDB采用Next-Key Locking机制来避免Phantom Problem幻读问题，也就是在该隔离级别下，Innodb采用Next-Key Lock的方式加锁，但是在read committed下，采用的是Record Lock方式加锁。

## 锁问题

通过锁机制可以实现事务的隔离性要求，使事务可以并发的工作。所提高了并发，但是却会带来潜在的问题。

### 脏读

在read uncommitted隔离级别下会出现脏读现象

### 不可重复读

在一个事务中两次读到的数据是不一样的情况，这种情况称为不可重复度。

一般来说不可重复读的问题是可以接受的，因为其读到的是已经提交的数据，本身不会带来很大的问题。

在Next-key Lock算法下，对于索引的扫描，不仅是锁住扫描到的索引，而且还锁住这些索引覆盖的范围（gap）。因此在这些范围内插入是不允许的，这样就避免了另外的事务在这个范围内插入数据导致的不可重复读的问题。

### 丢失更新

简单来说就是一个事务的更新会被另一个事务的更新操作所覆盖，从而导致数据的不一致

但是在当前数据库的任何隔离级别下，都不会导致理论意义上的丢失数据，因为对于行的DML操作，需要对行进行加锁，因此其他事务会等待前一个事务提交之后，才能被允许去更改同一个行上的数据。

但是如果操作是先查询，后更新，那么就有可能出现丢失更新的现象，因此我们需要在先查询的时候在数据上加上X锁。

## 阻塞

Innodb中，参数innodb_lock_wait_timeout用来控制等待的时间（默认是50秒），innodb_rollback_on_timeout用来设定是否在等待超时时对进行中的事务进行回滚操作。（默认OFF，表示不回滚）。

innodb_lock_wait_timeout参数是动态的，在MySQL运行时可以调整

innodb_rollback_on_timeout参数是静态的，不可以在运行的时候调整。

在默认情况下InnoDB在不会回滚的事务超时之后会引发一个异常，但是Innodb在大部分情况下不会对异常进行回滚，因此如果事务超时，引发异常，那么在引发异常之前的操作还是可能成功的，没有回滚。

## 死锁

死锁是指两个或多个事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象，

解决死锁最简单的方式：

* 不要有等待，任何等待都转化为回滚，并且事务重新开始，但是这样可能导致并发性能下降，甚至任何一个事务都不能进行
* 超时，当两个事务相互等待是，如果一个事务等待的时间超过了某个阈值，其中一个事务进行回滚，另一个等待的事务就可以进行。但是回滚还是会有性能的消耗。
* 使用等待图的方式来死锁检测，事务为等待图中的结点，边的定义为：事务T1等待事务T2所占有的资源或者事务T1最终等待T2所占用的资源，也就是事务之间的等待相同的资源，例如事务2先去申请一个资源，然后事务1再去申请这个资源，那么就会有一条边从T1执行T2。如果在等待图中发现了回路，那么Innodb会选择回滚段undo量最小的事务进行回滚。

除了超时机制，还普遍采用wait-for-graph（等待图）的方式来进行死锁检测。和超时机制相比，这是一种比较主动的死锁检测机制。Innodb也采用这种方式。

wait-for-graph的死锁检测通常采用深度优先的算法，Innodb使用非递归的方式，提高了Innodb存储引擎的性能

## 锁升级

锁升级是指将当前锁的粒度降低，例如数据库可以把表的1000个行锁升级为一个页锁，或者将页锁升级为表锁。如果在数据库的设计中认为锁是一种稀有资源，而且想避免锁的开销，那数据库中会频繁出现锁升级现象。

锁升级会带来的问题是因为锁粒度降低而导致并发性能的降低。

Innodb不存在锁升级的问题，因为其不是根据每个记录来产生行锁的，相反其根据每个事务访问的每个页对锁进行管理，采用的是位图的方式，因此不管一个事务锁住页中一个记录还是多个记录，开销通常都是一样的

## 如何减少行锁对性能的影响？

在Innodb事务中，行锁是在需要的时候才加上的，但是并不是不需要了就释放，而是等到事务结束时才释放。这就是两阶段锁协议。

了解了这个协议之后，我们就需要根据事务中语句的执行情况对语句顺序进行调整：如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。

当出现死锁之后，有两种策略：

* 直接进入等待，知道超时，这个超时时间可以通过参数innodb_lock_wait_timeout来设置
* 另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑。

在innodb中，innodb_lock_wait_timeout的默认时间是50S，意味着如果采用第一种策略，当出现死锁以后，第一个被锁住的线程要50s才会超时退出，然后其他线程才有可能继续执行。对于在线服务器来说，这个等待时间是不能接收的。

但是如果我们把这个时间设置很小，例如1S，这样出现死锁的时候，确实很快就可以解开，但是如果不是死锁，而是简单的锁等待，这样就会造成很多误伤。

所以正常情况下我们还是要采用第二种策略，即：主动死锁检测，而且Innodb_deadLock_detect的默认值本身就是on。主动死锁检测发生在死锁的时候，是能快速发现并进行处理的，但是他也是有额外负担的。







