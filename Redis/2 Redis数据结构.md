# Redis数据结构

<img src="C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220317150545668.png" alt="image-20220317150545668" style="zoom:80%;" />

Redis为什么那么快？

除了Redis是内存数据库，使得所有的操作都在内存上进行之外，还有一个重要的因素，**它实现的数据结构**，使得我们对数据进行增删改查操作时，Redis都能高效的处理。

## SDS简单动态字符串

Redis中没有使用C语言的字符串（使用\0作为结尾的字符），而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象结构，SDS是Redis的默认字符串表示。

在Redis中，C字符串只会作为字符串字面量用在一些无需对字符串值进行修改的地方，比如打印日志。

SDS的用处：

* 保存数据库中字符串值
* AOF模块中的AOF缓冲区
* 客户端状态中的输入缓冲区

### SDS的定义

<img src="C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220316143923220.png" alt="image-20220316143923220" style="zoom:80%;" />

Redis针对不同长度的字符串，定义了不同的sdshdr结构体，最基本的结构体内容如下：

* len：已使用字节长度，即字符串长度。Redis中限制字符串最大长度不能超过512M，记录了这个变量，当获取字符串长度时，Redis就可以使用O(1)时间返回。
* alloc：已申请的字节长度，即sds总长，可能存在申请了但是还没有使用的内存空间
* flags：低3位表示sdshdr类型，高5位表示字符串长度
* buf[]：字符数组，用来保存实际数据。不仅可以保存字符串，也可以保存二进制数据。

sds遵循C语言字符串结尾习惯，使用空字符结尾，并且不计入len，alloc的计算，这样的话，sds可以直接使用C语言中的一些函数。

### SDS和C字符串的区别

C语言使用长度为N+1的字符数组来表示长度为N的字符串，并且字符数组的最后一个元素总是空字符'\0'。 

#### 常数复杂度获取字符串长度

C字符串并不记录字符串的信息，如果想要获取字符串的长度，必须遍历整个字符串，然后计数，这个操作的时间复杂度是O(n)。

而SDS中记录了字符串的长度len，可以将获取字符串长度的复杂度降到常数级别，**从而使得获取字符串长度不会影响Redis的性能。**

#### 杜绝缓冲区溢出

由于C语言字符串不记录字符串长度信息，如果另个字符串进行拼接的话，容易造成缓冲区溢出。例如如果S1和S2这两个C字符串在内存中紧邻，如果我们使用strcat函数对S1字符串进行拼接操作，那么拼接上的字符串会溢出到S2内存区域，从而导致S2字符串的内容被改变。

但是SDS的内存分配策略杜绝了发生内存溢出的可能性：

当对sds进行修改时：

* 会先检查sds的空间是否满足修改要求，
* 如果不满足，自动将sds的空间扩容至执行修改所需要的大小，然后才执行实际的修改操作，但是有一个最大值，然后再进行实际的修改操作。

#### 减少修改字符串带来的内存分配次数

因为C语言字符串长度和底层数组的长度之间存在着相等的关系（长度为N的C字符，底层数组长度为N+1，加上一个结尾空字符），因此对于C语言的字符串的每次增长或缩短都对应着一次内存的重新分配，内存的重新分配可能需要系统调用，这样性能是不高的。

* 如果是增长字符串的操作，在增长操作之前，就需要通过内存重新分配来扩展底层数组的空间大小，如果忘了这一步，那么就会产生缓冲区溢出
* 如果是缩短字符串操作，例如截断操作（trim），那么在这个操作之前，程序需要通过内存重新分配来释放字符串不再使用的那部分空间，如果忘了，就会造成内存溢出。

**为了避免C语言的这种缺陷，redis通过未使用空间解除了字符串长度和底层数组长度之间的关联：**在sds中，buf数组的长度不一定就是字符串长度加一，数组中可以包含没有使用的字节，而这些字节的数量就是alloc-len的值。

通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略。

##### **空间预分配**

空间预分配用于优化sds字符串增长的操作：当sds的api对一个sds进行修改，并且需要对sds进行空间扩展的时候，程序不仅会为sds分配修改所需要的空间，还会为sds分配额外的未使用的空间。

* 如果修改后sds长度小于1MB，那么程序分配的值是len值的两倍
* 如果修改后sds长度大于1MB，那么程序会分配1MB的free空间

**通过空间预分配策略，Redis可以减少连续执行字符串增长操作所需的内存重分配次数，将连续增长N次字符串所需要的内存重分配次数从必定N次降低为最多N次。**

在扩展SDS空间之前

* SDS API会检查未使用空间是否足够 
* 如果足够的话，API就会直接使用未使用空间，而无需执行内存重分配
* 如果空间不足的话，就会进行空间的扩容分配。

##### **惰性内存释放**

惰性内存释放用于优化sds字符串缩短操作：当sds的api需要缩短sds保存的字符串时，程序并不立即使用内存重分配来后手缩短后多出来的字节，而是使用alloc和len属性的差值将这些字节记录起来，并等待将来使用。

与此同时，SDS也提供了相应的API，让我们可以在有需要的时候，真正的释放SDS的未使用空间，所以不用担心惰性空间释放策略会造成空间浪费。

#### 二进制安全

C字符串中的字符必须符合某种编码，并且除了字符串的末尾外，不能有空字符，要不就会被当做结尾处理，这限制了C字符串只能保存文本类的信息。

redis为了确保sds可以适用于各种不同的保存场景，sds的api都是二进制安全的，所有sds的api都会以处理二进制的方式来处理sds存放在buf数组中的数据，程序不会对其中的数据做任何限制，过滤，或者其他操作，数据在写入的时候什么样，出来的时候就是什么样。

这也就是我们将buf属性称为字节数组的原因，redis不是用这个数组来保存字符，而是用来保存一系列二进制数据。

因为SDS使用的是len属性的值而不是空字符来判断字符串是否结束，因此SDS可以用来存储任意格式的二进制数据。

#### 兼容部分C字符串

因为sds最后一个字符遵循C字符的规范，是一个空字符，因此如果sds中保存的是纯文本的话，可以使用C中关于字符串的函数，这样就不用重写函数，例如：比较函数，追加字符串的函数

#### 总结

总的来说，SDS在C字符串的基础上，增加了len，alloc以及flags三个属性，用来解决C语言字符串的缺陷。

![image-20220218112642303](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220218112642303.png)

## 链表list

Redis中List对象的底层实现之一就是链表。当一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时，Redis就会使用链表作为列表键的底层实现。

链表的用处：

* List对象的底层实现之一
* 发布与订阅，慢查询，监视器等功能
* 保存多个客户端的状态信息
* 构建客户端输出缓冲区（output buffer）



### 链表和链表结点的实现

每个链表结点使用一个listNode结构来实现：

```C
typedef struct listNode { 
    // 前置节点
    struct listNode * prev; 
    // 后置节点
    struct listNode * next; 
    // 节点的值
    void * value; 
}listNode;
```

保存链表信息的结构体：

list结构体为链表提供了链表的头指针head，链表尾结点tail，链表结点数量len，以及可以自定义实现的dup，free，match函数。

```C
typedef struct list { 
    // 表头节点
    listNode * head;
    // 表尾节点
    listNode * tail; 
    // 链表所包含的节点数量 
    unsigned long len; 
    // 节点值复制函数 
    void *(*dup)(void *ptr); 
    // 节点值释放函数 
    void (*free)(void *ptr); 
    // 节点值对比函数 
    int (*match)(void *ptr,void *key); 
} list;
```

### List的优缺点

优点：

* listNode链表结点的结构里带有prev和next指针，**获取某个结点的前置结点或后置结点的时间复杂度只需要O(1)**，而且这两个指针都可以指向NULL，所以链表是无环链表；
* list结构因为提供了表头指针head和表尾结点tail，所以**获取链表的头结点和尾结点的时间复杂度只需要O(1)**
* list结构提供了链表数量len属性，**所以获取链表中的结点数量的时间复杂度只需要O(1)**
* listNode链表结点使用void*指针保存结点值，并且可以通过list结构的dup，free，match函数指针为该结点设置该结点类型特定的函数，因此**链表结点可以保存各种不同类型的值**

缺点：

* 链表每个结点之间的内存都是不连续的，意味着**无法很好利用CPU缓存**。能很好利用CPU缓存的数据结构就是数组，因为数组的内存是连续的，这样就可以充分利用CPU缓存来加速访问。
* 保存一个链表结点的值都需要两个链表指针空间的分配，内存开销大。

因为list结构有以上缺点，因此在Redis3.0的List对象在数据量比较少的情况下，会采用压缩列表作为底层数据结构的实现，它的优势就是节省内存空间，并且是内存紧凑型的数据结构。

但是，压缩列表存在性能问题，所以Redis在3.2版本设计了新的数据结构quicklist，并将List对象的底层数据结构改为quickList实现。

在Redis 5.0设计了新的数据结构listpack，沿用了压缩列表紧凑型的内存布局，最终在最新的版本，将Hash对象和Zset对象的底层数据结构实现之一的压缩列表，替换成由listpack实现。



## 压缩列表ziplist

Redis内部使用**链表**保存运行时的数据，如主服务下所有的从服务器信息。但是Redis并不使用该链表保存用户列表数据，因为它对内存管理不够友好：

* 链表中的每个结点都使用独立的一块内存，导致内存碎片过多
* 链表结点中前后结点指针占用过多的额外空间

因此，Redis使用ziplist来保存用户列表数据，ziplist是一种类似于数组的紧凑链表格式，他会申请一整块内存，在这个内存上放该链表所有的数据，这就是ziplist的设计思想，这样的话不仅可以利用CPU缓存，而且会针对不同长度的数据，进行相应编码，这种方法可以有效地节省内存开销。

压缩列表的用处：（在以下对象包含数据量较少的情况下）

* List对象
* Hash对象
* Zset对象

### 压缩列表结构设计

压缩列表是Redis为节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构。一个压缩列表可以包含任意多个结点（entry），每个结点可以保存一个字节数组或者一个整数值。

ziplist总体布局如下：

![image-20220318143910113](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220318143910113.png)

压缩列表在表头和表尾有四个字段，用来存储整个压缩列表的整体信息：

* zlbytes记录整个ziplist占用的字节数，包括zlbytes占用的4字节，在对压缩列表进行内存重新分配或者计算zlend的位置的时候使用。
* zltail记录从ziplist起始位置到**尾结点**的偏移量，用于支持链表从尾部弹出或反向遍历
* zllen记录结点数量，2字节，如果压缩列表长度超过最大值（65535），需要使用遍历获取结点数量
* zlend特殊的标志结点，等于255，表示结尾

在压缩列表中，如果我们要查找定位第一个和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是O(1)，但是在查找其他元素时，就没有那么高效了，只能逐个查找，此时的复杂度就是O(N)了，因此压缩列表不适合保存过多元素。

### 结点的构成

![image-20220318145652754](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220318145652754.png)



entry包含以下三个内容：

* previous_entry_length，以字节为单位，记录了压缩列表中前一个节点的长度。previous_entry_length的长度可以是1字节或者5字节

  * 如果前一个节点的长度小于254字节，那么它的长度为1字节
  * 如果前一个结点的长度大于等于254字节，那么它的长度为5字节：其中第一个字节会被设置为（254），之后的字节保存前一个节点的长度

  压缩列表可以利用每个结点的previous_entry_length属性实现从表尾到表头遍历这一操作

* encoding属性记录了结点的data属性所保存数据的类型以及长度。

  * 如果当前结点保存的是整数，那么encoding属性使用1个字节进行编码，前两位为11
  * 如果当前结点的数据是字符串，encoding属性会根据字符串的长度选择使用1,2，或5字节的编码长度。

* 保存当前结点的值，结点值可以是一个字节数组或者整数，值的类型和长度由结点的encoding属性决定。

当我们向压缩列表中插入值时，压缩列表会根据当前的数据是整数还是字符串，以及数据的大小，然后使用不同大小的prevlen属性和encoding属性去保存相应的信息，**这种根据数据大小和类型进行不同空间大小分配的设计思想，正是redis为节省内存而采用的。**

### 连锁更新

因为压缩列表中entry中的prevlen中保存的是前一个节点的长度，如果前一个结点的长度小于254字节，那么这个属性使用1个字节；如果前一个节点的长度大于等于254字节，那么这个属性使用5个字节。

现在假设如果有多个连续的entry长度介于250到253字节之间，如果在第一个entry前面加入一个长度大于等于254字节的entry，那么就会导致这个新节点的下一个结点的prevlen从1个字节变为5个字节，因为这个结点的prevlen长度变量，那么它的下一个结点的prevlen长度也需要增大。

当需要增加entry所占用的内存时，程序需要对压缩列表进行内存的重新分配，因为有好多连续的结点需要将prevlen扩大到5字节，因此程序需要进行很多次的内存重新分配。

Redis将这种特殊情况下产生的连续多次空间扩展操作称为“连锁更新”。

除了新增结点可能会引起连锁更新之外，删除结点也有可能会引发连锁更新。如果删除了一个大小小于254的结点，但是这个删除结点的前一个节点大小大于等于254，那么下一个结点的prevlen就需要扩容。

因为连锁更新在最坏情况下需要对压缩列表执行N次空间重新分配操作，而每次空间重分配最坏复杂度为O(N),所以连锁更新的最坏复杂度为O（N2）。

但是产生连锁更新的条件很难达到，并且即使出现连锁更新，如果压缩列表中的entry数量不多，也无关紧要。

### 压缩列表的缺点

在增加或者删除元素的时候，会产生内存的重新分配，甚至是连锁更新的产生，印象数据访问的效率。因此压缩列表只会用于保存结点数量不多的场景。

Redis针对压缩列表在设计上的不足，在后来的版本中，新增设计了两种数据结构：quicklist（3.2）和listpack（5.0）。这两种数据结构的设计目标，就是尽可能的保持压缩列表节省内存的优势，同时解决压缩列表的连锁更新问题。



## quicklist

在Redis3.0之前，List对象的底层数据结构是双向链表或者压缩列表，在Redis3.2的时候，list对象的底层换为quicklist数据结构实现。

其实quicklist就是双向链表+压缩列表的组合，因为quicklist就是一个链表，而链表中的每个元素又是一个压缩列表。

虽然ziplist通过紧凑型的内存布局可以解决list的内存问题，但是他也有缺点：

* 因为存储紧凑，所以新增元素时，需要扩展内存，并将之前的数据拷贝过来
* 如果内容过多，内存分配和元素拷贝就会消耗很大，因此它不适合存储大量数据
* 同时还有连锁更新的风险，一旦发生，会造成性能下降。

quicklist解决以上问题的办法，通过控制每个链表结点中的压缩列表的大小或者元素个数，来规避连锁更新问题。因为压缩列表元素越少或者越小，连锁更新带来的影响就越小，从而提供了更好的访问性能。

quicklist的设计思想很简单，讲一个长ziplist拆分为多个端ziplist，避免插入或删除元素时导致大量的内容拷贝。

多个ziplist使用双向链表串联起来，每个ziplist的大小为8K。

### quicklist的实现

quicklist的结构体

* head指针指向quicklist表头node
* tail指针指向quicklist表尾node
* count表示所有压缩列表中总元素个数
* len表示quicklist中结点的个数（quicklistnode）

```c
typedef struct quicklist {
 //quicklist的链表头
 quicklistNode *head; //quicklist的链表头
 //quicklist的链表头
 quicklistNode *tail;
 //所有压缩列表中的总元素个数
 unsigned long count;
 //quicklistNodes的个数
 unsigned long len; 
 ...
} quicklist;
```

quicklistnode结构体

* prev，next，前一个node和下一个node的指针
* zl属性指针指向一个压缩列表
* sz属性保存压缩列表的字节大小

```c
typedef struct quicklistNode {
 //前⼀个quicklistNode
 struct quicklistNode *prev; //前⼀个quicklistNode
 //下⼀个quicklistNode
 struct quicklistNode *next; //后⼀个quicklistNode
 //quicklistNode指向的压缩列表
 unsigned char *zl; 
 //压缩列表的的字节⼤⼩
 unsigned int sz; 
 //压缩列表的元素个数
 unsigned int count : 16; //ziplist中的元素个数
 ....
} quicklistNode;
```

### 添加元素

向quicklist中添加元素时，不会像普通链表那样直接创建一个结点添加进去，而是会检查插入位置的压缩列表是否能够容纳该元素，如果能容纳就直接保存到quicklistNode结构里的压缩列表，如果不能容纳，才会创建一个新的quicklistNode结构。

### 一个quicklist结点到低包含多大的ziplist好?

* 每个quicklist节点上的ziplist越短，则内存碎片越多。内存碎片多了，有可能在内存中产生很多无法被利用的小碎片，从而降低存储效率。这种情况的极端是每个quicklist节点上的ziplist只包含一个数据项，这就蜕化成一个普通的双向链表了。
* 每个quicklist节点上的ziplist越长，则为ziplist分配大块连续内存空间的难度就越大。有可能出现内存里有很多小块的空闲空间（它们加起来很多），但却找不到一块足够大的空闲空间分配给ziplist的情况。这同样会降低存储效率。这种情况的极端是整个quicklist只有一个节点，所有的数据项都分配在这仅有的一个节点的ziplist里面。这其实蜕化成一个ziplist了。

[quicklist](https://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&mid=2657261335&idx=1&sn=053d72a348be2e78040f3847f4092d92&scene=19#wechat_redirect)

## 字典（哈希表）

字典数据结构的用处：

* Redis数据库是使用字典作为底层实现的
* 哈希建的底层实现之一也是字典，当一 个哈希键包含的键值对比较多，又或者键值对中的元素都是比较长的字 符串时，Redis就会使用字典作为哈希键的底层实现。
* Redis的其他很多功能也用到了字典。

### 字典的实现

<img src="C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220319100531239.png" alt="image-20220319100531239" style="zoom: 67%;" />

#### 哈希表

哈希表是一个数组（dictEntry **table），数组中的每一个元素是一个指向哈希结点的指针。

size属性记录了哈希表的大小，也就是table数组的大小；

used属性记录了哈希表目前已有的结点（键值对）数量

sizemask属性的值总是等于size-1，用于计算一个键在table的索引位置，由此可以看出，size的大小肯定是2的整数次方。

```C
typedef struct dictht { 
    // 哈希表数组 ,负责存储数据
    dictEntry **table; 
    // 哈希表大小 
    unsigned long size; 
    // 哈希表大小掩码，用于计算索引值 
    // 总是等于size-1 
    unsigned long sizemask; 
    // 该哈希表已有节点的数量 
    unsigned long used; 
} dictht;
```

#### 哈希结点

哈希结点中包含指向key以及value的指针，还有指向下一个结点的指针next，用于使用链地址法解决哈希冲突。

dictEntry中的union联合体表明了键值对中的值不仅可以指向实际值的指针，还可以是一个64位无符号数或者有符号数，这么做的好处是可以节省空间，因为当键值对中的值是整数或者浮点数的时候，就不需要使用一个指针再去指向一个实际的值，直接嵌入到这个结点结构体中，从而节省了指针的内存空间。

```c
typedef struct dictEntry {
    // 键 
    void *key; 
    // 值 
    union{
        void *val; 
        uint64_tu64; 
        int64_ts64; 
    } v; 
    // 指向下个哈希表节点，形成链表 
    struct dictEntry *next; 
} dictEntry;
```

#### 字典

ht属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表，一般情况下，字典只使用ht[0]，ht[1]哈希表只会在对ht[0]哈希表进行rehash时使用。

rehashidx属性也和rehash有关，他记录了当前rehash的进度，如果目前没有在进行rehash，那么它的值就是-1。

```C
typedef struct dict { 
    // 指定操作数据的函数指针 
    dictType *type; 
    // 私有数据
    void *privdata; 
    // 定义两个hash表用于字典扩容机制，通常情况下只会使用ht[0],扩容时会创建ht[1]，并在操作数据时逐步将ht[0]的数据移到ht[1]中
    dictht ht[2]; 
    // rehash 索引 
    // 当rehash 不在进行时，值为-1 
    long rehashidx; /* rehashing not in progress if rehashidx == -1 */ 
    // 当前运行的迭代器数量，迭代器用于遍历字典键值对
    unsigned long iterators;
} dict;
```

dictType定义了字典中用于操作数据的函数指针，这些函数负责实现数据复制，比较等操作。

```C
typedef struct dictType { 
    // 计算哈希值的函数 
    unsigned int (*hashFunction)(const void *key); 
    // 复制键的函数 
    void *(*keyDup)(void *privdata, const void *key); 
    // 复制值的函数 
    void *(*valDup)(void *privdata, const void *obj); 
    // 对比键的函数 
    int (*keyCompare)(void *privdata, const void *key1, const void *key2); 
    // 销毁键的函数 
    void (*keyDestructor)(void *privdata, void *key); 
    // 销毁值的函数 
    void (*valDestructor)(void *privdata, void *obj); } dictType;
```

通过dictType指定操作数据的函数指针，字典就可以存放不同类型的数据了，但是在一个字典中，键，值可以是不同的类型，但是键必须类型相同，值也必须类型相同。

### 哈希算法

使用SIPHash算法来计算key的哈希值，该算法能有效的放置Hash表碰撞攻击，并提供不错的性能

然后通过&运算来计算key在table中的index，利用sizemask属性，因此redishash表的大小应该也是2的整数倍

### 解决哈希冲突

Redis的哈希表使用链地址法（separate chaining）来解决键冲突，使用头插的方式。

### rehash

redis的哈希表有扩容和缩容操作，HashMap只有扩容没有缩容操作。

随着操作的不断执行，哈希表保存的键值对会逐渐地增多或者减少，为了让哈希表的负载因子（load factor）维持在一个合理的范围之内，**当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行相应的扩展或者收缩。**

哈希表rehash的步骤：

* 为字典ht[1]分配空间，这个哈希表的大小取决于要执行的是扩容还是缩容，以及当前ht[0]当前包含的键值对数量，也就是used属性的值。
  * 如果执行的是扩容操作，那么ht[1]的大小为第一个大于等于ht[0].used*2的2的整n次方
  * 如果执行的是缩容操作，那么大小为第一个大于等于used的2的整n次方。
* 将保存在ht0中的所有键值对rehash到ht1上面：rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht1哈希表的指定位置上
* 当ht0包含的所有键值对都移动到ht1之后，释放ht0空间，将ht1设置为ht0，并在ht1新创建一个空白哈希表，为下一此rehash做准备。

**这个rehash的过程看起来简单，但是其实第二步很有问题，如果哈希表1的数据量非常大，那么在迁移到哈希表2的时候，因为会涉及大量的数据拷贝，此时可能会对Redis造成阻塞，无法服务其他请求。**

### 渐进式扩容

为了避免rehash对服务器性能造成影响，服务器不是一次性将ht[0]里面的所有键值对全部rehash到ht[1]，而是分多次、渐进式地将ht[0]里面的键值对慢慢地rehash到ht[1]。

渐进式rehash的步骤：

1. 为ht1分配空间，字典同时具有ht0，ht1两个表
2. 在字典中维护rehashindex，将它的值设为0，表示rehash开始
3. 在rehash期间，每次对字典执行添加，删除，查找，或者更新操作时，程序除了执行指定的操作之外，还会顺带将ht0表在rehashidx索引上的所有键值对（如果有链表，就将整个链表）rehash到ht1中，当rehash工作完成之后，程序将rehashrdx属性的值加一
4. 当ht0全部被移到ht1之后，程序将rehashidx设置为-1，表示rehash操作已经完成

渐进式rehash的好处在于它采取分而治之的方式，将rehash键值对所需要的计算工作均摊到对字典的每个添加，删除，查找和更新操作上，从而避免了集中式rehash而带来的庞大计算量。

**渐进式rehash期间执行的哈希表操作**

在rehash过程中，字典的增删改查会在两个哈希表中进行

* 查找的话先查找ht0，如果没有查到，再查找ht1；

* 添加操作全部加到ht1中，保证了ht0只会少不会多

### rehash触发条件

扩容的触发：

* 服务器目前没有执行bgsave或者bgrewriteaof命令，并且哈希表的负载因子大于等于1
* 服务器目前正在执行bgsave或者bgrewriteaof命令，并且哈希表的负载因子大于等于5

哈希表的负载因子=哈希表used属性 / 哈希表size属性

为什么要根据服务器是否在bgsave或者bgrewriteaof来设置不同的rehash触发条件？

当bgsave或者bgrewriteaof的时候，redis会创建一个子进程然后进行bgsave和bgrewriteaof所需要的IO操作，因此这时候需要提高负载因子的界限，从而降低不必要的IO操作对系统的内存以及CPU的影响。

缩容的触发：

* 当哈希表的负载因子小于0.1时，程序自动开始对哈希表进行收缩操作。



## 跳跃表

跳跃表是一种有序数据结构，它通过在每个结点中维持多个指向其他结点的指针，从而达到快速访问结点的目的。

跳跃表的优点就是支持平均O(logN)，最坏O(N)复杂度的结点查找，还可以通过顺序性操作来批量处理结点

在大部分情况下，跳跃表的效率可以和平和树相媲美，并且因为跳跃表的实现比平衡树更为简单，主要体现在插入和删除结点之后的维护上，所以有不少程序都使用跳跃表来代替平衡树。

跳表的应用：

* 有序集合键（Zset）底层实现之一（实际是hash字典+跳跃表），如果一个有序集合包含的元素数量比较多，又或者有序集合元素的成员是比较长的字符串时，Redis就会使用跳跃表来作为有序集合的底层实现。
* 集群结点中用作内部数据结构

Zset底层使用数据结构的情况：

* Zset对象在使用压缩列表作为底层数据结构的时候，Zset对象结构的指针会指向压缩列表
* Zset对象在使用跳表作为底层数据结构的时候，Zset对象结构的指针会指向Zset结构（哈希表+跳表）

Zset在使用跳表作为底层实现的时候，并不是指向跳表数据结构，而是指向了Zset结构，它包含两个数据结构，一个是跳表，一个是哈希表。这样做的好处是即能进行高效的范围查询，也能进行高效的单点查询。

```c
typedef struct zset{
    dict *dict;
    zskiplist *zsl;
}zset;
```

zset 对象能支持范围查询（如zrangebyscore操作），这是因为它的数据结构采用了跳表。同时又能以常数复杂度获取元素权重（如zscore），这是因为它采用了哈希表进行索引。

### 跳跃表的实现

跳表是在链表的基础上改进过来的，实现了一种多层有序链表。

#### 跳表结构体zskiplist

* header属性指向跳表的头结点，可以实现在O(1)时间复杂度内反问头结点
* tail属性指向跳表尾结点
* length保存跳表的长度，实现O(1)复杂度获取链表长度，头结点不计算在内
* level跳表最大层数，便于在O(1)时间复杂度获取跳表中层⾼最⼤的那个节点的层数量

```C
typedef struct zskiplist { 
    // 表头节点和表尾节点 
    struct zskiplistNode *header, *tail; 
    // 表中节点的数量 
    unsigned long length; 
    // 表中层数最大的节点的层数 ，最大为32层
    int level; 
} zskiplist;
```

#### 跳表结点结构体zskiplistnode

* level数组可以包含元素，每个元素都有一个指向下一个结点的指针forward，通过这个指针我们可以快速的访问其他结点

  每次创建一个新的跳表结点，都会随机生成一个介于1到32之间的值作为level数组的大小，这个大小就是这个结点的层数

* forward前进指针，跳表结点的每层都有一个指向下一个姐弟啊的指针forward，用于从表头向表尾访问结点。

* span跨度，用于记录这个跳表结点的这一层到下一个跳表结点的这一层之间的距离。跨度是用来计算结点的排位：在查找某个结点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标结点在跳跃表中的排位。

* backWord后退指针，后退指针用于从跳表尾向跳表头访问结点，因为每个跳表结点只有一个backword，所以每次只能向后退一个结点，换句话说，只有level为0的结点有后退指针。

* score和ele，结点的分值score是一个double类型的浮点数，用于对跳跃表中的结点排位

  ele保存的是当前结点的值，是一个sds字符串类型

在同一个跳跃表中，各个结点保存的成员对象必须是唯一的，但是多个结点保存的分值却可以是相同的，分值相同的结点将按照成员对象在字典序中的大小进行排序，成员对象较小的结点会排在前面，成员对象较大的结点会排在后面。

```C
typedef struct zskiplistNode { 
    // 结点值
    sds ele;
    // 分数，用于排序结点
    double score; 
    // 层级
    struct zskiplistLevel { 
        // 后驱结点 
        struct zskiplistNode *forward; 
        // 本层的后继结点跨过第一层多少结点，用于计算节点索引
        unsigned long span; 
    } level[]; 
    // 指向前驱结点，一个结点只有第一层有前驱结点，因此skiplist的第一层是一个双向链表
    struct zskiplistNode *backward; 
} zskiplistNode;
```

### 跳表层数设置

在执行插入操作的时候，层数的设置是随机的过程，这个过程很关键，他对跳表的统计性特征有很重要的影响。但是层数不是一个服从均匀分布的随机数，它的计算过程如下：

* 首先，每个结点肯定都有第1层指针（每个结点都在第1层链表里）
* 如果一个结点有第i层（i>=1）指针（即结点已经在结点已经在第1层到第i层链表中），那么它有第i+1层指针的概率为p
* 结点最大的层数不允许超过一个最大值，记为MaxLevel。

随机计算层数的伪代码为：

```java
public int randomLevel(){
    int level = 1;
    // random()返回一个[1,0）的随机数
    while(random()<p && level < MaxLevel){
        level = level + 1;
    }
    return level;
}
```

randomLevel()函数中有两个参数，一个是p，一个是MaxLevel。在Redis的skipList实现中，这两个参数的取值为

```
p = 1/4
MaxLevel = 32
```

### 插入操作



## 整数集合

整数集合intset是集合键（set）的底层实现之一。当一个集合值包含整数元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。

### 整数集合的实现

整数集合本质上是一块连续内存空间。

```C
typedef struct intset { 
    // 编码方式
    uint32_t encoding; 
    // 集合包含的元素数量 
    uint32_t length; 
    // 保存元素的数组 
    int8_t contents[]; 
} intset;
```

存储的各个项在contents中从小到大排序，并且不包含重复的内容

contents数组用于保存元素，虽然contents被声明为int8_t类型的数组，但是实际上contents数组并不保存任何int8_t类型的元素，contents数组的真正类型取决于intset结构体中encoding属性的值，例如：

* 如果encoding属性值为intset_enc_int16，那么contents就是一个int16_t 类型的数组，数组中每一个元素的类型都是int16_t；
* 如果encoding属性值为intset_enc_in32，那么contents就是一个int32_t 类型的数组，数组中每一个元素的类型都是int32_t；
* 如果encoding属性值为intset_enc_int64，那么contents就是一个int64_t 类型的数组，数组中每一个元素的类型都是int64_t；

不同类型的contents数组，意味着数组的大小也会不同。

### 整数集合升级操作

每当我们要将一个新元素添加到整数集合里面时，并且新元素的类型比整数集合现在所有元素的类型都要长时，整数集合需要先进行升级，然后才能将新元素添加到整数集合里面。

在升级的过程中也会保持contents中的数据是有序的。

升级操作步骤：

1. 根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间
2. 将底层数组的元素都转换成和新元素相同的类型，并将类型转换后的元素放置到正确位置上，而且在放置元素的过程中，需要继续维持底层数组的有序性不变。
3. 将新元素添加到底层数组里面。

所以向整数集合添加 新元素的时间复杂度为O（N）。 

**整数集合不支持降级操作**

### 升级的好处

1. 提升灵活性，我们可以向整数集合中添加不同类型的整数，因为底层为我们实现了升级操作。
2. 节约内存，只有在需要使用到大空间的时候，才进行升级操作，使用大空间，因此可以节省内存。

## redis为什么使用跳表而不使用平衡树？

可以从内存占用、对范围查找的支持以及实现的难易程度三个方面进行分析。

1. 跳表在实现相同功能的情况下使用的内存空间少，当增加一层的概率为0.25的时候，跳表平均一个结点的指针占用是1.33，而平衡树需要的是固定的2，同时可以通过更改这个概率来改变跳表的内存占用
2. 跳表对于范围查找的支持比平衡树要好。平衡树的范围查找要更复杂。对于平衡树，我们需要使用中序遍历才能查找到一个范围的数据，但是跳表只需要遍历第0层就可以实现。
3. 平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除操作只需要修改相邻结点的指针，操作简单又快

# 对象

Redis并没有直接















