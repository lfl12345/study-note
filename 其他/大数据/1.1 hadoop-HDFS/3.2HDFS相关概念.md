## 块的概念

* 整个HDFS中最核心的概念
* 与普通文件系统的联系：为了分摊磁盘读写开销，也就是为了在大量数据间分摊磁盘寻址的开销
* 区别：这个块要比普通文件系统大的很多

## 为什么这样设置

* 支持面向大规模数据存储
* 降低分布式结点的寻址开销：访问HDFS文件需要三级寻址，先元数据目录，接着数据结点，最后从数据结点取数据。 但是也不是越大越好，受到MapReduce的限制。

## 缺点

* 如果块过大会导致MapReduce就一两个任务在执行，完全牺牲了MapReduce的并行度，发挥不了分布式并行的处理效果。

## 抽象快的好处

* 支持大规模文件存储：突破单机存储上线
* 简化系统设计
* 适合数据备份：一个块会被冗余的存储到别的块

## 名称结点

* 主节点，相当于整个HDFS集群的关键，里面存储这元数据，从中得知块到低存储在那个数据结点
* 元数据的两大结构
  * FsImage：用于保存系统文件树，以及文件树中所有的文件以及文件夹的元数据，没有保存块到低存储在哪，这个存储信息是在程序运行的过程中，数据结点和名称结点不断地沟通中保存的，都是保存在内存当中。
    * 文件的复制等级
    * 修改和访问的时间
    * 访问权限
    * 块大小以及组成文件的块
  * EditLog：可以记录对数据进行的诸如创建、删除、重命名等操作
* 启动以后，底层的FsImage 被加载到内存中和EditLog进行合并，得到最新的元数据。然后名称节点保留新版的FsImage 把旧版的删掉，同时创建一个空的EditLog。
* 为什么设置EditLog，因为FsIMage 很大，如果每次操作都去修改fsimage ,效果会不好，但是EditLog也会增大，执行效果也会变得不好，所以我们需要第二名称结点

![image-20210725135110760](C:\Users\三夏三十\AppData\Roaming\Typora\typora-user-images\image-20210725135110760.png)

## 第二名称结点

* 第二名称结点会定期的与名称节点进行通信，在某个阶段会告诉名称节点停止使用EditLog文件，然后名称结点会形成一个edits.new，把接下来的更新写到这个文件中去，把原来的让第二名称结点取走，第二名称结点通过HTTPget的方式把FSimage和EditLog都拷贝到本地，然后在本地做合并，形成一个新的FsImage，然后发送个名称节点

![image-20210725135747215](C:\Users\三夏三十\AppData\Roaming\Typora\typora-user-images\image-20210725135747215.png)

## 数据结点

* DataNode：实际存储、取数据的，数据被保存到本地的Linux系统当中
* 

## 元数据

* 名称结点中要存储元数据
* 元数据中存储着
  * 文件是什么
  * 文件被分为多少块
  * 每个块和文件是怎么映射的
  * 每个块被存储在那个服务器上面