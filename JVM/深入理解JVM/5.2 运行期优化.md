# Java运行期优化

## 即时编译器

当虚拟机发现某个方法或者代码块的运行特别频繁，就会把这些代码认定为"热点代码"，为了提高热点代码的执行效率，在运行时，虚拟机会把这些代码编译成本地机器码，并以各种手段尽可能地进行代码优化，运行时完成这个任务的后端编译器本**称为即使编译器**

## 即时编译器运行过程

### 为什么要使用解释器和即时编译器并存的架构？

**解释器优点：**

* 提高程序的响应速度（省去编译的时间），并且可以节约内存

**编译器优点：**

* 提高运行效率

因此解释器和编译器相辅相成地配合工作，使程序运行达到最优的效果。

### 为什么要实现两个不同的JIT编译器？

HotSpot虚拟机内置了两个即时编译器：

* Client Compiler（C1编译器）
* Server Compiler（C2编译器）

在分层编译工作模式出现之前，HotSpot虚拟机通常是采用解释器和其中一个编译器直接搭配的工作方式，程序使用哪种编译器，取决于宿主机器的硬件性能，用户也可以自己选择使用客户端模式还是服务端模式。

### 什么是虚拟机的分层编译？

由于即时编译器编译本地代码需要占用程序运行时间，通常要编译出优化程度越高的代码，所花费的时间便会越长，而且想要编译出优化程度更高的代码，解释器可能还要替编译器收集性能监控信息，这对解释执行阶段的速度也有所影响。

为了在程序启动相应速度和运行效率之间达到最佳平衡，HotSpot虚拟机在编译子系统中加入了分层编译的功能。

**编译层次的划分**：

1. 程序纯解释执行，并且解释器不开启性能监控功能
2. 使用客户端编译器将字节码编译为本地代码运行，进行简单可靠的稳定优化，不开启性能监控功能
3. 仍然使用客户端编译执行，仅开启方法以及回边次数统计等有限的性能监控功能
4. 仍然使用客户端编译执行，开启全部性能监控，除了第二层的统计信息外，还会收集如分支跳转、虚方法调用版本等全部统计信息
5. 使用服务端编译器将字节码编译为本地代码，相比客户端编译，服务端编译会启用更多编译耗时更长的优化。

实施分层编译后，解释器、客户端编译器和服务端编译器就会同时工作，热点代码都可能会被多次编译，用客户端编译器获取更高的编译速度，用服务端编译器来获取更好的编译质量。

### 如何判断热点代码，触发编译的条件？

什么是热点代码：

* 被多次调用的方法
* 被多次执行的循环体
  * 虽然被判断为热点代码的是循环体，但是即时编译是以方法为单位的，所以编译器还是会将整个方法编译。

**触发编译的条件：**

要知道某段代码是不是热点代码，是不是需要触发即时编译，这个行为称为"热点探测"，热点探测判定方法有两种

* 基于采样的热点探测：jvm会周期性的检查各个线程的调用栈顶，如果发现某个方法进程出现在栈顶，那这个方法就是热点方法。
  * 优点：简单高效，容易获得方法的调用关系
  * 缺点：很难紧缺的确认一个方法的热度，容易因为收到阻塞或别的外界因素的影响而扰乱热点探测
* 基于计数器的热点探测：jvm为每个方法建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值，就认为是热点方法，
  * 优点：统计结果相对来说更准确
  * 缺点：实现麻烦，需要为每个方法建立并维护计数器，并且不能直接获取到调用关系

HotSpot虚拟机使用第二种基于计数器的热点探测方法，为了实现热点计数，HotSpot为每个方法准备了两类计数器：**方法调用计数器和回边计数器（回边指在循环边界往回跳转）**

**方法调用计数器：**

当一个方法被调用时，jvm会先检查方法是否存在被即使编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在，则将该方法的调用计数器值加一，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阈值。一旦超过阈值，将会行即时编译器田炯一个发方法的代码编译请求。

当超过一定时间限度，如果方法的调用次数任然不足以让它提交即时编译器编译，那该方法的调用计数器就会被减少一半，这个过程被称为方法调用计数器热度的衰减，而这段时间就称为此方法统计的半衰周期。进行热度衰减的动作是在虚拟机垃圾回收的时候顺便做的。

**回边技术器：**

在字节码中遇到控制流向后跳转的指令就称为"回边"，很显然建立回边计数器统计的目的是为了触发栈上的替换编译。

当解释器遇到一条回边指令时，会先查找将要执行的代码片段是否有已经编译好的版本，如果有的话，他将会优先执行已有编译的代码，否则就把回边计数器的值加一，然后判断方法调用计数器与回边计数器值之和是否超过回边计数器的阈值。当超过阈值的时候，将会提交一个站上替换编译请求，并且把回边计数器的值稍微降低一些，以便继续在解释器中执行循环，等待编译器输出编译结果。

回边计数器没有计数热度衰减的过程。

**热点代码探测流程**

![image-20220128130720210](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220128130720210.png)

## 经典编译优化技术

### 方法内联（最重要）

目的是：去除方法调用的成本（如建立栈帧等），并为其他优化建立良好的基础，所以一般将方法内两放在优化序列最前端，因为它对其他优化有帮助。

由于java大多数方法都是虚方法，只有在运行的时候才能判断调用的方法到底是那个，无法再编译的时候就确定，因此jvm引入了一种名为**类型继承关系分析**（CHA）的技术来解决虚方法内联的问题。

**对于虚方法：**

* 直接进行方法内联

**对于非虚方法：**

向CHA查询此方法在当前程序下是否有多个目标可选择：

* 只有一个目标的话，
  * 先对这个目标进行内联，这种内联被称为守护内联
  * 如果之后的执行中，虚拟机没有加载到会令这个方法接收者的继承关系发生改变的新类，则该内联代码可以一直使用；
  * 如果加载到导致继承关系发生变化的新类，就抛弃已编译的代码。
* 有多个目标：
  * 使用内联缓存，未发生方法调用前，内联缓存为空；
  * 第一次调用发生后，记录调用方法的对象的版本信息；
  * 之后的每次调用都要先与内联缓存中的对象版本信息进行比较；
    - 版本信息一样，继续使用内联代码；
    - 版本信息不一样，说明程序使用了虚方法的多态特性，这时取消内联，查找虚方法进行方法分派。

### 逃逸分析（最前沿）

基本原理：分析对象动态作用域，如果没有被外部引用，这种对象称为从不逃逸对象，如果被别的的方法引用则称为方法逃逸对象，如果被别的线程引用，则称为线程逃逸对象。

根据对象的逃逸程度不同可以采取不同的优化方式：

- **栈上分配：** 对于不会逃逸到线程外的对象，可以在栈上分配内存，这样这个对象所占用的空间可以随栈帧出栈而销毁，减小 GC 的压力。栈上分配可以支持方法逃逸，不吃支持线程逃逸
- **标量替换（重要）：**
  - 标量：基本数据类型和 reference。
  - 不创建对象，而是将对象拆分成一个一个标量，然后直接在栈上分配，是栈上分配的一种实现方式。
  - HotSpot 使用的是标量替换而不是栈上分配，因为实现栈上分配需要更改大量假设了 “对象只能在堆中分配” 的代码。
  - 不允许对象逃逸出方法范围内
- **锁消除：** 不会逃逸到线程外的变量如果同步的化，可以把锁消除掉。

### 公共子表达式消除（语言无关）

如果一个表达式 E 已经计算过了，并且从先前的计算到现在，E 中所有变量值都没有发生变化，则 E 为公共子表达式，无需再次计算，直接用之前的结果替换。

### 数组边界检查（语言相关）

在循环中使用循环变量访问数组，如果可以判断循环变量的范围在数组的索引范围内，则可以消除整个循环的数组范围检查

