# Unix下5种IO模型

UNIX 系统下的 I/O 模型有 5 种：

* 阻塞IO
* 非阻塞IO
* IO复用（select、poll、epoll）
* 信号驱动IO
* 异步IO（POSIX的aio_系列函数）

**如何理解UnixIO模型中的阻塞与非阻塞、同步与异步：**

* 区分同步和异步：同步是一种可靠的有序的运行机制，当我们使用同步操作时，后续操作是等待当前调用返回才进行下一步；而异步相反，其他任务不需要等待当前调用的返回就可以执行，通常依靠事件、回调等机制来实现任务间的次序关系。

> 感觉同步和异步可以用来描述两个进程之间的关系，也可以用来描述方法调用。例如同步可以指两个进程之间是同步的，比如网络消息的发送，也可以用来指两个方法之间是同步的。

* 阻塞和非阻塞：在进行阻塞操作时，当前进程会处于阻塞状态，无法从事其他任务，只有当条件就绪才能继续，比如 ServerSocket 新连接建立完毕，或数据读取、写入操作完成；而非阻塞则是不管条件（数据）是否就绪直接返回，进程不会因为数据没有准备好而进入阻塞状态。

**一个输入操作通常包含两个不同的阶段：**

* **用户线程等待内核将数据从网卡（或者其他数据源）拷贝到内核空间，此时数据算是准备好了**
* **从内核向用户空间的进程复制数据**

**各种IO模型的区别就是：它们实现这两个步骤的方式是不一样的**

对于套接字上的输入操作，第一步通常涉及等待数据从网络中到达，当等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区赋值到应用进程缓冲区。

## 阻塞式IO模型

最流向 IO模型是阻塞式IO模型（blocking IO）。

![image-20220105110816521](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220105110816521.png)

进程调用recvfrom，其系统调用直到数据报到达且被复制到应用进程的缓冲区中或者发生错错误才返回。最常见的错误时系统调用被信号中断。进程在从调用recvfrom开始到它返回的整段时间内是被阻塞的，进程让出CPU，内核等待数据从网络中到达内核中的缓冲区，然后唤醒进程，进程的系统调用recvfrom成功的从内核的缓冲区将数据拷贝到用户\进程缓冲区，然后recvfrom成功返回，应用进程开始处理数据报。

## 非阻塞IO模型

进程把一个套接字设置成非阻塞是在通知内核：当所请求IO操作非得把本进程投入睡眠才能完成时，不要把本进程投入睡眠，而是返回一个错误。

![image-20220105111337849](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220105111337849.png)

前三次recvfrom时没有数据可返回，因此内核转而立即返回一个错误。第四次调用recvfrom时已经有一个数据准备好，它被复制到应用进程缓冲区，于是recvfrom成功返回，进程接着处理数据。

当一个应用进程像这样对一个非阻塞描述符循环调用recvfrom时，我们称之为**轮询**（polling）。应用进程持续轮询内核，已查看某个操作是否就绪。这么做往往消耗大量的CPU时间。

## IO复用模型

我们可以使用select、poll、epoll实现IO复用，这样进程会阻塞在这三个系统调用中的某一个上，而不是阻塞在真正的IO系统调用上。

![image-20220105111825388](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220105111825388.png)

进程阻塞在select系统调用上，等待数据报套接字变为可读。当select返回套接字可读这一条件时，我们调用recvfrom把所读数据报复制到应用进程缓冲区。

IO复用和阻塞IO相比好像没有什么优势，都会阻塞到一个系统调用上，然后IO系统调用有数据之后，应用进程才可以读取数据，事实上由于使用select需要两个而不是单个系统调用，IO复用还稍有劣势。但是IO复用有一个很大的优点，就是我们可以同时等待多个描述符就绪。

IO复用模型和多线程中使用阻塞式IO模型很相似。

## 信号驱动式IO模型

我们可以使用信号，让内核在描述符就绪时发送SIGIO信号通知我们。这种模型就是信号驱动式IO模型（signal-driven IO）

![image-20220105112810572](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220105112810572.png)

进程首先开启套接字的信号驱动式IO功能，然后通过sigaction系统调用安装一个信号处理函数。该系统调用立即返回，进程可以继续工作，也就是进程没有被阻塞。当数据报准备好读取数据时，内核就为该进程产生一个SIGIO信号。进程随后就可以在信号处理函数中调用recvfrom读取数据，并通知主循环数据已准备好待处理，也可以立即通知主循环让它读取数据报。

无论如何处理SIGIO信号，这种模型的优势在于等待数据报到达期间进程不被阻塞。主循环可以继续执行，只要等待来自信号处理函数的通知：既可以是数据已准备好被处理，也可以是数据报已准备好被读取。

## 异步IO模型

异步IO由POSIX规范定义。一般来说，这些异步函数的工作机制是：告诉内核启动某个操作，并让内核在整个操作（包括将数据从内核复制到我们自己的缓冲区）完成后通知我们，这种模型与信号驱动IO模型的主要区别是：信号驱动模型是由内核通知进程何时启动一个IO操作，而异步IO模型是由内核通知我们IO操作何时完成。

![image-20220105114859580](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220105114859580.png)

进程调用aio_read函数（POSIX异步IO函数以aio或lio开头），给内核传递文件描述符，缓冲区指针，缓冲区大小（与read相同的三个参数）和文件偏移（与lseek类似），并告诉内核当整个操作完成时如何通知我们。该系统调用立即返回，而且在等待IO完成期间，进程不被阻塞。

本例子中我们假设要求内核在操作完成时产生某种信号，该信号直到数据已复制到应用进程缓冲区才产生，这一点不同于信号驱动IO模型。

## 各种IO模型的比较

这五种不同的IO模型，前四种模型的主要区别在于IO操作的第一个阶段，因为他们第二个阶段都是一样的，都是由进程通过系统调用将数据复制到进程的缓冲区中，也就是数据从内核复制到调用者的缓冲区期间，进程阻塞于recvfrom调用，反之，异步IO模型在这两个阶段都是内核处理的，不同于其他四种模型。

## 同步IO和异步IO对比

POSIX把这两个术语定义如下：

* 同步IO操作导致请求进程阻塞，直到IO操作完成
* 异步IO操作不导致请求进程阻塞

![image-20220105115625879](C:\Users\lfl\AppData\Roaming\Typora\typora-user-images\image-20220105115625879.png)

根据上述定义，前四种模型都是同步IO模型，因为真正的IO操作将阻塞进程，只有异步IO模型才是真正的异步IO。

## Socket编程



## IO多路复用

### BIO有什么缺点？

BIO中的B表示的是阻塞的意思，使用ServerSocket绑定端口之后，服务端会监听该端口，等待accept事件，accept函数会阻塞当前主线程。当我们收到accept事件时，程序就会拿到一个客户端与服务端连接的socket，针对这个socket服务端可以进行读写，但是socket的读写方法都是会阻塞当前线程的，一般我们会使用多线程的方式进行c/s交互，但是这种解决方式当客户端数量增多的时候，服务端的线程数量就会变得很多，服务端的负载变大，线程的上下文切换也会大大增加服务端的负载。

### 针对C10K这样的需求，NIO靠什么解决的问题？

BIO之所以处理不了C10k这样的需求，就是因为BIO是阻塞操作的。因为NIO API具有非阻塞特性，就可以使用一个线程去检查n个socket。NIO的包为我们提供了一个selector选择器，我们需要把要检查的socket注册到selector中，然后主线程阻塞在selector的select方法里，当选择器发某个socket就绪了，就会唤醒主线程，主线程可以通过selector获取到就绪的socket，之后进行相应的处理。

selector其实是Java底层使用native api进行包装的，在底层是jvm虚拟机去使用系统调用实现的。

### 多路复用操作系统函数select()工作原理？

我们每次调用select函数的时候，都会涉及到**用户态和内核态的切换**，同时需要传递需要检查的socket集合，其实就是需要检查的文件描述符(fd)。

select函数被调用之后，内核首先会按照fd集合去检查内存中的socket套接字状态，这个检查的复杂度是O(N)的，然后检查完一遍之后，如果有就绪的socket，就直接返回，不会阻塞当前的线程，否则就说明当前文件描述符集合没有就绪状态的socket，这时候就需要阻塞当前调用的线程，直到某个socket有数据之后，才会唤起线程。

select去监听文件描述符的时候，文件描述符的数量是有限制的，默认最大可以监听1024个。

### 多路复用操作系统函数select()默认监听socket数量为什么是1024？

因为fd_set(select函数的参数之一)这个参数的结构是一个bitmap位图结构，这个结构就是一个长的二进制数，这个bitmap的默认长度是1024个bit。

默认值给1024，出于性能考虑。因为当内核监听到某个socket就绪之后，就会对位图进行置位，表示socket已经就绪了，但是用户的线程并不知道到底哪个fd就绪了，只知道就绪的个数，因此还需要一遍遍历去寻找就绪的fd。因此如果bitmap太长，程序的运行时间将会增加，也不利于用户态到内核态的参数传递（数据拷贝），系统调用速度会降低。

### 多路复用操作系统函数select()第一遍O(N)未发现就绪socket，后续在某个socket就绪以后，select如何感知？是不停轮询吗？

这个和操作系统的进程调度以及中断有关系。

select函数第一遍轮序如果没有发现就绪的socket，就会把当前进程保留给需要检查的socket等待队列中。socket的结构有三块核心区域，分别是读缓存、写缓存和等待队列。select函数把当前线程放到每一个需要检查的socket等待队列中之后，会把当前进程从工作队列中移除，当前进程被挂起，select函数不在会被运行。

如果客户端往服务端发送数据，数据从网线到网卡，网卡在到DMA硬件的这种方式将数据写入到内存中，着整个过程CPU是不参与的，当整个过程完成之后，就会触发网络数据传输完毕的中断程序，这个中断程序会把CPU正在运行的程序停掉，CPU就会处理中断程序的逻辑。

中断程序的逻辑大概为根据内存中的数据包，分析出数据包是那个socket的数据，因为数据传输使用的是tcp/ip协议，保证数据包是有端口号的，根据端口号找到socket实例，找到之后，把数据导入socket的读缓冲区，导入完成只有就会检查socket的等待队列是否有等待者，如果有的话，就把等待者移到工作队列中，中断程序到这一步就执行完了。

进程回到工作队列中，有机会获取CPU时间片，此时select函数检查就会发现已经有就绪的fd，然后将此fd打上标记，返回。

### 多路复用操作系统函数poll和select主要区别？

最大的区别就是传入的参数不同了。

select使用的bitmap结构，poll使用的是数组结构（也有说是链表），表示需要检查的socket集合，主要是为了解决select bitmap长度是1024这个问题，poll使用数组没有这个限制，就可以让线程监听超过1024个socket。

### 为什么会有epoll这个技术，他产生的背景是什么？

主要是为了解决select和poll的缺陷。

select和poll的缺陷：

* select和poll需要进程传入需要监听的文件描述符集合，牵扯到用户态内核态转换，参数传递，比较耗费性能。但是每次可能只有几个fd就绪，select和poll函数在内核层面不会保留任何数据信息，所以说每次调用都需要数据拷贝。
* select和poll返回值是一个int，只能代表有多少fd就绪了，没办法表示那个socket就绪，需要轮询使用新的系统调用去判断那个socket就绪，这时就走了弯路。

### epoll函数的工作原理是什么？

epoll就是为了解决以上两种缺陷。这样就需要epoll函数在内核空间内，对应一个数据结构去存储数据，这个数据结构其实就是一个eventpoll对象，eventpoll对象可以通过epoll_create去创建，创建完成之后，系统返回一个eventpoll对象id，相当于我们在内核中开辟了一小块空间，我们也知道这块空间的位置。

eventpoll的结构有两块重要的区域，一块是存放需要监听的socket文件描述符列表，另一块是就绪列表。还有一个等待队列

epoll_ctl系统调用可以通过epollid增删改查内核空间上的eventpoll对象的注册的fd

epoll_wait通过epollid监听对应eventpoll实例上注册的fd，默认阻塞线程

### eventpoll对象的就绪列表数据是如何维护的？

这个过程和select函数判断就绪状态的socket过程十分类似。

首先我们会使用epoll_ctl函数讲一个fd添加到eventpoll实例中，内核程序会将当前eventpoll对象追加到socket等待队列当中，然后等待中断程序执行完毕，但是中断程序发现等待队列内等待的不是一个进程，是一个eventpoll对象的引用，然后就根据eventpoll引用，将当前的socket引用追加到eventpoll的就链表的末尾。

eventpoll还有一个等待队列，等待队列中存放的是调用epoll_wait的进程，当中断程序将socket追加到链表之后，就会检查eventpoll等待队列中的进程，将进程放入工作队列中，进程就可以继续执行，然后epoll_wait函数被执行，返回。

### epoll是如何实现获取就绪的socketfd的？

调用epoll_wait会传入一个数组指针，epoll_wait正常返回之前，会把就绪的socket事件、信息拷贝到这个数组里

### epoll_wait 是否可以设置为非阻塞的？

可以。默认是非阻塞的，有参数可以设置阻塞的时间长短，如果设置为0，表示非阻塞，调用之后立即返回

### eventpoll对象中存放需要检查的socket信息是采用什么数据结构？为什么？

采用的是红黑树的数据结构。因为eventpoll中的socket经常有增删改查的需求，这个需求红黑树一定很合适，它能保持一种相对稳定的查找效率，复杂的应该是O(LogN)。

# Java中的IO模型

## Java BIO

### 伪异步IO编程

如果进来一个socket，使用一个线程去处理socket发送的数据，那么随着客户端并发访问增加，服务端将呈现1:1的线程开销，访问量越大，系统将发生线程栈溢出，线程创建失败。

使用线程池和任务队列的方式可以实现一种伪异步IO通信框架，当客户端接入时，将客户端的Socket封装成一个Task（该任务实现Runnable接口）交给后端的线程池中处理。JDK的线程池维护一个消息队列和N个活跃的线程，对消息队列中Socket任务进行处理，由于线程池可以设置消息队列大小和最大线程数，因此，它占用的资源时可控的，无论多少客户端并发访问，都不会导致资源的耗尽和宕机。

总结

* 伪异步IO采用了线程池实现，因此避免了为每个请求创建一个独立线程而造成线程资源耗尽的问题，但是由于底层依然是采用的同步阻塞模型，因此无法从根本上解决问题。
* 如果单个消息处理的缓慢，或者服务器线程池中的全部线程都被阻塞，那么后续socket的IO消息将在队列中牌堆。新的Socket请求将被拒绝，客户端回发生大量连接超时。

### BIO模式下的端口转发思想

## Java NIO

### Java NIO基本介绍

Java NIO（New IO）也有人称之为java non-blocking IO 是从Java 1.4 版本开始引入的一个新的IO API，可以代替标准的Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持**面向缓冲区**的、基于**通道**的IO操作。NIO讲义更加高效的方式进行文件的读写操作。

NIO可以理解为非阻塞IO，传统的IO的read和write只能阻塞执行，线程在读写IO期间不能干其他事情，比如调用socket.read()时，如果服务器一直没有数据传输过来，线程就一直阻塞，而NIO中可以配置socket为非阻塞模式。

NIO相关类都被放在java.nio包以及子包下，并对原来的Java.io包中的很多类进行改写。

NIO有三大核心部分：Channel(通道)、Buffer(缓冲区)、Selector(选择器)

JavaNIO的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直到数据变得可以读取之前，改线程可以继续做其他任何事情。非阻塞写也是如此，一个线程请求写入一些数据到某个通道，但是不需要等待他完全写入，这个线程同时可以去做别的事情。

通俗理解：NIO可以做到用一个线程来处理多个操作。

### NIO 和 BIO 的比较

* BIO以流的方式处理数据，而NIO以块的方式处理数据，块IO的效率比流IO高很多（有待考证）

* BIO是阻塞的，NIO是非阻塞的
* BIO是基于字节流和字符流进行操作，而NIO基于Channel(通道)和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入通道中。Selector(选择器)用于监听多个通道事件（比如：连接请求，数据到达请求），因此可以使用单线程监听多个客户端通道

| NIO                       | BIO                   |
| ------------------------- | --------------------- |
| 面向缓冲区（Buffer）      | 面向流（Stream）      |
| 非阻塞（Non blocking IO） | 阻塞IO（Blocking IO） |
| 选择器（Selectors）       |                       |

### NIO 三大核心原理

NIO 有三个核心部分：**Channel（通道）、Buffer（缓冲区）、Selector（选择器）**

#### Buffer缓冲区

缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该快内存。相比较直接对数组的操作，Buffer API更容易操作和管理。

#### Channel通道

Java NIO的通道类似流，但又有些不同：既可以从通道中读取数据，又可以写数据到通道。但流的（input或output）读写通常是单向的，通道可以非阻塞读取和写入，通道可以支持读取或写入缓冲区，也可以支持异步的读写。

#### Selector选择器

Selector是一个Java NIO组件 ，能检查一个或多个NIO通道，并确定哪些通道已经准备好进行读取或写入。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接，提高效率。

* 每个channel都会对应一个Buffer
* 一个线程对应一个Selector，一个Selector对应多个channel(连接)
* 程序切换到那个channel是由事件决定的
* Selector会根据不同的事件，在各个通道上切换
* Buffer就是一个内存块，底层是一个数组
* 数据的读取写入是通过Buffer完成的，BIO中要么是输入流，或者是输出流，不能双向。但是NIO的Buffer是可以读也可以写。
* Java NIO系统的核心在于：通道（Channel）和缓冲区（Buffer）。通道表示打开的IO设备（例如：文件，套接字，网络中的连接），若需要使用NIO系统，需要获取用于IO设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理。简而言之，Channel负责传输，Buffer负责存取数据。

### NIO核心一：缓冲区 Buffer

一个用于特定基本数据类型的容器。有java.nio包定义，所有缓冲区都是Buffer抽象类的子类。Java NIO中的Buffer主要用于与NIO通道进行交互，数据是从通道读入缓冲区，从缓冲区写入通道。

#### Buffer类及其子类

Buffer就像一个数组，可以保存多个相同类型的数据，根据数据类型的不同，有一下Buffer常用子类：

* ByteBuffer（抽象类）
  * MappedByteBuffer
  * DirectByteBuffer
  * HeapByteBuffer

* CharBuffer
* ShortBuffer
* IntBuffer
* LongBuffer
* FloatBuffer
* DoubleBuffer

上述Buffer类都采用相似的方法进行管理数据，只是各自管理的数据类型不同而已，都是通过如下方法获取一个Buffer对象：

```java
static xxxBuffer allocate(int capacity):创建一个容量为capacity的xxxBuffer对象
```

#### 缓冲区基本属性

Buffer中重要概念：

* 容量（Capacity）
* 限制（limit）

#### 直接与非直接缓冲区

byte buffer可以使两种类型，一种是基于直接内存（也就是非堆内存），另一种是非直接内存（也就是堆内存）。对于直接内存来说，JVM将会在IO操作上具有更高的性能，因为他直接作用域本地系统的IO操作。而非直接内存，也就是堆内存中的数据，如果要做IO操作，会先从本进程内存复制到直接内存中，再利用本地IO处理。

从数据流的角度，非直接内存是下面这样的作用链：

```tex
本地IO--》直接内存--》非直接内存--》直接内存--》本地IO
```

而直接内存是：

```java
本地IO--》直接内存--》本地IO
```

很明显，在做IO处理时，比如网络发送大量数据时，直接内存会具有更高的效率。直接内存使用allocateDirect创建，但是它比申请普通的堆内存需要消耗更高的性能。不过，这部分数据是在JVM之外的，因此他不会占用应用的内存，所以当有很大的数据需要缓存，并且它的生命周期又很长，那么就比较适合使用直接内存。知识一般来说，如果不是能带来很明显的性能提升，还是推荐使用堆内存。可以使用isDirect()方法来确定字节缓冲区是堆内存还是直接内存。

直接内存使用场景

* 有很大的数据需要存储，它的生命周期长
* 适合频繁的IO操作，比如网络并发场景

### NIO核心二：Channel通道

Channel表示IO源与目标打开的连接。Channel类似于传统的流，只不过Channel本身不能访问数据，Channel只能与Buffer进行交互。

NIO的Channel类似于流，区别如下：

* 通道可以同时进行读写，而流只能读或者只能写
* 通道可以实现异步读写数据
* 通道可以从缓冲区读数据，也可以写数据到缓冲区

BIO中的Stream是单向的，而NIO中的通道是双向的。

Channel在NIO中是一个接口

```java
public interface Channel extends Closeable{}
```

#### 常用的Channel实现类

* FileChannel：用于读取、写入、映射和操作文件的通道
* DatagramChannel：通过UDP读写网络中的数据通道
* SocketChannel：通过TCP读写网络中的数据
* ServerSocketChannel：可以监听新进来的TCP连接，对每一个新进来的连接都会创建一个SocketChannel。

#### FileChannel类

可以通过对支持通道的对象调用getChannel方法获取通道。支持通道的类如下：

* FileInputStream
* FileOutputStream
* RandomAccessFile
* DatagramSocket
* Socket
* ServerSocket

还可以通过使用Files类的静态方法newBytesChannel获取字节通道，或者通过通道的静态方法open打开并返回指定通道。

### NIO核心三：Selector选择器

使用**多线程实现服务端**的缺点：

* 内存占用高
* 线程上下文切换成本高
* 只适合连接数少的场景

使用**线程池实现服务端**的缺点：

* 阻塞模式下，线程仅能处理一个socket连接
* 仅适合短连接场景

选择器Selector是SelectableChannel对象的多路复用器，Selector可以同时监控多个SelectableChannel的IO状况，也就是说，利用Selector可以使一个单独的线程管理多个Channel。Selector是非阻塞IO的核心。

Java的NIO，使用非阻塞IO的方式。可以使用一个线程，处理多个客户端连接，这时就要使用到Selector选择器

Selector能检测多个注册的通道上是否有事件发生（注意：多个Channel以事件的方式可以注册到同一个Selector），如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。

只有在连接\通道真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程。

避免了线程之间的上下文切换导致的开销。

#### 选择器selector的应用

## Java AIO

Java AIO（NIO.2）: 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的IO请求都是由OS先完成了再通知服务器应用去启动线程进行处理。

与NIO不同，当进行读写操作时，只需直接调用API的read和write方法即可，这两种方法均为异步的，对于读操作而言，当有流可读入时，操作系统会将可读入的流传入read方法打的缓冲区，对于写操作而言，当操作系统将write方法传递的流写完之后，操作系统主动通知应用程序

可以理解为read和write方法都是异步的，完成后会主动调用回调函数。在JDK1.7中，这部分内容被称为NIO.2，主要在java.nio.channels包下增加了下面四个异步通道

```java
AsynchronousSocketChannel
AsynchronousServerSocketChannel
AsynchronousFileChannel
AsycnhronousDatagramChannel
```

## Java IO模型总结

Java BIO：同步并阻塞，服务器试下模式为一个连接一个线程，即客户端有连接请求时服务器端就启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。

Java NIO：同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有IO请求时才启动一个线程进行处理。

Java AIO（NIO.2）：异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的IO请求都是由OS先完成了再通知服务器应用去启动线程进行处理。

BIO NIO AIO适用场景分析：

BIO方式适用不连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中

NIO方式适用于连接数目多而且连接比较短（轻操作）的架构，比如聊天服务器，并发局限不应用中，编程复杂。

AIO方式适用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程复杂