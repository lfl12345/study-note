# 虚拟机类加载机制

## 类加载时机

关于什么情况下要进行类的加载，jvm没有强制规定，但是jvm严格规定了有且只有六种情况必须进行类的初始化阶段，此时，类的加载必须进行。

在对一个类型进行**主动引用**的时候，会发生类的初始化：

* 遇到new、getstatic、putstatic或者invokestatic这四条字节码指令时，如果类型没有进行初始化，则需要先执行初始化阶段，能生成这四种字节码指令的java代码场景有：
  * 使用new关键字实例化对象
  * 读取或设置一个类型的静态字段的时候（被final修饰、已在编译器把结果放入常量池的静态字段除外）
  * 调用一个类的静态方法

* 使用java.lang.reflect包的方法对类型进行反射调用的时候，如果 类型没有进行过初始化，则需要先触发初始化
* 初始化类的时候 ，如果父类还没有初始化，则需要先触发父类的初始化
* 虚拟机启动的时候，会先初始化用户指定的一个要执行main方法的主类
* 当一个接口中有默认方法（使用default修饰），如果这个接口的实现类发生了初始化，接口需要先初始化

当一个类发生**被动引用**时，不会触发初始化操作：

* 通过子类引用父类静态字段，不会导致子类初始化；
* `Array[] arr = new Array[10];` 不会触发 Array 类初始化；
* `static final VAR` 在编译阶段会存入调用类的常量池，通过 `ClassName.VAR` 引用不会触发 ClassName 初始化。

### 接口和类初始化的区别

当一个接口初始化的时候不会要求父类也进行初始化，直到真正使用到父类接口的时候（引用接口中定义的常量）才会初始化。

## 类加载过程

### 类的声明周期

```java
加载 --> 验证 --> 准备 --> 解析 --> 初始化 --> 使用 --> 卸载
       |<------- 连接 ------->|
|<------------- 类加载 ---------------->|
```

类的生命周期一共有 7 个阶段，其中前五个阶段较为重要，统称为类加载，第 2 ~ 4 阶段统称为连接，加载和连接中的三个过程开始的顺序是固定的，但是执行过程中是可以交叉执行的。

### 加载

#### 加载阶段的任务：

1. 通过一个类的全限定名获取定义此类的二进制字节流（例如：将.class读入内存）
2. 将字节流的静态结构转化为方法区运行时数据结构
3. 在内存中生成一个代表这个类的Class对象，作为方法区这个类的各种数据的访问入口

#### 数组和非数组对比

相对于类加载过程的其他阶段，**非数组类型**的加载阶段是开发人员可控性最强的阶段，既可以使用内置的启动类加载器来完成，也可以使用自定义的类加载器。

对于数组类型来说，它本身不通过类加载器创建，而是由jvm直接在堆内存创建。但是数组的元素类型最终还是要依靠类加载器来完成加载。

* 如果元素类型是引用类型，则递归采用加载过程去加载这个组件类型。
* 如果不是引用类型，会把数组标记为与启动类加载器关联。

### 验证

验证是连接阶段的第一步，目的是确保class文件的字节流中包含的信息符合jvm规范的全部约束要求，保证这些信息被当做代码运行后不会危害虚拟机自身安全。

四个阶段：

*  文件格式验证：验证字节流是否符合Class文件格式的规范，并能被当前版本的虚拟机处理

  * 是否以正确的魔数开头
  * 主次版本号是否可以被接收

  只有通过了这个阶段的验证之后，这段字节流才被允许进入Java虚拟机内存的方法区中进行存储，所以后面三个验证阶段全部都是基于方法区，而不是直接读取、操作字节流了。

* 元数据验证：对字节码描述的信息进行语义分析

  * 这个类是否有父类
  * 这个类是否继承了不该被继承的类

* 字节码验证：通过数据流分析和控制流分析，确定程序语义是否合法、符合逻辑。主要是对Code属性进行校验。

* 符号引用校验：对类自身以外（常量池中的分钟符号引用）的各类信息进行匹配性校验。

验证阶段对于类加载是非常重要的，但是不是必须的，如果代码已经被反复验证过，那么就可以不用验证阶段。

### 准备

准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段。

这些变量的内存分配在方法区。

static分配空间和赋值是两步：

* 分配空间在准备阶段完成，空间分配完之后的值为默认值。
* 赋值在初始化阶段完成
  * 如果static变量是final修饰的非引用类型或者字符串常量，那么在编译阶段值就确定了，赋值在准备阶段完成
  * 如果static变量时final修饰的引用类型，赋值也会在初始化阶段完成。

### 解析

将常量池中的符号引用替换为直接引用的过程

* 符号引用：使用一组符号来表示引用的目标，不是地址
* 直接引用：可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。

对方法或者字段的访问，也会在解析阶段中对他们的可访问性进行检查

### 初始化

初始化阶段就是执行类构造器\<clinit>()方法的过程。

\<clinit>()方法由Javac编译器自动生成，它收集类中的所有静态变量的赋值动作和静态语句块中的语句合并而成，编译器收集的顺序是语句在源代码中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在他之后的变量可以赋值，但是不能访问。

\<clinit>()对于类和接口不是必须的。

执行一个类的\<clinit>()是必须先执行父类的\<clinit>()，但是接口不用先执行父接口的\<clinit>()，直到用到父接口的变量时才需要执行父接口的\<clinit>()

jvm保证\<clinit>()方法在多线程环境中被正确的加锁。

## 类加载器

java的类加载器一直保持着三层类加载器、双亲委派的类加载架构。

### 如何判断两个类“相等”

对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。

两个类**相等**的条件：

* 同一个类加载器加载
* 同一个Class文件
* 被同一个Java虚拟机加载

这里的**相等**包括了：

* 类的Class对象的equals方法、isAssignableFrom方法和isInstance方法
* 使用instanceof关键字做对象所属关系判定

### 类加载器的分类

#### 启动类加载器

使用C++语言实现，是虚拟机自身的一部分

加载<JAVA_HOME>/lib目录或者-Xbootclasspath 参数指定的路径

#### 扩展类加载器

使用java语言实现，继承自抽象类java.lang.ClassLoader

加载<JAVA_HOME>/lib/ext或者java.ext.dirs 系统变量指定的路径。

开发者可以将自己的代码放入扩展目录实现扩展Java SE的功能。

#### 应用程序类加载器

使用java语言实现，继承自抽象类java.lang.ClassLoader

他负责加载用户路径（ClassPath）上的所有类库，开发者同样可以直接在代码中使用这个类加载器。

### 双亲委派模式

工作过程：

* 如果一个类加载器收到类加载请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成
* 因此所有的加载请求最终都应该传送到最顶层的启动类加载器中
* 只有当父类加载反馈自己无法完成这个加载请求（它搜索的范围中没有找到所需要的类）时，子类加载器会尝试自己去加载类。

实现代码：

```java
protected Class<?> loadClass(String name, boolean resolve)
    throws ClassNotFoundException
{
    synchronized (getClassLoadingLock(name)) {
        // First, check if the class has already been loaded
        Class<?> c = findLoadedClass(name);
        if (c == null) {
            long t0 = System.nanoTime();
            try {
                if (parent != null) {
                    c = parent.loadClass(name, false);
                } else {
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
                // ClassNotFoundException thrown if class not found
                // from the non-null parent class loader
            }

            if (c == null) {
                // If still not found, then invoke findClass in order
                // to find the class.
                long t1 = System.nanoTime();
                c = findClass(name);

                // this is the defining class loader; record the stats
                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                sun.misc.PerfCounter.getFindClasses().increment();
            }
        }
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }
}
```

### 破坏双亲委派模式

* 如果子类覆盖父类的loadClass方法，则可以破坏双亲委派模式
* 





























