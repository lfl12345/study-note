# java内存分配策略

## 对象优先在Eden分配

大多数情况下，对象在新生代Eden区中分配，当Eden区没有足够内存进行分配时，虚拟机将发起一次Minor GC。

> **新生代和老年代的 GC 操作**
>
> - 新生代 GC 操作：Minor GC
>   - 发生的非常频繁，速度较块。
> - 老年代 GC 操作：Full GC / Major GC
>   - 经常伴随着至少一次的 Minor GC；
>   - 速度一般比 Minor GC 慢上 10 倍以上。

## 大对象直接进入老年代

大对象指的是需要大量连续内存空间的Java对象，最典型的大对象就是很长的字符串、元素很多的数组。

可以通过虚拟机参数`-XX:PretenureSizeThreshold`（单位字节）来指定**大于该值的对象**直接在老年代分配，这样做的**目的**就是避免大对象在Eden和Survivor区之间来回复制，产生大量的内存复制操作。

## 长期存活的对象进入老年代

虚拟机给每一个对象定义了一个对象年龄计数器，存储在对象头中。如果经历了一次Minor GC之后，并且被Survivor容纳，那么这个对象年龄加一，当他们年龄增加到一定程度（默认15），就会被升级到老年代。

## 动态对象年龄判定

如果在Survivor空间中低于或等于某年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。

## 空间分配担保

我们知道，新生代采用的是复制算法清理内存，每一次 Minor GC，虚拟机会将 Eden 区和其中一块 Survivor 区的存活对象复制到另一块 Survivor 区，但 **当出现大量对象在一次 Minor GC 后仍然存活的情况时，Survivor 区可能容纳不下这么多对象，此时，就需要老年代进行分配担保，即将 Survivor 无法容纳的对象直接进入老年代。**

这么做有一个前提，就是老年代得装得下这么多对象。可是在一次 GC 操作前，虚拟机并不知道到底会有多少对象存活，所以空间分配担保有这样一个判断流程：

- 发生 Minor GC 前，虚拟机先使用之前的经验平均值检查老年代的最大可用连续空间是否大于新生代所有对象的总空间；
  - 如果大于，Minor GC 一定是安全的；
  - 如果小于，虚拟机会查看 HandlePromotionFailure 参数，看看是否允许担保失败；
    - 允许失败：尝试着进行一次 Minor GC；
    - 不允许失败：进行一次 Full GC；
- 不过 JDK 6 Update 24 后，HandlePromotionFailure 参数就没有用了，规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行 Minor GC，否则将进行 Full GC。

























































